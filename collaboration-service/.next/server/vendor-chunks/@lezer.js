"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lezer";
exports.ids = ["vendor-chunks/@lezer"];
exports.modules = {

/***/ "(ssr)/./node_modules/@lezer/common/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@lezer/common/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultBufferLength: () => (/* binding */ DefaultBufferLength),\n/* harmony export */   IterMode: () => (/* binding */ IterMode),\n/* harmony export */   MountedTree: () => (/* binding */ MountedTree),\n/* harmony export */   NodeProp: () => (/* binding */ NodeProp),\n/* harmony export */   NodeSet: () => (/* binding */ NodeSet),\n/* harmony export */   NodeType: () => (/* binding */ NodeType),\n/* harmony export */   NodeWeakMap: () => (/* binding */ NodeWeakMap),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   Tree: () => (/* binding */ Tree),\n/* harmony export */   TreeBuffer: () => (/* binding */ TreeBuffer),\n/* harmony export */   TreeCursor: () => (/* binding */ TreeCursor),\n/* harmony export */   TreeFragment: () => (/* binding */ TreeFragment),\n/* harmony export */   parseMixed: () => (/* binding */ parseMixed)\n/* harmony export */ });\n// FIXME profile adding a per-Tree TreeNode cache, validating it by\n// parent pointer\n/// The default maximum length of a `TreeBuffer` node.\nconst DefaultBufferLength = 1024;\nlet nextPropID = 0;\nclass Range {\n    constructor(from, to) {\n        this.from = from;\n        this.to = to;\n    }\n}\n/// Each [node type](#common.NodeType) or [individual tree](#common.Tree)\n/// can have metadata associated with it in props. Instances of this\n/// class represent prop names.\nclass NodeProp {\n    /// Create a new node prop type.\n    constructor(config = {}) {\n        this.id = nextPropID++;\n        this.perNode = !!config.perNode;\n        this.deserialize = config.deserialize || (() => {\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n    }\n    /// This is meant to be used with\n    /// [`NodeSet.extend`](#common.NodeSet.extend) or\n    /// [`LRParser.configure`](#lr.ParserConfig.props) to compute\n    /// prop values for each node type in the set. Takes a [match\n    /// object](#common.NodeType^match) or function that returns undefined\n    /// if the node type doesn't get this prop, and the prop's value if\n    /// it does.\n    add(match) {\n        if (this.perNode)\n            throw new RangeError(\"Can't add per-node props to node types\");\n        if (typeof match != \"function\")\n            match = NodeType.match(match);\n        return (type) => {\n            let result = match(type);\n            return result === undefined ? null : [this, result];\n        };\n    }\n}\n/// Prop that is used to describe matching delimiters. For opening\n/// delimiters, this holds an array of node names (written as a\n/// space-separated string when declaring this prop in a grammar)\n/// for the node types of closing delimiters that match it.\nNodeProp.closedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is\n/// attached to closing delimiters, holding an array of node names\n/// of types of matching opening delimiters.\nNodeProp.openedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// Used to assign node types to groups (for example, all node\n/// types that represent an expression could be tagged with an\n/// `\"Expression\"` group).\nNodeProp.group = new NodeProp({ deserialize: str => str.split(\" \") });\n/// The hash of the [context](#lr.ContextTracker.constructor)\n/// that the node was parsed in, if any. Used to limit reuse of\n/// contextual nodes.\nNodeProp.contextHash = new NodeProp({ perNode: true });\n/// The distance beyond the end of the node that the tokenizer\n/// looked ahead for any of the tokens inside the node. (The LR\n/// parser only stores this when it is larger than 25, for\n/// efficiency reasons.)\nNodeProp.lookAhead = new NodeProp({ perNode: true });\n/// This per-node prop is used to replace a given node, or part of a\n/// node, with another tree. This is useful to include trees from\n/// different languages in mixed-language parsers.\nNodeProp.mounted = new NodeProp({ perNode: true });\n/// A mounted tree, which can be [stored](#common.NodeProp^mounted) on\n/// a tree node to indicate that parts of its content are\n/// represented by another tree.\nclass MountedTree {\n    constructor(\n    /// The inner tree.\n    tree, \n    /// If this is null, this tree replaces the entire node (it will\n    /// be included in the regular iteration instead of its host\n    /// node). If not, only the given ranges are considered to be\n    /// covered by this tree. This is used for trees that are mixed in\n    /// a way that isn't strictly hierarchical. Such mounted trees are\n    /// only entered by [`resolveInner`](#common.Tree.resolveInner)\n    /// and [`enter`](#common.SyntaxNode.enter).\n    overlay, \n    /// The parser used to create this subtree.\n    parser) {\n        this.tree = tree;\n        this.overlay = overlay;\n        this.parser = parser;\n    }\n}\nconst noProps = Object.create(null);\n/// Each node in a syntax tree has a node type associated with it.\nclass NodeType {\n    /// @internal\n    constructor(\n    /// The name of the node type. Not necessarily unique, but if the\n    /// grammar was written properly, different node types with the\n    /// same name within a node set should play the same semantic\n    /// role.\n    name, \n    /// @internal\n    props, \n    /// The id of this node in its set. Corresponds to the term ids\n    /// used in the parser.\n    id, \n    /// @internal\n    flags = 0) {\n        this.name = name;\n        this.props = props;\n        this.id = id;\n        this.flags = flags;\n    }\n    /// Define a node type.\n    static define(spec) {\n        let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n        let flags = (spec.top ? 1 /* NodeFlag.Top */ : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */ : 0) |\n            (spec.error ? 4 /* NodeFlag.Error */ : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */ : 0);\n        let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n        if (spec.props)\n            for (let src of spec.props) {\n                if (!Array.isArray(src))\n                    src = src(type);\n                if (src) {\n                    if (src[0].perNode)\n                        throw new RangeError(\"Can't store a per-node prop on a node type\");\n                    props[src[0].id] = src[1];\n                }\n            }\n        return type;\n    }\n    /// Retrieves a node prop for this type. Will return `undefined` if\n    /// the prop isn't present on this node.\n    prop(prop) { return this.props[prop.id]; }\n    /// True when this is the top node of a grammar.\n    get isTop() { return (this.flags & 1 /* NodeFlag.Top */) > 0; }\n    /// True when this node is produced by a skip rule.\n    get isSkipped() { return (this.flags & 2 /* NodeFlag.Skipped */) > 0; }\n    /// Indicates whether this is an error node.\n    get isError() { return (this.flags & 4 /* NodeFlag.Error */) > 0; }\n    /// When true, this node type doesn't correspond to a user-declared\n    /// named node, for example because it is used to cache repetition.\n    get isAnonymous() { return (this.flags & 8 /* NodeFlag.Anonymous */) > 0; }\n    /// Returns true when this node's name or one of its\n    /// [groups](#common.NodeProp^group) matches the given string.\n    is(name) {\n        if (typeof name == 'string') {\n            if (this.name == name)\n                return true;\n            let group = this.prop(NodeProp.group);\n            return group ? group.indexOf(name) > -1 : false;\n        }\n        return this.id == name;\n    }\n    /// Create a function from node types to arbitrary values by\n    /// specifying an object whose property names are node or\n    /// [group](#common.NodeProp^group) names. Often useful with\n    /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n    /// names, separated by spaces, in a single property name to map\n    /// multiple node names to a single value.\n    static match(map) {\n        let direct = Object.create(null);\n        for (let prop in map)\n            for (let name of prop.split(\" \"))\n                direct[name] = map[prop];\n        return (node) => {\n            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n                let found = direct[i < 0 ? node.name : groups[i]];\n                if (found)\n                    return found;\n            }\n        };\n    }\n}\n/// An empty dummy node type to use when no actual type is available.\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* NodeFlag.Anonymous */);\n/// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a numeric array. Each parser\n/// [has](#lr.LRParser.nodeSet) a node set, and [tree\n/// buffers](#common.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536) node\n/// types in it, so that the ids fit into 16-bit typed array slots.\nclass NodeSet {\n    /// Create a set with the given types. The `id` property of each\n    /// type should correspond to its position within the array.\n    constructor(\n    /// The node types in this set, by id.\n    types) {\n        this.types = types;\n        for (let i = 0; i < types.length; i++)\n            if (types[i].id != i)\n                throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n    /// Create a copy of this set with some node properties added. The\n    /// arguments to this method can be created with\n    /// [`NodeProp.add`](#common.NodeProp.add).\n    extend(...props) {\n        let newTypes = [];\n        for (let type of this.types) {\n            let newProps = null;\n            for (let source of props) {\n                let add = source(type);\n                if (add) {\n                    if (!newProps)\n                        newProps = Object.assign({}, type.props);\n                    newProps[add[0].id] = add[1];\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n        return new NodeSet(newTypes);\n    }\n}\nconst CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();\n/// Options that control iteration. Can be combined with the `|`\n/// operator to enable multiple ones.\nvar IterMode;\n(function (IterMode) {\n    /// When enabled, iteration will only visit [`Tree`](#common.Tree)\n    /// objects, not nodes packed into\n    /// [`TreeBuffer`](#common.TreeBuffer)s.\n    IterMode[IterMode[\"ExcludeBuffers\"] = 1] = \"ExcludeBuffers\";\n    /// Enable this to make iteration include anonymous nodes (such as\n    /// the nodes that wrap repeated grammar constructs into a balanced\n    /// tree).\n    IterMode[IterMode[\"IncludeAnonymous\"] = 2] = \"IncludeAnonymous\";\n    /// By default, regular [mounted](#common.NodeProp^mounted) nodes\n    /// replace their base node in iteration. Enable this to ignore them\n    /// instead.\n    IterMode[IterMode[\"IgnoreMounts\"] = 4] = \"IgnoreMounts\";\n    /// This option only applies in\n    /// [`enter`](#common.SyntaxNode.enter)-style methods. It tells the\n    /// library to not enter mounted overlays if one covers the given\n    /// position.\n    IterMode[IterMode[\"IgnoreOverlays\"] = 8] = \"IgnoreOverlays\";\n})(IterMode || (IterMode = {}));\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the [`TreeCursor`](#common.TreeCursor) or\n/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\n/// a view on some part of this data structure, and can be used to\n/// move around to adjacent nodes.\nclass Tree {\n    /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n    constructor(\n    /// The type of the top node.\n    type, \n    /// This node's child nodes.\n    children, \n    /// The positions (offsets relative to the start of this tree) of\n    /// the children.\n    positions, \n    /// The total length of this tree\n    length, \n    /// Per-node [node props](#common.NodeProp) to associate with this node.\n    props) {\n        this.type = type;\n        this.children = children;\n        this.positions = positions;\n        this.length = length;\n        /// @internal\n        this.props = null;\n        if (props && props.length) {\n            this.props = Object.create(null);\n            for (let [prop, value] of props)\n                this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n        }\n    }\n    /// @internal\n    toString() {\n        let mounted = this.prop(NodeProp.mounted);\n        if (mounted && !mounted.overlay)\n            return mounted.tree.toString();\n        let children = \"\";\n        for (let ch of this.children) {\n            let str = ch.toString();\n            if (str) {\n                if (children)\n                    children += \",\";\n                children += str;\n            }\n        }\n        return !this.type.name ? children :\n            (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\n                (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    /// Get a [tree cursor](#common.TreeCursor) positioned at the top of\n    /// the tree. Mode can be used to [control](#common.IterMode) which\n    /// nodes the cursor visits.\n    cursor(mode = 0) {\n        return new TreeCursor(this.topNode, mode);\n    }\n    /// Get a [tree cursor](#common.TreeCursor) pointing into this tree\n    /// at the given position and side (see\n    /// [`moveTo`](#common.TreeCursor.moveTo).\n    cursorAt(pos, side = 0, mode = 0) {\n        let scope = CachedNode.get(this) || this.topNode;\n        let cursor = new TreeCursor(scope);\n        cursor.moveTo(pos, side);\n        CachedNode.set(this, cursor._tree);\n        return cursor;\n    }\n    /// Get a [syntax node](#common.SyntaxNode) object for the top of the\n    /// tree.\n    get topNode() {\n        return new TreeNode(this, 0, 0, null);\n    }\n    /// Get the [syntax node](#common.SyntaxNode) at the given position.\n    /// If `side` is -1, this will move into nodes that end at the\n    /// position. If 1, it'll move into nodes that start at the\n    /// position. With 0, it'll only enter nodes that cover the position\n    /// from both sides.\n    ///\n    /// Note that this will not enter\n    /// [overlays](#common.MountedTree.overlay), and you often want\n    /// [`resolveInner`](#common.Tree.resolveInner) instead.\n    resolve(pos, side = 0) {\n        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\n        CachedNode.set(this, node);\n        return node;\n    }\n    /// Like [`resolve`](#common.Tree.resolve), but will enter\n    /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n    /// pointing into the innermost overlaid tree at the given position\n    /// (with parent links going through all parent structure, including\n    /// the host trees).\n    resolveInner(pos, side = 0) {\n        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\n        CachedInnerNode.set(this, node);\n        return node;\n    }\n    /// Iterate over the tree and its children, calling `enter` for any\n    /// node that touches the `from`/`to` region (if given) before\n    /// running over such a node's children, and `leave` (if given) when\n    /// leaving the node. When `enter` returns `false`, that node will\n    /// not have its children iterated over (or `leave` called).\n    iterate(spec) {\n        let { enter, leave, from = 0, to = this.length } = spec;\n        let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;\n        for (let c = this.cursor(mode | IterMode.IncludeAnonymous);;) {\n            let entered = false;\n            if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {\n                if (c.firstChild())\n                    continue;\n                entered = true;\n            }\n            for (;;) {\n                if (entered && leave && (anon || !c.type.isAnonymous))\n                    leave(c);\n                if (c.nextSibling())\n                    break;\n                if (!c.parent())\n                    return;\n                entered = true;\n            }\n        }\n    }\n    /// Get the value of the given [node prop](#common.NodeProp) for this\n    /// node. Works with both per-node and per-type props.\n    prop(prop) {\n        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n    }\n    /// Returns the node's [per-node props](#common.NodeProp.perNode) in a\n    /// format that can be passed to the [`Tree`](#common.Tree)\n    /// constructor.\n    get propValues() {\n        let result = [];\n        if (this.props)\n            for (let id in this.props)\n                result.push([+id, this.props[id]]);\n        return result;\n    }\n    /// Balance the direct children of this tree, producing a copy of\n    /// which may have children grouped into subtrees with type\n    /// [`NodeType.none`](#common.NodeType^none).\n    balance(config = {}) {\n        return this.children.length <= 8 /* Balance.BranchFactor */ ? this :\n            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));\n    }\n    /// Build a tree from a postfix-ordered buffer of node information,\n    /// or a cursor over such a buffer.\n    static build(data) { return buildTree(data); }\n}\n/// The empty tree\nTree.empty = new Tree(NodeType.none, [], [], 0);\nclass FlatBufferCursor {\n    constructor(buffer, index) {\n        this.buffer = buffer;\n        this.index = index;\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    get pos() { return this.index; }\n    next() { this.index -= 4; }\n    fork() { return new FlatBufferCursor(this.buffer, this.index); }\n}\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it).\nclass TreeBuffer {\n    /// Create a tree buffer.\n    constructor(\n    /// The buffer's content.\n    buffer, \n    /// The total length of the group of nodes in the buffer.\n    length, \n    /// The node set used in this buffer.\n    set) {\n        this.buffer = buffer;\n        this.length = length;\n        this.set = set;\n    }\n    /// @internal\n    get type() { return NodeType.none; }\n    /// @internal\n    toString() {\n        let result = [];\n        for (let index = 0; index < this.buffer.length;) {\n            result.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result.join(\",\");\n    }\n    /// @internal\n    childString(index) {\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\n        let type = this.set.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.isError)\n            result = JSON.stringify(result);\n        index += 4;\n        if (endIndex == index)\n            return result;\n        let children = [];\n        while (index < endIndex) {\n            children.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result + \"(\" + children.join(\",\") + \")\";\n    }\n    /// @internal\n    findChild(startIndex, endIndex, dir, pos, side) {\n        let { buffer } = this, pick = -1;\n        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n                pick = i;\n                if (dir > 0)\n                    break;\n            }\n        }\n        return pick;\n    }\n    /// @internal\n    slice(startI, endI, from) {\n        let b = this.buffer;\n        let copy = new Uint16Array(endI - startI), len = 0;\n        for (let i = startI, j = 0; i < endI;) {\n            copy[j++] = b[i++];\n            copy[j++] = b[i++] - from;\n            let to = copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - startI;\n            len = Math.max(len, to);\n        }\n        return new TreeBuffer(copy, len, this.set);\n    }\n}\nfunction checkSide(side, pos, from, to) {\n    switch (side) {\n        case -2 /* Side.Before */: return from < pos;\n        case -1 /* Side.AtOrBefore */: return to >= pos && from < pos;\n        case 0 /* Side.Around */: return from < pos && to > pos;\n        case 1 /* Side.AtOrAfter */: return from <= pos && to > pos;\n        case 2 /* Side.After */: return to > pos;\n        case 4 /* Side.DontCare */: return true;\n    }\n}\nfunction enterUnfinishedNodesBefore(node, pos) {\n    let scan = node.childBefore(pos);\n    while (scan) {\n        let last = scan.lastChild;\n        if (!last || last.to != scan.to)\n            break;\n        if (last.type.isError && last.from == last.to) {\n            node = scan;\n            scan = last.prevSibling;\n        }\n        else {\n            scan = last;\n        }\n    }\n    return node;\n}\nfunction resolveNode(node, pos, side, overlays) {\n    var _a;\n    // Move up to a node that actually holds the position, if possible\n    while (node.from == node.to ||\n        (side < 1 ? node.from >= pos : node.from > pos) ||\n        (side > -1 ? node.to <= pos : node.to < pos)) {\n        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\n        if (!parent)\n            return node;\n        node = parent;\n    }\n    let mode = overlays ? 0 : IterMode.IgnoreOverlays;\n    // Must go up out of overlays when those do not overlap with pos\n    if (overlays)\n        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {\n            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)\n                node = parent;\n        }\n    for (;;) {\n        let inner = node.enter(pos, side, mode);\n        if (!inner)\n            return node;\n        node = inner;\n    }\n}\nclass TreeNode {\n    constructor(_tree, from, \n    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n    index, _parent) {\n        this._tree = _tree;\n        this.from = from;\n        this.index = index;\n        this._parent = _parent;\n    }\n    get type() { return this._tree.type; }\n    get name() { return this._tree.type.name; }\n    get to() { return this.from + this._tree.length; }\n    nextChild(i, dir, pos, side, mode = 0) {\n        for (let parent = this;;) {\n            for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n                let next = children[i], start = positions[i] + parent.from;\n                if (!checkSide(side, pos, start, start + next.length))\n                    continue;\n                if (next instanceof TreeBuffer) {\n                    if (mode & IterMode.ExcludeBuffers)\n                        continue;\n                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n                    if (index > -1)\n                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n                }\n                else if ((mode & IterMode.IncludeAnonymous) || (!next.type.isAnonymous || hasChild(next))) {\n                    let mounted;\n                    if (!(mode & IterMode.IgnoreMounts) &&\n                        next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)\n                        return new TreeNode(mounted.tree, start, i, parent);\n                    let inner = new TreeNode(next, start, i, parent);\n                    return (mode & IterMode.IncludeAnonymous) || !inner.type.isAnonymous ? inner\n                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n                }\n            }\n            if ((mode & IterMode.IncludeAnonymous) || !parent.type.isAnonymous)\n                return null;\n            if (parent.index >= 0)\n                i = parent.index + dir;\n            else\n                i = dir < 0 ? -1 : parent._parent._tree.children.length;\n            parent = parent._parent;\n            if (!parent)\n                return null;\n        }\n    }\n    get firstChild() { return this.nextChild(0, 1, 0, 4 /* Side.DontCare */); }\n    get lastChild() { return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */); }\n    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* Side.After */); }\n    childBefore(pos) { return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */); }\n    enter(pos, side, mode = 0) {\n        let mounted;\n        if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {\n            let rPos = pos - this.from;\n            for (let { from, to } of mounted.overlay) {\n                if ((side > 0 ? from <= rPos : from < rPos) &&\n                    (side < 0 ? to >= rPos : to > rPos))\n                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n            }\n        }\n        return this.nextChild(0, 1, pos, side, mode);\n    }\n    nextSignificantParent() {\n        let val = this;\n        while (val.type.isAnonymous && val._parent)\n            val = val._parent;\n        return val;\n    }\n    get parent() {\n        return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n    get nextSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */) : null;\n    }\n    get prevSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */) : null;\n    }\n    cursor(mode = 0) { return new TreeCursor(this, mode); }\n    get tree() { return this._tree; }\n    toTree() { return this._tree; }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    /// @internal\n    toString() { return this._tree.toString(); }\n    get node() { return this; }\n    matchContext(context) { return matchNodeContext(this, context); }\n}\nfunction getChildren(node, type, before, after) {\n    let cur = node.cursor(), result = [];\n    if (!cur.firstChild())\n        return result;\n    if (before != null)\n        while (!cur.type.is(before))\n            if (!cur.nextSibling())\n                return result;\n    for (;;) {\n        if (after != null && cur.type.is(after))\n            return result;\n        if (cur.type.is(type))\n            result.push(cur.node);\n        if (!cur.nextSibling())\n            return after == null ? result : [];\n    }\n}\nfunction matchNodeContext(node, context, i = context.length - 1) {\n    for (let p = node.parent; i >= 0; p = p.parent) {\n        if (!p)\n            return false;\n        if (!p.type.isAnonymous) {\n            if (context[i] && context[i] != p.name)\n                return false;\n            i--;\n        }\n    }\n    return true;\n}\nclass BufferContext {\n    constructor(parent, buffer, index, start) {\n        this.parent = parent;\n        this.buffer = buffer;\n        this.index = index;\n        this.start = start;\n    }\n}\nclass BufferNode {\n    get name() { return this.type.name; }\n    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }\n    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }\n    constructor(context, _parent, index) {\n        this.context = context;\n        this._parent = _parent;\n        this.index = index;\n        this.type = context.buffer.set.types[context.buffer.buffer[index]];\n    }\n    child(dir, pos, side) {\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get firstChild() { return this.child(1, 0, 4 /* Side.DontCare */); }\n    get lastChild() { return this.child(-1, 0, 4 /* Side.DontCare */); }\n    childAfter(pos) { return this.child(1, pos, 2 /* Side.After */); }\n    childBefore(pos) { return this.child(-1, pos, -2 /* Side.Before */); }\n    enter(pos, side, mode = 0) {\n        if (mode & IterMode.ExcludeBuffers)\n            return null;\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get parent() {\n        return this._parent || this.context.parent.nextSignificantParent();\n    }\n    externalSibling(dir) {\n        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */);\n    }\n    get nextSibling() {\n        let { buffer } = this.context;\n        let after = buffer.buffer[this.index + 3];\n        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\n            return new BufferNode(this.context, this._parent, after);\n        return this.externalSibling(1);\n    }\n    get prevSibling() {\n        let { buffer } = this.context;\n        let parentStart = this._parent ? this._parent.index + 4 : 0;\n        if (this.index == parentStart)\n            return this.externalSibling(-1);\n        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\n    }\n    cursor(mode = 0) { return new TreeCursor(this, mode); }\n    get tree() { return null; }\n    toTree() {\n        let children = [], positions = [];\n        let { buffer } = this.context;\n        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];\n        if (endI > startI) {\n            let from = buffer.buffer[this.index + 1];\n            children.push(buffer.slice(startI, endI, from));\n            positions.push(0);\n        }\n        return new Tree(this.type, children, positions, this.to - this.from);\n    }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }\n    /// @internal\n    toString() { return this.context.buffer.childString(this.index); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    get node() { return this; }\n    matchContext(context) { return matchNodeContext(this, context); }\n}\n/// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\nclass TreeCursor {\n    /// Shorthand for `.type.name`.\n    get name() { return this.type.name; }\n    /// @internal\n    constructor(node, \n    /// @internal\n    mode = 0) {\n        this.mode = mode;\n        /// @internal\n        this.buffer = null;\n        this.stack = [];\n        /// @internal\n        this.index = 0;\n        this.bufferNode = null;\n        if (node instanceof TreeNode) {\n            this.yieldNode(node);\n        }\n        else {\n            this._tree = node.context.parent;\n            this.buffer = node.context;\n            for (let n = node._parent; n; n = n._parent)\n                this.stack.unshift(n.index);\n            this.bufferNode = node;\n            this.yieldBuf(node.index);\n        }\n    }\n    yieldNode(node) {\n        if (!node)\n            return false;\n        this._tree = node;\n        this.type = node.type;\n        this.from = node.from;\n        this.to = node.to;\n        return true;\n    }\n    yieldBuf(index, type) {\n        this.index = index;\n        let { start, buffer } = this.buffer;\n        this.type = type || buffer.set.types[buffer.buffer[index]];\n        this.from = start + buffer.buffer[index + 1];\n        this.to = start + buffer.buffer[index + 2];\n        return true;\n    }\n    yield(node) {\n        if (!node)\n            return false;\n        if (node instanceof TreeNode) {\n            this.buffer = null;\n            return this.yieldNode(node);\n        }\n        this.buffer = node.context;\n        return this.yieldBuf(node.index, node.type);\n    }\n    /// @internal\n    toString() {\n        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    }\n    /// @internal\n    enterChild(dir, pos, side) {\n        if (!this.buffer)\n            return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));\n        let { buffer } = this.buffer;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n        if (index < 0)\n            return false;\n        this.stack.push(this.index);\n        return this.yieldBuf(index);\n    }\n    /// Move the cursor to this node's first child. When this returns\n    /// false, the node has no child, and the cursor has not been moved.\n    firstChild() { return this.enterChild(1, 0, 4 /* Side.DontCare */); }\n    /// Move the cursor to this node's last child.\n    lastChild() { return this.enterChild(-1, 0, 4 /* Side.DontCare */); }\n    /// Move the cursor to the first child that ends after `pos`.\n    childAfter(pos) { return this.enterChild(1, pos, 2 /* Side.After */); }\n    /// Move to the last child that starts before `pos`.\n    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Side.Before */); }\n    /// Move the cursor to the child around `pos`. If side is -1 the\n    /// child may end at that position, when 1 it may start there. This\n    /// will also enter [overlaid](#common.MountedTree.overlay)\n    /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n    /// set to false.\n    enter(pos, side, mode = this.mode) {\n        if (!this.buffer)\n            return this.yield(this._tree.enter(pos, side, mode));\n        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);\n    }\n    /// Move to the node's parent node, if this isn't the top node.\n    parent() {\n        if (!this.buffer)\n            return this.yieldNode((this.mode & IterMode.IncludeAnonymous) ? this._tree._parent : this._tree.parent);\n        if (this.stack.length)\n            return this.yieldBuf(this.stack.pop());\n        let parent = (this.mode & IterMode.IncludeAnonymous) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n        this.buffer = null;\n        return this.yieldNode(parent);\n    }\n    /// @internal\n    sibling(dir) {\n        if (!this.buffer)\n            return !this._tree._parent ? false\n                : this.yield(this._tree.index < 0 ? null\n                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode));\n        let { buffer } = this.buffer, d = this.stack.length - 1;\n        if (dir < 0) {\n            let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n            if (this.index != parentStart)\n                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\n        }\n        else {\n            let after = buffer.buffer[this.index + 3];\n            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\n                return this.yieldBuf(after);\n        }\n        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode)) : false;\n    }\n    /// Move to this node's next sibling, if any.\n    nextSibling() { return this.sibling(1); }\n    /// Move to this node's previous sibling, if any.\n    prevSibling() { return this.sibling(-1); }\n    atLastNode(dir) {\n        let index, parent, { buffer } = this;\n        if (buffer) {\n            if (dir > 0) {\n                if (this.index < buffer.buffer.buffer.length)\n                    return false;\n            }\n            else {\n                for (let i = 0; i < this.index; i++)\n                    if (buffer.buffer.buffer[i + 3] < this.index)\n                        return false;\n            }\n            ({ index, parent } = buffer);\n        }\n        else {\n            ({ index, _parent: parent } = this._tree);\n        }\n        for (; parent; { index, _parent: parent } = parent) {\n            if (index > -1)\n                for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {\n                    let child = parent._tree.children[i];\n                    if ((this.mode & IterMode.IncludeAnonymous) ||\n                        child instanceof TreeBuffer ||\n                        !child.type.isAnonymous ||\n                        hasChild(child))\n                        return false;\n                }\n        }\n        return true;\n    }\n    move(dir, enter) {\n        if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */))\n            return true;\n        for (;;) {\n            if (this.sibling(dir))\n                return true;\n            if (this.atLastNode(dir) || !this.parent())\n                return false;\n        }\n    }\n    /// Move to the next node in a\n    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)\n    /// traversal, going from a node to its first child or, if the\n    /// current node is empty or `enter` is false, its next sibling or\n    /// the next sibling of the first parent node that has one.\n    next(enter = true) { return this.move(1, enter); }\n    /// Move to the next node in a last-to-first pre-order traveral. A\n    /// node is followed by its last child or, if it has none, its\n    /// previous sibling or the previous sibling of the first parent\n    /// node that has one.\n    prev(enter = true) { return this.move(-1, enter); }\n    /// Move the cursor to the innermost node that covers `pos`. If\n    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    /// it will enter nodes that start at `pos`.\n    moveTo(pos, side = 0) {\n        // Move up to a node that actually holds the position, if possible\n        while (this.from == this.to ||\n            (side < 1 ? this.from >= pos : this.from > pos) ||\n            (side > -1 ? this.to <= pos : this.to < pos))\n            if (!this.parent())\n                break;\n        // Then scan down into child nodes as far as possible\n        while (this.enterChild(1, pos, side)) { }\n        return this;\n    }\n    /// Get a [syntax node](#common.SyntaxNode) at the cursor's current\n    /// position.\n    get node() {\n        if (!this.buffer)\n            return this._tree;\n        let cache = this.bufferNode, result = null, depth = 0;\n        if (cache && cache.context == this.buffer) {\n            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n                for (let c = cache; c; c = c._parent)\n                    if (c.index == index) {\n                        if (index == this.index)\n                            return c;\n                        result = c;\n                        depth = d + 1;\n                        break scan;\n                    }\n                index = this.stack[--d];\n            }\n        }\n        for (let i = depth; i < this.stack.length; i++)\n            result = new BufferNode(this.buffer, result, this.stack[i]);\n        return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    }\n    /// Get the [tree](#common.Tree) that represents the current node, if\n    /// any. Will return null when the node is in a [tree\n    /// buffer](#common.TreeBuffer).\n    get tree() {\n        return this.buffer ? null : this._tree._tree;\n    }\n    /// Iterate over the current node and all its descendants, calling\n    /// `enter` when entering a node and `leave`, if given, when leaving\n    /// one. When `enter` returns `false`, any children of that node are\n    /// skipped, and `leave` isn't called for it.\n    iterate(enter, leave) {\n        for (let depth = 0;;) {\n            let mustLeave = false;\n            if (this.type.isAnonymous || enter(this) !== false) {\n                if (this.firstChild()) {\n                    depth++;\n                    continue;\n                }\n                if (!this.type.isAnonymous)\n                    mustLeave = true;\n            }\n            for (;;) {\n                if (mustLeave && leave)\n                    leave(this);\n                mustLeave = this.type.isAnonymous;\n                if (this.nextSibling())\n                    break;\n                if (!depth)\n                    return;\n                this.parent();\n                depth--;\n                mustLeave = true;\n            }\n        }\n    }\n    /// Test whether the current node matches a given contextâ€”a sequence\n    /// of direct parent node names. Empty strings in the context array\n    /// are treated as wildcards.\n    matchContext(context) {\n        if (!this.buffer)\n            return matchNodeContext(this.node, context);\n        let { buffer } = this.buffer, { types } = buffer.set;\n        for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {\n            if (d < 0)\n                return matchNodeContext(this.node, context, i);\n            let type = types[buffer.buffer[this.stack[d]]];\n            if (!type.isAnonymous) {\n                if (context[i] && context[i] != type.name)\n                    return false;\n                i--;\n            }\n        }\n        return true;\n    }\n}\nfunction hasChild(tree) {\n    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\nfunction buildTree(data) {\n    var _a;\n    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    let types = nodeSet.types;\n    let contextHash = 0, lookAhead = 0;\n    function takeNode(parentStart, minPos, children, positions, inRepeat) {\n        let { id, start, end, size } = cursor;\n        let lookAheadAtStart = lookAhead;\n        while (size < 0) {\n            cursor.next();\n            if (size == -1 /* SpecialRecord.Reuse */) {\n                let node = reused[id];\n                children.push(node);\n                positions.push(start - parentStart);\n                return;\n            }\n            else if (size == -3 /* SpecialRecord.ContextChange */) { // Context change\n                contextHash = id;\n                return;\n            }\n            else if (size == -4 /* SpecialRecord.LookAhead */) {\n                lookAhead = id;\n                return;\n            }\n            else {\n                throw new RangeError(`Unrecognized record size: ${size}`);\n            }\n        }\n        let type = types[id], node, buffer;\n        let startPos = start - parentStart;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n            // Small enough for a buffer, and no reused nodes inside\n            let data = new Uint16Array(buffer.size - buffer.skip);\n            let endPos = cursor.pos - buffer.size, index = data.length;\n            while (cursor.pos > endPos)\n                index = copyToBuffer(buffer.start, data, index);\n            node = new TreeBuffer(data, end - buffer.start, nodeSet);\n            startPos = buffer.start - parentStart;\n        }\n        else { // Make it a node\n            let endPos = cursor.pos - size;\n            cursor.next();\n            let localChildren = [], localPositions = [];\n            let localInRepeat = id >= minRepeatType ? id : -1;\n            let lastGroup = 0, lastEnd = end;\n            while (cursor.pos > endPos) {\n                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n                    if (cursor.end <= lastEnd - maxBufferLength) {\n                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);\n                        lastGroup = localChildren.length;\n                        lastEnd = cursor.end;\n                    }\n                    cursor.next();\n                }\n                else {\n                    takeNode(start, endPos, localChildren, localPositions, localInRepeat);\n                }\n            }\n            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)\n                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);\n            localChildren.reverse();\n            localPositions.reverse();\n            if (localInRepeat > -1 && lastGroup > 0) {\n                let make = makeBalanced(type);\n                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n            }\n            else {\n                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);\n            }\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function makeBalanced(type) {\n        return (children, positions, length) => {\n            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;\n            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n                if (!lastI && last.type == type && last.length == length)\n                    return last;\n                if (lookAheadProp = last.prop(NodeProp.lookAhead))\n                    lookAhead = positions[lastI] + last.length + lookAheadProp;\n            }\n            return makeTree(type, children, positions, length, lookAhead);\n        };\n    }\n    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {\n        let localChildren = [], localPositions = [];\n        while (children.length > i) {\n            localChildren.push(children.pop());\n            localPositions.push(positions.pop() + base - from);\n        }\n        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));\n        positions.push(from - base);\n    }\n    function makeTree(type, children, positions, length, lookAhead = 0, props) {\n        if (contextHash) {\n            let pair = [NodeProp.contextHash, contextHash];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        if (lookAhead > 25) {\n            let pair = [NodeProp.lookAhead, lookAhead];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        return new Tree(type, children, positions, length, props);\n    }\n    function findBufferSize(maxSize, inRepeat) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer).\n        // If `inRepeat` is > -1, ignore node boundaries of that type for\n        // nesting, but make sure the end falls either at the start\n        // (`maxSize`) or before such a node.\n        let fork = cursor.fork();\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        let result = { size: 0, start: 0, skip: 0 };\n        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n            let nodeSize = fork.size;\n            // Pretend nested repeat nodes of the same type don't exist\n            if (fork.id == inRepeat && nodeSize >= 0) {\n                // Except that we store the current state as a valid return\n                // value.\n                result.size = size;\n                result.start = start;\n                result.skip = skip;\n                skip += 4;\n                size += 4;\n                fork.next();\n                continue;\n            }\n            let startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)\n                break;\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            let nodeStart = fork.start;\n            fork.next();\n            while (fork.pos > startPos) {\n                if (fork.size < 0) {\n                    if (fork.size == -3 /* SpecialRecord.ContextChange */)\n                        localSkipped += 4;\n                    else\n                        break scan;\n                }\n                else if (fork.id >= minRepeatType) {\n                    localSkipped += 4;\n                }\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        if (inRepeat < 0 || size == maxSize) {\n            result.size = size;\n            result.start = start;\n            result.skip = skip;\n        }\n        return result.size > 4 ? result : undefined;\n    }\n    function copyToBuffer(bufferStart, buffer, index) {\n        let { id, start, end, size } = cursor;\n        cursor.next();\n        if (size >= 0 && id < minRepeatType) {\n            let startIndex = index;\n            if (size > 4) {\n                let endPos = cursor.pos - (size - 4);\n                while (cursor.pos > endPos)\n                    index = copyToBuffer(bufferStart, buffer, index);\n            }\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        }\n        else if (size == -3 /* SpecialRecord.ContextChange */) {\n            contextHash = id;\n        }\n        else if (size == -4 /* SpecialRecord.LookAhead */) {\n            lookAhead = id;\n        }\n        return index;\n    }\n    let children = [], positions = [];\n    while (cursor.pos > 0)\n        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);\n    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);\n    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nconst nodeSizeCache = new WeakMap;\nfunction nodeSize(balanceType, node) {\n    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)\n        return 1;\n    let size = nodeSizeCache.get(node);\n    if (size == null) {\n        size = 1;\n        for (let child of node.children) {\n            if (child.type != balanceType || !(child instanceof Tree)) {\n                size = 1;\n                break;\n            }\n            size += nodeSize(balanceType, child);\n        }\n        nodeSizeCache.set(node, size);\n    }\n    return size;\n}\nfunction balanceRange(\n// The type the balanced tree's inner nodes.\nbalanceType, \n// The direct children and their positions\nchildren, positions, \n// The index range in children/positions to use\nfrom, to, \n// The start position of the nodes, relative to their parent.\nstart, \n// Length of the outer node\nlength, \n// Function to build the top node of the balanced tree\nmkTop, \n// Function to build internal nodes for the balanced tree\nmkTree) {\n    let total = 0;\n    for (let i = from; i < to; i++)\n        total += nodeSize(balanceType, children[i]);\n    let maxChild = Math.ceil((total * 1.5) / 8 /* Balance.BranchFactor */);\n    let localChildren = [], localPositions = [];\n    function divide(children, positions, from, to, offset) {\n        for (let i = from; i < to;) {\n            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);\n            i++;\n            for (; i < to; i++) {\n                let nextSize = nodeSize(balanceType, children[i]);\n                if (groupSize + nextSize >= maxChild)\n                    break;\n                groupSize += nextSize;\n            }\n            if (i == groupFrom + 1) {\n                if (groupSize > maxChild) {\n                    let only = children[groupFrom]; // Only trees can have a size > 1\n                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n                    continue;\n                }\n                localChildren.push(children[groupFrom]);\n            }\n            else {\n                let length = positions[i - 1] + children[i - 1].length - groupStart;\n                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n            }\n            localPositions.push(groupStart + offset - start);\n        }\n    }\n    divide(children, positions, from, to, 0);\n    return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n/// Provides a way to associate values with pieces of trees. As long\n/// as that part of the tree is reused, the associated values can be\n/// retrieved from an updated tree.\nclass NodeWeakMap {\n    constructor() {\n        this.map = new WeakMap();\n    }\n    setBuffer(buffer, index, value) {\n        let inner = this.map.get(buffer);\n        if (!inner)\n            this.map.set(buffer, inner = new Map);\n        inner.set(index, value);\n    }\n    getBuffer(buffer, index) {\n        let inner = this.map.get(buffer);\n        return inner && inner.get(index);\n    }\n    /// Set the value for this syntax node.\n    set(node, value) {\n        if (node instanceof BufferNode)\n            this.setBuffer(node.context.buffer, node.index, value);\n        else if (node instanceof TreeNode)\n            this.map.set(node.tree, value);\n    }\n    /// Retrieve value for this syntax node, if it exists in the map.\n    get(node) {\n        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index)\n            : node instanceof TreeNode ? this.map.get(node.tree) : undefined;\n    }\n    /// Set the value for the node that a cursor currently points to.\n    cursorSet(cursor, value) {\n        if (cursor.buffer)\n            this.setBuffer(cursor.buffer.buffer, cursor.index, value);\n        else\n            this.map.set(cursor.tree, value);\n    }\n    /// Retrieve the value for the node that a cursor currently points\n    /// to.\n    cursorGet(cursor) {\n        return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);\n    }\n}\n\n/// Tree fragments are used during [incremental\n/// parsing](#common.Parser.startParse) to track parts of old trees\n/// that can be reused in a new parse. An array of fragments is used\n/// to track regions of an old tree whose nodes might be reused in new\n/// parses. Use the static\n/// [`applyChanges`](#common.TreeFragment^applyChanges) method to\n/// update fragments for document changes.\nclass TreeFragment {\n    /// Construct a tree fragment. You'll usually want to use\n    /// [`addTree`](#common.TreeFragment^addTree) and\n    /// [`applyChanges`](#common.TreeFragment^applyChanges) instead of\n    /// calling this directly.\n    constructor(\n    /// The start of the unchanged range pointed to by this fragment.\n    /// This refers to an offset in the _updated_ document (as opposed\n    /// to the original tree).\n    from, \n    /// The end of the unchanged range.\n    to, \n    /// The tree that this fragment is based on.\n    tree, \n    /// The offset between the fragment's tree and the document that\n    /// this fragment can be used against. Add this when going from\n    /// document to tree positions, subtract it to go from tree to\n    /// document positions.\n    offset, openStart = false, openEnd = false) {\n        this.from = from;\n        this.to = to;\n        this.tree = tree;\n        this.offset = offset;\n        this.open = (openStart ? 1 /* Open.Start */ : 0) | (openEnd ? 2 /* Open.End */ : 0);\n    }\n    /// Whether the start of the fragment represents the start of a\n    /// parse, or the end of a change. (In the second case, it may not\n    /// be safe to reuse some nodes at the start, depending on the\n    /// parsing algorithm.)\n    get openStart() { return (this.open & 1 /* Open.Start */) > 0; }\n    /// Whether the end of the fragment represents the end of a\n    /// full-document parse, or the start of a change.\n    get openEnd() { return (this.open & 2 /* Open.End */) > 0; }\n    /// Create a set of fragments from a freshly parsed tree, or update\n    /// an existing set of fragments by replacing the ones that overlap\n    /// with a tree with content from the new tree. When `partial` is\n    /// true, the parse is treated as incomplete, and the resulting\n    /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n    /// true.\n    static addTree(tree, fragments = [], partial = false) {\n        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];\n        for (let f of fragments)\n            if (f.to > tree.length)\n                result.push(f);\n        return result;\n    }\n    /// Apply a set of edits to an array of fragments, removing or\n    /// splitting fragments as necessary to remove edited ranges, and\n    /// adjusting offsets for fragments that moved.\n    static applyChanges(fragments, changes, minGap = 128) {\n        if (!changes.length)\n            return fragments;\n        let result = [];\n        let fI = 1, nextF = fragments.length ? fragments[0] : null;\n        for (let cI = 0, pos = 0, off = 0;; cI++) {\n            let nextC = cI < changes.length ? changes[cI] : null;\n            let nextPos = nextC ? nextC.fromA : 1e9;\n            if (nextPos - pos >= minGap)\n                while (nextF && nextF.from < nextPos) {\n                    let cut = nextF;\n                    if (pos >= cut.from || nextPos <= cut.to || off) {\n                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\n                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n                    }\n                    if (cut)\n                        result.push(cut);\n                    if (nextF.to > nextPos)\n                        break;\n                    nextF = fI < fragments.length ? fragments[fI++] : null;\n                }\n            if (!nextC)\n                break;\n            pos = nextC.toA;\n            off = nextC.toA - nextC.toB;\n        }\n        return result;\n    }\n}\n/// A superclass that parsers should extend.\nclass Parser {\n    /// Start a parse, returning a [partial parse](#common.PartialParse)\n    /// object. [`fragments`](#common.TreeFragment) can be passed in to\n    /// make the parse incremental.\n    ///\n    /// By default, the entire input is parsed. You can pass `ranges`,\n    /// which should be a sorted array of non-empty, non-overlapping\n    /// ranges, to parse only those ranges. The tree returned in that\n    /// case will start at `ranges[0].from`.\n    startParse(input, fragments, ranges) {\n        if (typeof input == \"string\")\n            input = new StringInput(input);\n        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];\n        return this.createParse(input, fragments || [], ranges);\n    }\n    /// Run a full parse, returning the resulting tree.\n    parse(input, fragments, ranges) {\n        let parse = this.startParse(input, fragments, ranges);\n        for (;;) {\n            let done = parse.advance();\n            if (done)\n                return done;\n        }\n    }\n}\nclass StringInput {\n    constructor(string) {\n        this.string = string;\n    }\n    get length() { return this.string.length; }\n    chunk(from) { return this.string.slice(from); }\n    get lineChunks() { return false; }\n    read(from, to) { return this.string.slice(from, to); }\n}\n\n/// Create a parse wrapper that, after the inner parse completes,\n/// scans its tree for mixed language regions with the `nest`\n/// function, runs the resulting [inner parses](#common.NestedParse),\n/// and then [mounts](#common.NodeProp^mounted) their results onto the\n/// tree.\nfunction parseMixed(nest) {\n    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);\n}\nclass InnerParse {\n    constructor(parser, parse, overlay, target, ranges) {\n        this.parser = parser;\n        this.parse = parse;\n        this.overlay = overlay;\n        this.target = target;\n        this.ranges = ranges;\n        if (!ranges.length || ranges.some(r => r.from >= r.to))\n            throw new RangeError(\"Invalid inner parse ranges given: \" + JSON.stringify(ranges));\n    }\n}\nclass ActiveOverlay {\n    constructor(parser, predicate, mounts, index, start, target, prev) {\n        this.parser = parser;\n        this.predicate = predicate;\n        this.mounts = mounts;\n        this.index = index;\n        this.start = start;\n        this.target = target;\n        this.prev = prev;\n        this.depth = 0;\n        this.ranges = [];\n    }\n}\nconst stoppedInner = new NodeProp({ perNode: true });\nclass MixedParse {\n    constructor(base, nest, input, fragments, ranges) {\n        this.nest = nest;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.inner = [];\n        this.innerDone = 0;\n        this.baseTree = null;\n        this.stoppedAt = null;\n        this.baseParse = base;\n    }\n    advance() {\n        if (this.baseParse) {\n            let done = this.baseParse.advance();\n            if (!done)\n                return null;\n            this.baseParse = null;\n            this.baseTree = done;\n            this.startInner();\n            if (this.stoppedAt != null)\n                for (let inner of this.inner)\n                    inner.parse.stopAt(this.stoppedAt);\n        }\n        if (this.innerDone == this.inner.length) {\n            let result = this.baseTree;\n            if (this.stoppedAt != null)\n                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));\n            return result;\n        }\n        let inner = this.inner[this.innerDone], done = inner.parse.advance();\n        if (done) {\n            this.innerDone++;\n            // This is a somewhat dodgy but super helpful hack where we\n            // patch up nodes created by the inner parse (and thus\n            // presumably not aliased anywhere else) to hold the information\n            // about the inner parse.\n            let props = Object.assign(Object.create(null), inner.target.props);\n            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n            inner.target.props = props;\n        }\n        return null;\n    }\n    get parsedPos() {\n        if (this.baseParse)\n            return 0;\n        let pos = this.input.length;\n        for (let i = this.innerDone; i < this.inner.length; i++) {\n            if (this.inner[i].ranges[0].from < pos)\n                pos = Math.min(pos, this.inner[i].parse.parsedPos);\n        }\n        return pos;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n        if (this.baseParse)\n            this.baseParse.stopAt(pos);\n        else\n            for (let i = this.innerDone; i < this.inner.length; i++)\n                this.inner[i].parse.stopAt(pos);\n    }\n    startInner() {\n        let fragmentCursor = new FragmentCursor(this.fragments);\n        let overlay = null;\n        let covered = null;\n        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n        scan: for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt;) {\n            let enter = true, range;\n            if (fragmentCursor.hasNode(cursor)) {\n                if (overlay) {\n                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n                    if (match)\n                        for (let r of match.mount.overlay) {\n                            let from = r.from + match.pos, to = r.to + match.pos;\n                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))\n                                overlay.ranges.push({ from, to });\n                        }\n                }\n                enter = false;\n            }\n            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n                enter = isCovered != 2 /* Cover.Full */;\n            }\n            else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {\n                if (!cursor.tree)\n                    materialize(cursor);\n                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n                if (typeof nest.overlay == \"function\") {\n                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\n                }\n                else {\n                    let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);\n                    if (ranges.length)\n                        this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));\n                    if (!nest.overlay)\n                        enter = false;\n                    else if (ranges.length)\n                        covered = { ranges, depth: 0, prev: covered };\n                }\n            }\n            else if (overlay && (range = overlay.predicate(cursor))) {\n                if (range === true)\n                    range = new Range(cursor.from, cursor.to);\n                if (range.from < range.to)\n                    overlay.ranges.push(range);\n            }\n            if (enter && cursor.firstChild()) {\n                if (overlay)\n                    overlay.depth++;\n                if (covered)\n                    covered.depth++;\n            }\n            else {\n                for (;;) {\n                    if (cursor.nextSibling())\n                        break;\n                    if (!cursor.parent())\n                        break scan;\n                    if (overlay && !--overlay.depth) {\n                        let ranges = punchRanges(this.ranges, overlay.ranges);\n                        if (ranges.length)\n                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));\n                        overlay = overlay.prev;\n                    }\n                    if (covered && !--covered.depth)\n                        covered = covered.prev;\n                }\n            }\n        }\n    }\n}\nfunction checkCover(covered, from, to) {\n    for (let range of covered) {\n        if (range.from >= to)\n            break;\n        if (range.to > from)\n            return range.from <= from && range.to >= to ? 2 /* Cover.Full */ : 1 /* Cover.Partial */;\n    }\n    return 0 /* Cover.None */;\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n    if (startI < endI) {\n        let from = buf.buffer[startI + 1];\n        nodes.push(buf.slice(startI, endI, from));\n        positions.push(from - off);\n    }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n    let { node } = cursor, depth = 0;\n    // Scan up to the nearest tree\n    do {\n        cursor.parent();\n        depth++;\n    } while (!cursor.tree);\n    // Find the index of the buffer in that tree\n    let i = 0, base = cursor.tree, off = 0;\n    for (;; i++) {\n        off = base.positions[i] + cursor.from;\n        if (off <= node.from && off + base.children[i].length >= node.to)\n            break;\n    }\n    let buf = base.children[i], b = buf.buffer;\n    // Split a level in the buffer, putting the nodes before and after\n    // the child that contains `node` into new buffers.\n    function split(startI, endI, type, innerOffset, length) {\n        let i = startI;\n        while (b[i + 2] + off <= node.from)\n            i = b[i + 3];\n        let children = [], positions = [];\n        sliceBuf(buf, startI, i, children, positions, innerOffset);\n        let from = b[i + 1], to = b[i + 2];\n        let isTarget = from + off == node.from && to + off == node.to && b[i] == node.type.id;\n        children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], from, to - from));\n        positions.push(from - innerOffset);\n        sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);\n        return new Tree(type, children, positions, length);\n    }\n    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length);\n    // Move the cursor back to the target node\n    for (let d = 0; d <= depth; d++)\n        cursor.childAfter(node.from);\n}\nclass StructureCursor {\n    constructor(root, offset) {\n        this.offset = offset;\n        this.done = false;\n        this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n    }\n    // Move to the first node (in pre-order) that starts at or after `pos`.\n    moveTo(pos) {\n        let { cursor } = this, p = pos - this.offset;\n        while (!this.done && cursor.from < p) {\n            if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;\n            else if (!cursor.next(false))\n                this.done = true;\n        }\n    }\n    hasNode(cursor) {\n        this.moveTo(cursor.from);\n        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n            for (let tree = this.cursor.tree;;) {\n                if (tree == cursor.tree)\n                    return true;\n                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)\n                    tree = tree.children[0];\n                else\n                    break;\n            }\n        }\n        return false;\n    }\n}\nclass FragmentCursor {\n    constructor(fragments) {\n        var _a;\n        this.fragments = fragments;\n        this.curTo = 0;\n        this.fragI = 0;\n        if (fragments.length) {\n            let first = this.curFrag = fragments[0];\n            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\n            this.inner = new StructureCursor(first.tree, -first.offset);\n        }\n        else {\n            this.curFrag = this.inner = null;\n        }\n    }\n    hasNode(node) {\n        while (this.curFrag && node.from >= this.curTo)\n            this.nextFrag();\n        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\n    }\n    nextFrag() {\n        var _a;\n        this.fragI++;\n        if (this.fragI == this.fragments.length) {\n            this.curFrag = this.inner = null;\n        }\n        else {\n            let frag = this.curFrag = this.fragments[this.fragI];\n            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\n            this.inner = new StructureCursor(frag.tree, -frag.offset);\n        }\n    }\n    findMounts(pos, parser) {\n        var _a;\n        let result = [];\n        if (this.inner) {\n            this.inner.cursor.moveTo(pos, 1);\n            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {\n                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n                if (mount && mount.parser == parser) {\n                    for (let i = this.fragI; i < this.fragments.length; i++) {\n                        let frag = this.fragments[i];\n                        if (frag.from >= pos.to)\n                            break;\n                        if (frag.tree == this.curFrag.tree)\n                            result.push({\n                                frag,\n                                pos: pos.from - frag.offset,\n                                mount\n                            });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nfunction punchRanges(outer, ranges) {\n    let copy = null, current = ranges;\n    for (let i = 1, j = 0; i < outer.length; i++) {\n        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;\n        for (; j < current.length; j++) {\n            let r = current[j];\n            if (r.from >= gapTo)\n                break;\n            if (r.to <= gapFrom)\n                continue;\n            if (!copy)\n                current = copy = ranges.slice();\n            if (r.from < gapFrom) {\n                copy[j] = new Range(r.from, gapFrom);\n                if (r.to > gapTo)\n                    copy.splice(j + 1, 0, new Range(gapTo, r.to));\n            }\n            else if (r.to > gapTo) {\n                copy[j--] = new Range(gapTo, r.to);\n            }\n            else {\n                copy.splice(j--, 1);\n            }\n        }\n    }\n    return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;\n    let result = [];\n    for (;;) {\n        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n        if (inA != inB) {\n            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);\n            if (start < end)\n                result.push(new Range(start, end));\n        }\n        pos = Math.min(nextA, nextB);\n        if (pos == 1e9)\n            break;\n        if (nextA == pos) {\n            if (!inA)\n                inA = true;\n            else {\n                inA = false;\n                iA++;\n            }\n        }\n        if (nextB == pos) {\n            if (!inB)\n                inB = true;\n            else {\n                inB = false;\n                iB++;\n            }\n        }\n    }\n    return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n    let result = [];\n    for (let { pos, mount, frag } of mounts) {\n        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;\n        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);\n        if (mount.overlay) {\n            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));\n            let changes = findCoverChanges(ranges, overlay, from, to);\n            for (let i = 0, pos = from;; i++) {\n                let last = i == changes.length, end = last ? to : changes[i].from;\n                if (end > pos)\n                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));\n                if (last)\n                    break;\n                pos = changes[i].to;\n            }\n        }\n        else {\n            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));\n        }\n    }\n    return result;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2NvbW1vbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQztBQUN2RTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxvQ0FBb0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGVBQWU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZUFBZTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZUFBZTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsa0NBQWtDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQztBQUN6RDtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBLGdDQUFnQztBQUNoQyx1QkFBdUIsc0JBQXNCLG9EQUFvRCxRQUFRO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEdBQUc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0EsZUFBZSxVQUFVLHlCQUF5QjtBQUNsRDtBQUNBLDJGQUEyRixRQUFRO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLE9BQU87QUFDN0Usb0NBQW9DLEdBQUc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTLGlCQUFpQixRQUFRO0FBQ2hELG9FQUFvRSxRQUFRO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDRHQUE0RztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLEtBQUs7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixvREFBb0Qsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELEtBQUs7QUFDeEQ7QUFDQTtBQUNBLDZDQUE2QywyQkFBMkI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGxpdmVibG9ja3MtZXhhbXBsZXMvbmV4dGpzLXlqcy1jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL0BsZXplci9jb21tb24vZGlzdC9pbmRleC5qcz81ZjM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZJWE1FIHByb2ZpbGUgYWRkaW5nIGEgcGVyLVRyZWUgVHJlZU5vZGUgY2FjaGUsIHZhbGlkYXRpbmcgaXQgYnlcbi8vIHBhcmVudCBwb2ludGVyXG4vLy8gVGhlIGRlZmF1bHQgbWF4aW11bSBsZW5ndGggb2YgYSBgVHJlZUJ1ZmZlcmAgbm9kZS5cbmNvbnN0IERlZmF1bHRCdWZmZXJMZW5ndGggPSAxMDI0O1xubGV0IG5leHRQcm9wSUQgPSAwO1xuY2xhc3MgUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG59XG4vLy8gRWFjaCBbbm9kZSB0eXBlXSgjY29tbW9uLk5vZGVUeXBlKSBvciBbaW5kaXZpZHVhbCB0cmVlXSgjY29tbW9uLlRyZWUpXG4vLy8gY2FuIGhhdmUgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIGl0IGluIHByb3BzLiBJbnN0YW5jZXMgb2YgdGhpc1xuLy8vIGNsYXNzIHJlcHJlc2VudCBwcm9wIG5hbWVzLlxuY2xhc3MgTm9kZVByb3Age1xuICAgIC8vLyBDcmVhdGUgYSBuZXcgbm9kZSBwcm9wIHR5cGUuXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRQcm9wSUQrKztcbiAgICAgICAgdGhpcy5wZXJOb2RlID0gISFjb25maWcucGVyTm9kZTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGNvbmZpZy5kZXNlcmlhbGl6ZSB8fCAoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBub2RlIHR5cGUgZG9lc24ndCBkZWZpbmUgYSBkZXNlcmlhbGl6ZSBmdW5jdGlvblwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vLyBUaGlzIGlzIG1lYW50IHRvIGJlIHVzZWQgd2l0aFxuICAgIC8vLyBbYE5vZGVTZXQuZXh0ZW5kYF0oI2NvbW1vbi5Ob2RlU2V0LmV4dGVuZCkgb3JcbiAgICAvLy8gW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuUGFyc2VyQ29uZmlnLnByb3BzKSB0byBjb21wdXRlXG4gICAgLy8vIHByb3AgdmFsdWVzIGZvciBlYWNoIG5vZGUgdHlwZSBpbiB0aGUgc2V0LiBUYWtlcyBhIFttYXRjaFxuICAgIC8vLyBvYmplY3RdKCNjb21tb24uTm9kZVR5cGVebWF0Y2gpIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB1bmRlZmluZWRcbiAgICAvLy8gaWYgdGhlIG5vZGUgdHlwZSBkb2Vzbid0IGdldCB0aGlzIHByb3AsIGFuZCB0aGUgcHJvcCdzIHZhbHVlIGlmXG4gICAgLy8vIGl0IGRvZXMuXG4gICAgYWRkKG1hdGNoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlck5vZGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IGFkZCBwZXItbm9kZSBwcm9wcyB0byBub2RlIHR5cGVzXCIpO1xuICAgICAgICBpZiAodHlwZW9mIG1hdGNoICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIG1hdGNoID0gTm9kZVR5cGUubWF0Y2gobWF0Y2gpO1xuICAgICAgICByZXR1cm4gKHR5cGUpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBtYXRjaCh0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBbdGhpcywgcmVzdWx0XTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4vLy8gUHJvcCB0aGF0IGlzIHVzZWQgdG8gZGVzY3JpYmUgbWF0Y2hpbmcgZGVsaW1pdGVycy4gRm9yIG9wZW5pbmdcbi8vLyBkZWxpbWl0ZXJzLCB0aGlzIGhvbGRzIGFuIGFycmF5IG9mIG5vZGUgbmFtZXMgKHdyaXR0ZW4gYXMgYVxuLy8vIHNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgd2hlbiBkZWNsYXJpbmcgdGhpcyBwcm9wIGluIGEgZ3JhbW1hcilcbi8vLyBmb3IgdGhlIG5vZGUgdHlwZXMgb2YgY2xvc2luZyBkZWxpbWl0ZXJzIHRoYXQgbWF0Y2ggaXQuXG5Ob2RlUHJvcC5jbG9zZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBUaGUgaW52ZXJzZSBvZiBbYGNsb3NlZEJ5YF0oI2NvbW1vbi5Ob2RlUHJvcF5jbG9zZWRCeSkuIFRoaXMgaXNcbi8vLyBhdHRhY2hlZCB0byBjbG9zaW5nIGRlbGltaXRlcnMsIGhvbGRpbmcgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lc1xuLy8vIG9mIHR5cGVzIG9mIG1hdGNoaW5nIG9wZW5pbmcgZGVsaW1pdGVycy5cbk5vZGVQcm9wLm9wZW5lZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLy8vIFVzZWQgdG8gYXNzaWduIG5vZGUgdHlwZXMgdG8gZ3JvdXBzIChmb3IgZXhhbXBsZSwgYWxsIG5vZGVcbi8vLyB0eXBlcyB0aGF0IHJlcHJlc2VudCBhbiBleHByZXNzaW9uIGNvdWxkIGJlIHRhZ2dlZCB3aXRoIGFuXG4vLy8gYFwiRXhwcmVzc2lvblwiYCBncm91cCkuXG5Ob2RlUHJvcC5ncm91cCA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBUaGUgaGFzaCBvZiB0aGUgW2NvbnRleHRdKCNsci5Db250ZXh0VHJhY2tlci5jb25zdHJ1Y3Rvcilcbi8vLyB0aGF0IHRoZSBub2RlIHdhcyBwYXJzZWQgaW4sIGlmIGFueS4gVXNlZCB0byBsaW1pdCByZXVzZSBvZlxuLy8vIGNvbnRleHR1YWwgbm9kZXMuXG5Ob2RlUHJvcC5jb250ZXh0SGFzaCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vLy8gVGhlIGRpc3RhbmNlIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBub2RlIHRoYXQgdGhlIHRva2VuaXplclxuLy8vIGxvb2tlZCBhaGVhZCBmb3IgYW55IG9mIHRoZSB0b2tlbnMgaW5zaWRlIHRoZSBub2RlLiAoVGhlIExSXG4vLy8gcGFyc2VyIG9ubHkgc3RvcmVzIHRoaXMgd2hlbiBpdCBpcyBsYXJnZXIgdGhhbiAyNSwgZm9yXG4vLy8gZWZmaWNpZW5jeSByZWFzb25zLilcbk5vZGVQcm9wLmxvb2tBaGVhZCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vLy8gVGhpcyBwZXItbm9kZSBwcm9wIGlzIHVzZWQgdG8gcmVwbGFjZSBhIGdpdmVuIG5vZGUsIG9yIHBhcnQgb2YgYVxuLy8vIG5vZGUsIHdpdGggYW5vdGhlciB0cmVlLiBUaGlzIGlzIHVzZWZ1bCB0byBpbmNsdWRlIHRyZWVzIGZyb21cbi8vLyBkaWZmZXJlbnQgbGFuZ3VhZ2VzIGluIG1peGVkLWxhbmd1YWdlIHBhcnNlcnMuXG5Ob2RlUHJvcC5tb3VudGVkID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8vLyBBIG1vdW50ZWQgdHJlZSwgd2hpY2ggY2FuIGJlIFtzdG9yZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgb25cbi8vLyBhIHRyZWUgbm9kZSB0byBpbmRpY2F0ZSB0aGF0IHBhcnRzIG9mIGl0cyBjb250ZW50IGFyZVxuLy8vIHJlcHJlc2VudGVkIGJ5IGFub3RoZXIgdHJlZS5cbmNsYXNzIE1vdW50ZWRUcmVlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIGlubmVyIHRyZWUuXG4gICAgdHJlZSwgXG4gICAgLy8vIElmIHRoaXMgaXMgbnVsbCwgdGhpcyB0cmVlIHJlcGxhY2VzIHRoZSBlbnRpcmUgbm9kZSAoaXQgd2lsbFxuICAgIC8vLyBiZSBpbmNsdWRlZCBpbiB0aGUgcmVndWxhciBpdGVyYXRpb24gaW5zdGVhZCBvZiBpdHMgaG9zdFxuICAgIC8vLyBub2RlKS4gSWYgbm90LCBvbmx5IHRoZSBnaXZlbiByYW5nZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmVcbiAgICAvLy8gY292ZXJlZCBieSB0aGlzIHRyZWUuIFRoaXMgaXMgdXNlZCBmb3IgdHJlZXMgdGhhdCBhcmUgbWl4ZWQgaW5cbiAgICAvLy8gYSB3YXkgdGhhdCBpc24ndCBzdHJpY3RseSBoaWVyYXJjaGljYWwuIFN1Y2ggbW91bnRlZCB0cmVlcyBhcmVcbiAgICAvLy8gb25seSBlbnRlcmVkIGJ5IFtgcmVzb2x2ZUlubmVyYF0oI2NvbW1vbi5UcmVlLnJlc29sdmVJbm5lcilcbiAgICAvLy8gYW5kIFtgZW50ZXJgXSgjY29tbW9uLlN5bnRheE5vZGUuZW50ZXIpLlxuICAgIG92ZXJsYXksIFxuICAgIC8vLyBUaGUgcGFyc2VyIHVzZWQgdG8gY3JlYXRlIHRoaXMgc3VidHJlZS5cbiAgICBwYXJzZXIpIHtcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgfVxufVxuY29uc3Qgbm9Qcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vLy8gRWFjaCBub2RlIGluIGEgc3ludGF4IHRyZWUgaGFzIGEgbm9kZSB0eXBlIGFzc29jaWF0ZWQgd2l0aCBpdC5cbmNsYXNzIE5vZGVUeXBlIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBuYW1lIG9mIHRoZSBub2RlIHR5cGUuIE5vdCBuZWNlc3NhcmlseSB1bmlxdWUsIGJ1dCBpZiB0aGVcbiAgICAvLy8gZ3JhbW1hciB3YXMgd3JpdHRlbiBwcm9wZXJseSwgZGlmZmVyZW50IG5vZGUgdHlwZXMgd2l0aCB0aGVcbiAgICAvLy8gc2FtZSBuYW1lIHdpdGhpbiBhIG5vZGUgc2V0IHNob3VsZCBwbGF5IHRoZSBzYW1lIHNlbWFudGljXG4gICAgLy8vIHJvbGUuXG4gICAgbmFtZSwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHByb3BzLCBcbiAgICAvLy8gVGhlIGlkIG9mIHRoaXMgbm9kZSBpbiBpdHMgc2V0LiBDb3JyZXNwb25kcyB0byB0aGUgdGVybSBpZHNcbiAgICAvLy8gdXNlZCBpbiB0aGUgcGFyc2VyLlxuICAgIGlkLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgZmxhZ3MgPSAwKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgfVxuICAgIC8vLyBEZWZpbmUgYSBub2RlIHR5cGUuXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBwcm9wcyA9IHNwZWMucHJvcHMgJiYgc3BlYy5wcm9wcy5sZW5ndGggPyBPYmplY3QuY3JlYXRlKG51bGwpIDogbm9Qcm9wcztcbiAgICAgICAgbGV0IGZsYWdzID0gKHNwZWMudG9wID8gMSAvKiBOb2RlRmxhZy5Ub3AgKi8gOiAwKSB8IChzcGVjLnNraXBwZWQgPyAyIC8qIE5vZGVGbGFnLlNraXBwZWQgKi8gOiAwKSB8XG4gICAgICAgICAgICAoc3BlYy5lcnJvciA/IDQgLyogTm9kZUZsYWcuRXJyb3IgKi8gOiAwKSB8IChzcGVjLm5hbWUgPT0gbnVsbCA/IDggLyogTm9kZUZsYWcuQW5vbnltb3VzICovIDogMCk7XG4gICAgICAgIGxldCB0eXBlID0gbmV3IE5vZGVUeXBlKHNwZWMubmFtZSB8fCBcIlwiLCBwcm9wcywgc3BlYy5pZCwgZmxhZ3MpO1xuICAgICAgICBpZiAoc3BlYy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHNyYyBvZiBzcGVjLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNyYykpXG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYyh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcmNbMF0ucGVyTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3Qgc3RvcmUgYSBwZXItbm9kZSBwcm9wIG9uIGEgbm9kZSB0eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1tzcmNbMF0uaWRdID0gc3JjWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIC8vLyBSZXRyaWV2ZXMgYSBub2RlIHByb3AgZm9yIHRoaXMgdHlwZS4gV2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaWZcbiAgICAvLy8gdGhlIHByb3AgaXNuJ3QgcHJlc2VudCBvbiB0aGlzIG5vZGUuXG4gICAgcHJvcChwcm9wKSB7IHJldHVybiB0aGlzLnByb3BzW3Byb3AuaWRdOyB9XG4gICAgLy8vIFRydWUgd2hlbiB0aGlzIGlzIHRoZSB0b3Agbm9kZSBvZiBhIGdyYW1tYXIuXG4gICAgZ2V0IGlzVG9wKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIE5vZGVGbGFnLlRvcCAqLykgPiAwOyB9XG4gICAgLy8vIFRydWUgd2hlbiB0aGlzIG5vZGUgaXMgcHJvZHVjZWQgYnkgYSBza2lwIHJ1bGUuXG4gICAgZ2V0IGlzU2tpcHBlZCgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMiAvKiBOb2RlRmxhZy5Ta2lwcGVkICovKSA+IDA7IH1cbiAgICAvLy8gSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhbiBlcnJvciBub2RlLlxuICAgIGdldCBpc0Vycm9yKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0IC8qIE5vZGVGbGFnLkVycm9yICovKSA+IDA7IH1cbiAgICAvLy8gV2hlbiB0cnVlLCB0aGlzIG5vZGUgdHlwZSBkb2Vzbid0IGNvcnJlc3BvbmQgdG8gYSB1c2VyLWRlY2xhcmVkXG4gICAgLy8vIG5hbWVkIG5vZGUsIGZvciBleGFtcGxlIGJlY2F1c2UgaXQgaXMgdXNlZCB0byBjYWNoZSByZXBldGl0aW9uLlxuICAgIGdldCBpc0Fub255bW91cygpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgOCAvKiBOb2RlRmxhZy5Bbm9ueW1vdXMgKi8pID4gMDsgfVxuICAgIC8vLyBSZXR1cm5zIHRydWUgd2hlbiB0aGlzIG5vZGUncyBuYW1lIG9yIG9uZSBvZiBpdHNcbiAgICAvLy8gW2dyb3Vwc10oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbWF0Y2hlcyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgIGlzKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lID09IG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSB0aGlzLnByb3AoTm9kZVByb3AuZ3JvdXApO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwID8gZ3JvdXAuaW5kZXhPZihuYW1lKSA+IC0xIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgPT0gbmFtZTtcbiAgICB9XG4gICAgLy8vIENyZWF0ZSBhIGZ1bmN0aW9uIGZyb20gbm9kZSB0eXBlcyB0byBhcmJpdHJhcnkgdmFsdWVzIGJ5XG4gICAgLy8vIHNwZWNpZnlpbmcgYW4gb2JqZWN0IHdob3NlIHByb3BlcnR5IG5hbWVzIGFyZSBub2RlIG9yXG4gICAgLy8vIFtncm91cF0oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbmFtZXMuIE9mdGVuIHVzZWZ1bCB3aXRoXG4gICAgLy8vIFtgTm9kZVByb3AuYWRkYF0oI2NvbW1vbi5Ob2RlUHJvcC5hZGQpLiBZb3UgY2FuIHB1dCBtdWx0aXBsZVxuICAgIC8vLyBuYW1lcywgc2VwYXJhdGVkIGJ5IHNwYWNlcywgaW4gYSBzaW5nbGUgcHJvcGVydHkgbmFtZSB0byBtYXBcbiAgICAvLy8gbXVsdGlwbGUgbm9kZSBuYW1lcyB0byBhIHNpbmdsZSB2YWx1ZS5cbiAgICBzdGF0aWMgbWF0Y2gobWFwKSB7XG4gICAgICAgIGxldCBkaXJlY3QgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIG1hcClcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgb2YgcHJvcC5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICAgICAgZGlyZWN0W25hbWVdID0gbWFwW3Byb3BdO1xuICAgICAgICByZXR1cm4gKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGdyb3VwcyA9IG5vZGUucHJvcChOb2RlUHJvcC5ncm91cCksIGkgPSAtMTsgaSA8IChncm91cHMgPyBncm91cHMubGVuZ3RoIDogMCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGRpcmVjdFtpIDwgMCA/IG5vZGUubmFtZSA6IGdyb3Vwc1tpXV07XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuLy8vIEFuIGVtcHR5IGR1bW15IG5vZGUgdHlwZSB0byB1c2Ugd2hlbiBubyBhY3R1YWwgdHlwZSBpcyBhdmFpbGFibGUuXG5Ob2RlVHlwZS5ub25lID0gbmV3IE5vZGVUeXBlKFwiXCIsIE9iamVjdC5jcmVhdGUobnVsbCksIDAsIDggLyogTm9kZUZsYWcuQW5vbnltb3VzICovKTtcbi8vLyBBIG5vZGUgc2V0IGhvbGRzIGEgY29sbGVjdGlvbiBvZiBub2RlIHR5cGVzLiBJdCBpcyB1c2VkIHRvXG4vLy8gY29tcGFjdGx5IHJlcHJlc2VudCB0cmVlcyBieSBzdG9yaW5nIHRoZWlyIHR5cGUgaWRzLCByYXRoZXIgdGhhbiBhXG4vLy8gZnVsbCBwb2ludGVyIHRvIHRoZSB0eXBlIG9iamVjdCwgaW4gYSBudW1lcmljIGFycmF5LiBFYWNoIHBhcnNlclxuLy8vIFtoYXNdKCNsci5MUlBhcnNlci5ub2RlU2V0KSBhIG5vZGUgc2V0LCBhbmQgW3RyZWVcbi8vLyBidWZmZXJzXSgjY29tbW9uLlRyZWVCdWZmZXIpIGNhbiBvbmx5IHN0b3JlIGNvbGxlY3Rpb25zIG9mIG5vZGVzXG4vLy8gZnJvbSB0aGUgc2FtZSBzZXQuIEEgc2V0IGNhbiBoYXZlIGEgbWF4aW11bSBvZiAyKioxNiAoNjU1MzYpIG5vZGVcbi8vLyB0eXBlcyBpbiBpdCwgc28gdGhhdCB0aGUgaWRzIGZpdCBpbnRvIDE2LWJpdCB0eXBlZCBhcnJheSBzbG90cy5cbmNsYXNzIE5vZGVTZXQge1xuICAgIC8vLyBDcmVhdGUgYSBzZXQgd2l0aCB0aGUgZ2l2ZW4gdHlwZXMuIFRoZSBgaWRgIHByb3BlcnR5IG9mIGVhY2hcbiAgICAvLy8gdHlwZSBzaG91bGQgY29ycmVzcG9uZCB0byBpdHMgcG9zaXRpb24gd2l0aGluIHRoZSBhcnJheS5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIG5vZGUgdHlwZXMgaW4gdGhpcyBzZXQsIGJ5IGlkLlxuICAgIHR5cGVzKSB7XG4gICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0eXBlc1tpXS5pZCAhPSBpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGlkcyBzaG91bGQgY29ycmVzcG9uZCB0byBhcnJheSBwb3NpdGlvbnMgd2hlbiBjcmVhdGluZyBhIG5vZGUgc2V0XCIpO1xuICAgIH1cbiAgICAvLy8gQ3JlYXRlIGEgY29weSBvZiB0aGlzIHNldCB3aXRoIHNvbWUgbm9kZSBwcm9wZXJ0aWVzIGFkZGVkLiBUaGVcbiAgICAvLy8gYXJndW1lbnRzIHRvIHRoaXMgbWV0aG9kIGNhbiBiZSBjcmVhdGVkIHdpdGhcbiAgICAvLy8gW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuXG4gICAgZXh0ZW5kKC4uLnByb3BzKSB7XG4gICAgICAgIGxldCBuZXdUeXBlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0eXBlIG9mIHRoaXMudHlwZXMpIHtcbiAgICAgICAgICAgIGxldCBuZXdQcm9wcyA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRkID0gc291cmNlKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdQcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZS5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzW2FkZFswXS5pZF0gPSBhZGRbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VHlwZXMucHVzaChuZXdQcm9wcyA/IG5ldyBOb2RlVHlwZSh0eXBlLm5hbWUsIG5ld1Byb3BzLCB0eXBlLmlkLCB0eXBlLmZsYWdzKSA6IHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNldChuZXdUeXBlcyk7XG4gICAgfVxufVxuY29uc3QgQ2FjaGVkTm9kZSA9IG5ldyBXZWFrTWFwKCksIENhY2hlZElubmVyTm9kZSA9IG5ldyBXZWFrTWFwKCk7XG4vLy8gT3B0aW9ucyB0aGF0IGNvbnRyb2wgaXRlcmF0aW9uLiBDYW4gYmUgY29tYmluZWQgd2l0aCB0aGUgYHxgXG4vLy8gb3BlcmF0b3IgdG8gZW5hYmxlIG11bHRpcGxlIG9uZXMuXG52YXIgSXRlck1vZGU7XG4oZnVuY3Rpb24gKEl0ZXJNb2RlKSB7XG4gICAgLy8vIFdoZW4gZW5hYmxlZCwgaXRlcmF0aW9uIHdpbGwgb25seSB2aXNpdCBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgLy8vIG9iamVjdHMsIG5vdCBub2RlcyBwYWNrZWQgaW50b1xuICAgIC8vLyBbYFRyZWVCdWZmZXJgXSgjY29tbW9uLlRyZWVCdWZmZXIpcy5cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIkV4Y2x1ZGVCdWZmZXJzXCJdID0gMV0gPSBcIkV4Y2x1ZGVCdWZmZXJzXCI7XG4gICAgLy8vIEVuYWJsZSB0aGlzIHRvIG1ha2UgaXRlcmF0aW9uIGluY2x1ZGUgYW5vbnltb3VzIG5vZGVzIChzdWNoIGFzXG4gICAgLy8vIHRoZSBub2RlcyB0aGF0IHdyYXAgcmVwZWF0ZWQgZ3JhbW1hciBjb25zdHJ1Y3RzIGludG8gYSBiYWxhbmNlZFxuICAgIC8vLyB0cmVlKS5cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIkluY2x1ZGVBbm9ueW1vdXNcIl0gPSAyXSA9IFwiSW5jbHVkZUFub255bW91c1wiO1xuICAgIC8vLyBCeSBkZWZhdWx0LCByZWd1bGFyIFttb3VudGVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIG5vZGVzXG4gICAgLy8vIHJlcGxhY2UgdGhlaXIgYmFzZSBub2RlIGluIGl0ZXJhdGlvbi4gRW5hYmxlIHRoaXMgdG8gaWdub3JlIHRoZW1cbiAgICAvLy8gaW5zdGVhZC5cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIklnbm9yZU1vdW50c1wiXSA9IDRdID0gXCJJZ25vcmVNb3VudHNcIjtcbiAgICAvLy8gVGhpcyBvcHRpb24gb25seSBhcHBsaWVzIGluXG4gICAgLy8vIFtgZW50ZXJgXSgjY29tbW9uLlN5bnRheE5vZGUuZW50ZXIpLXN0eWxlIG1ldGhvZHMuIEl0IHRlbGxzIHRoZVxuICAgIC8vLyBsaWJyYXJ5IHRvIG5vdCBlbnRlciBtb3VudGVkIG92ZXJsYXlzIGlmIG9uZSBjb3ZlcnMgdGhlIGdpdmVuXG4gICAgLy8vIHBvc2l0aW9uLlxuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiSWdub3JlT3ZlcmxheXNcIl0gPSA4XSA9IFwiSWdub3JlT3ZlcmxheXNcIjtcbn0pKEl0ZXJNb2RlIHx8IChJdGVyTW9kZSA9IHt9KSk7XG4vLy8gQSBwaWVjZSBvZiBzeW50YXggdHJlZS4gVGhlcmUgYXJlIHR3byB3YXlzIHRvIGFwcHJvYWNoIHRoZXNlXG4vLy8gdHJlZXM6IHRoZSB3YXkgdGhleSBhcmUgYWN0dWFsbHkgc3RvcmVkIGluIG1lbW9yeSwgYW5kIHRoZVxuLy8vIGNvbnZlbmllbnQgd2F5LlxuLy8vXG4vLy8gU3ludGF4IHRyZWVzIGFyZSBzdG9yZWQgYXMgYSB0cmVlIG9mIGBUcmVlYCBhbmQgYFRyZWVCdWZmZXJgXG4vLy8gb2JqZWN0cy4gQnkgcGFja2luZyBkZXRhaWwgaW5mb3JtYXRpb24gaW50byBgVHJlZUJ1ZmZlcmAgbGVhZlxuLy8vIG5vZGVzLCB0aGUgcmVwcmVzZW50YXRpb24gaXMgbWFkZSBhIGxvdCBtb3JlIG1lbW9yeS1lZmZpY2llbnQuXG4vLy9cbi8vLyBIb3dldmVyLCB3aGVuIHlvdSB3YW50IHRvIGFjdHVhbGx5IHdvcmsgd2l0aCB0cmVlIG5vZGVzLCB0aGlzXG4vLy8gcmVwcmVzZW50YXRpb24gaXMgdmVyeSBhd2t3YXJkLCBzbyBtb3N0IGNsaWVudCBjb2RlIHdpbGwgd2FudCB0b1xuLy8vIHVzZSB0aGUgW2BUcmVlQ3Vyc29yYF0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBvclxuLy8vIFtgU3ludGF4Tm9kZWBdKCNjb21tb24uU3ludGF4Tm9kZSkgaW50ZXJmYWNlIGluc3RlYWQsIHdoaWNoIHByb3ZpZGVzXG4vLy8gYSB2aWV3IG9uIHNvbWUgcGFydCBvZiB0aGlzIGRhdGEgc3RydWN0dXJlLCBhbmQgY2FuIGJlIHVzZWQgdG9cbi8vLyBtb3ZlIGFyb3VuZCB0byBhZGphY2VudCBub2Rlcy5cbmNsYXNzIFRyZWUge1xuICAgIC8vLyBDb25zdHJ1Y3QgYSBuZXcgdHJlZS4gU2VlIGFsc28gW2BUcmVlLmJ1aWxkYF0oI2NvbW1vbi5UcmVlXmJ1aWxkKS5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHR5cGUgb2YgdGhlIHRvcCBub2RlLlxuICAgIHR5cGUsIFxuICAgIC8vLyBUaGlzIG5vZGUncyBjaGlsZCBub2Rlcy5cbiAgICBjaGlsZHJlbiwgXG4gICAgLy8vIFRoZSBwb3NpdGlvbnMgKG9mZnNldHMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoaXMgdHJlZSkgb2ZcbiAgICAvLy8gdGhlIGNoaWxkcmVuLlxuICAgIHBvc2l0aW9ucywgXG4gICAgLy8vIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhpcyB0cmVlXG4gICAgbGVuZ3RoLCBcbiAgICAvLy8gUGVyLW5vZGUgW25vZGUgcHJvcHNdKCNjb21tb24uTm9kZVByb3ApIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgbm9kZS5cbiAgICBwcm9wcykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLnByb3BzID0gbnVsbDtcbiAgICAgICAgaWYgKHByb3BzICYmIHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBmb3IgKGxldCBbcHJvcCwgdmFsdWVdIG9mIHByb3BzKVxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHNbdHlwZW9mIHByb3AgPT0gXCJudW1iZXJcIiA/IHByb3AgOiBwcm9wLmlkXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IG1vdW50ZWQgPSB0aGlzLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgIGlmIChtb3VudGVkICYmICFtb3VudGVkLm92ZXJsYXkpXG4gICAgICAgICAgICByZXR1cm4gbW91bnRlZC50cmVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGxldCBzdHIgPSBjaC50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gKz0gXCIsXCI7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gKz0gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhdGhpcy50eXBlLm5hbWUgPyBjaGlsZHJlbiA6XG4gICAgICAgICAgICAoL1xcVy8udGVzdCh0aGlzLnR5cGUubmFtZSkgJiYgIXRoaXMudHlwZS5pc0Vycm9yID8gSlNPTi5zdHJpbmdpZnkodGhpcy50eXBlLm5hbWUpIDogdGhpcy50eXBlLm5hbWUpICtcbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4ubGVuZ3RoID8gXCIoXCIgKyBjaGlsZHJlbiArIFwiKVwiIDogXCJcIik7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcG9zaXRpb25lZCBhdCB0aGUgdG9wIG9mXG4gICAgLy8vIHRoZSB0cmVlLiBNb2RlIGNhbiBiZSB1c2VkIHRvIFtjb250cm9sXSgjY29tbW9uLkl0ZXJNb2RlKSB3aGljaFxuICAgIC8vLyBub2RlcyB0aGUgY3Vyc29yIHZpc2l0cy5cbiAgICBjdXJzb3IobW9kZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMudG9wTm9kZSwgbW9kZSk7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcG9pbnRpbmcgaW50byB0aGlzIHRyZWVcbiAgICAvLy8gYXQgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCBzaWRlIChzZWVcbiAgICAvLy8gW2Btb3ZlVG9gXSgjY29tbW9uLlRyZWVDdXJzb3IubW92ZVRvKS5cbiAgICBjdXJzb3JBdChwb3MsIHNpZGUgPSAwLCBtb2RlID0gMCkge1xuICAgICAgICBsZXQgc2NvcGUgPSBDYWNoZWROb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGU7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgVHJlZUN1cnNvcihzY29wZSk7XG4gICAgICAgIGN1cnNvci5tb3ZlVG8ocG9zLCBzaWRlKTtcbiAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgY3Vyc29yLl90cmVlKTtcbiAgICAgICAgcmV0dXJuIGN1cnNvcjtcbiAgICB9XG4gICAgLy8vIEdldCBhIFtzeW50YXggbm9kZV0oI2NvbW1vbi5TeW50YXhOb2RlKSBvYmplY3QgZm9yIHRoZSB0b3Agb2YgdGhlXG4gICAgLy8vIHRyZWUuXG4gICAgZ2V0IHRvcE5vZGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUodGhpcywgMCwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIFtzeW50YXggbm9kZV0oI2NvbW1vbi5TeW50YXhOb2RlKSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgLy8vIElmIGBzaWRlYCBpcyAtMSwgdGhpcyB3aWxsIG1vdmUgaW50byBub2RlcyB0aGF0IGVuZCBhdCB0aGVcbiAgICAvLy8gcG9zaXRpb24uIElmIDEsIGl0J2xsIG1vdmUgaW50byBub2RlcyB0aGF0IHN0YXJ0IGF0IHRoZVxuICAgIC8vLyBwb3NpdGlvbi4gV2l0aCAwLCBpdCdsbCBvbmx5IGVudGVyIG5vZGVzIHRoYXQgY292ZXIgdGhlIHBvc2l0aW9uXG4gICAgLy8vIGZyb20gYm90aCBzaWRlcy5cbiAgICAvLy9cbiAgICAvLy8gTm90ZSB0aGF0IHRoaXMgd2lsbCBub3QgZW50ZXJcbiAgICAvLy8gW292ZXJsYXlzXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpLCBhbmQgeW91IG9mdGVuIHdhbnRcbiAgICAvLy8gW2ByZXNvbHZlSW5uZXJgXSgjY29tbW9uLlRyZWUucmVzb2x2ZUlubmVyKSBpbnN0ZWFkLlxuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJlc29sdmVOb2RlKENhY2hlZE5vZGUuZ2V0KHRoaXMpIHx8IHRoaXMudG9wTm9kZSwgcG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgICAgIENhY2hlZE5vZGUuc2V0KHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLy8vIExpa2UgW2ByZXNvbHZlYF0oI2NvbW1vbi5UcmVlLnJlc29sdmUpLCBidXQgd2lsbCBlbnRlclxuICAgIC8vLyBbb3ZlcmxhaWRdKCNjb21tb24uTW91bnRlZFRyZWUub3ZlcmxheSkgbm9kZXMsIHByb2R1Y2luZyBhIHN5bnRheCBub2RlXG4gICAgLy8vIHBvaW50aW5nIGludG8gdGhlIGlubmVybW9zdCBvdmVybGFpZCB0cmVlIGF0IHRoZSBnaXZlbiBwb3NpdGlvblxuICAgIC8vLyAod2l0aCBwYXJlbnQgbGlua3MgZ29pbmcgdGhyb3VnaCBhbGwgcGFyZW50IHN0cnVjdHVyZSwgaW5jbHVkaW5nXG4gICAgLy8vIHRoZSBob3N0IHRyZWVzKS5cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJlc29sdmVOb2RlKENhY2hlZElubmVyTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIHRydWUpO1xuICAgICAgICBDYWNoZWRJbm5lck5vZGUuc2V0KHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLy8vIEl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBhbmQgaXRzIGNoaWxkcmVuLCBjYWxsaW5nIGBlbnRlcmAgZm9yIGFueVxuICAgIC8vLyBub2RlIHRoYXQgdG91Y2hlcyB0aGUgYGZyb21gL2B0b2AgcmVnaW9uIChpZiBnaXZlbikgYmVmb3JlXG4gICAgLy8vIHJ1bm5pbmcgb3ZlciBzdWNoIGEgbm9kZSdzIGNoaWxkcmVuLCBhbmQgYGxlYXZlYCAoaWYgZ2l2ZW4pIHdoZW5cbiAgICAvLy8gbGVhdmluZyB0aGUgbm9kZS4gV2hlbiBgZW50ZXJgIHJldHVybnMgYGZhbHNlYCwgdGhhdCBub2RlIHdpbGxcbiAgICAvLy8gbm90IGhhdmUgaXRzIGNoaWxkcmVuIGl0ZXJhdGVkIG92ZXIgKG9yIGBsZWF2ZWAgY2FsbGVkKS5cbiAgICBpdGVyYXRlKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgZW50ZXIsIGxlYXZlLCBmcm9tID0gMCwgdG8gPSB0aGlzLmxlbmd0aCB9ID0gc3BlYztcbiAgICAgICAgbGV0IG1vZGUgPSBzcGVjLm1vZGUgfHwgMCwgYW5vbiA9IChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPiAwO1xuICAgICAgICBmb3IgKGxldCBjID0gdGhpcy5jdXJzb3IobW9kZSB8IEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpOzspIHtcbiAgICAgICAgICAgIGxldCBlbnRlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYy5mcm9tIDw9IHRvICYmIGMudG8gPj0gZnJvbSAmJiAoIWFub24gJiYgYy50eXBlLmlzQW5vbnltb3VzIHx8IGVudGVyKGMpICE9PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYy5maXJzdENoaWxkKCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGVudGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChlbnRlcmVkICYmIGxlYXZlICYmIChhbm9uIHx8ICFjLnR5cGUuaXNBbm9ueW1vdXMpKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZShjKTtcbiAgICAgICAgICAgICAgICBpZiAoYy5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBlbnRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gR2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gW25vZGUgcHJvcF0oI2NvbW1vbi5Ob2RlUHJvcCkgZm9yIHRoaXNcbiAgICAvLy8gbm9kZS4gV29ya3Mgd2l0aCBib3RoIHBlci1ub2RlIGFuZCBwZXItdHlwZSBwcm9wcy5cbiAgICBwcm9wKHByb3ApIHtcbiAgICAgICAgcmV0dXJuICFwcm9wLnBlck5vZGUgPyB0aGlzLnR5cGUucHJvcChwcm9wKSA6IHRoaXMucHJvcHMgPyB0aGlzLnByb3BzW3Byb3AuaWRdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLy8gUmV0dXJucyB0aGUgbm9kZSdzIFtwZXItbm9kZSBwcm9wc10oI2NvbW1vbi5Ob2RlUHJvcC5wZXJOb2RlKSBpbiBhXG4gICAgLy8vIGZvcm1hdCB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIFtgVHJlZWBdKCNjb21tb24uVHJlZSlcbiAgICAvLy8gY29uc3RydWN0b3IuXG4gICAgZ2V0IHByb3BWYWx1ZXMoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMpXG4gICAgICAgICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnByb3BzKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFsraWQsIHRoaXMucHJvcHNbaWRdXSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vLyBCYWxhbmNlIHRoZSBkaXJlY3QgY2hpbGRyZW4gb2YgdGhpcyB0cmVlLCBwcm9kdWNpbmcgYSBjb3B5IG9mXG4gICAgLy8vIHdoaWNoIG1heSBoYXZlIGNoaWxkcmVuIGdyb3VwZWQgaW50byBzdWJ0cmVlcyB3aXRoIHR5cGVcbiAgICAvLy8gW2BOb2RlVHlwZS5ub25lYF0oI2NvbW1vbi5Ob2RlVHlwZV5ub25lKS5cbiAgICBiYWxhbmNlKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA8PSA4IC8qIEJhbGFuY2UuQnJhbmNoRmFjdG9yICovID8gdGhpcyA6XG4gICAgICAgICAgICBiYWxhbmNlUmFuZ2UoTm9kZVR5cGUubm9uZSwgdGhpcy5jaGlsZHJlbiwgdGhpcy5wb3NpdGlvbnMsIDAsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoLCAwLCB0aGlzLmxlbmd0aCwgKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkgPT4gbmV3IFRyZWUodGhpcy50eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIHRoaXMucHJvcFZhbHVlcyksIGNvbmZpZy5tYWtlVHJlZSB8fCAoKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkgPT4gbmV3IFRyZWUoTm9kZVR5cGUubm9uZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSkpO1xuICAgIH1cbiAgICAvLy8gQnVpbGQgYSB0cmVlIGZyb20gYSBwb3N0Zml4LW9yZGVyZWQgYnVmZmVyIG9mIG5vZGUgaW5mb3JtYXRpb24sXG4gICAgLy8vIG9yIGEgY3Vyc29yIG92ZXIgc3VjaCBhIGJ1ZmZlci5cbiAgICBzdGF0aWMgYnVpbGQoZGF0YSkgeyByZXR1cm4gYnVpbGRUcmVlKGRhdGEpOyB9XG59XG4vLy8gVGhlIGVtcHR5IHRyZWVcblRyZWUuZW1wdHkgPSBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBbXSwgW10sIDApO1xuY2xhc3MgRmxhdEJ1ZmZlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBpbmRleCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfVxuICAgIG5leHQoKSB7IHRoaXMuaW5kZXggLT0gNDsgfVxuICAgIGZvcmsoKSB7IHJldHVybiBuZXcgRmxhdEJ1ZmZlckN1cnNvcih0aGlzLmJ1ZmZlciwgdGhpcy5pbmRleCk7IH1cbn1cbi8vLyBUcmVlIGJ1ZmZlcnMgY29udGFpbiAodHlwZSwgc3RhcnQsIGVuZCwgZW5kSW5kZXgpIHF1YWRzIGZvciBlYWNoXG4vLy8gbm9kZS4gSW4gc3VjaCBhIGJ1ZmZlciwgbm9kZXMgYXJlIHN0b3JlZCBpbiBwcmVmaXggb3JkZXIgKHBhcmVudHNcbi8vLyBiZWZvcmUgY2hpbGRyZW4sIHdpdGggdGhlIGVuZEluZGV4IG9mIHRoZSBwYXJlbnQgaW5kaWNhdGluZyB3aGljaFxuLy8vIGNoaWxkcmVuIGJlbG9uZyB0byBpdCkuXG5jbGFzcyBUcmVlQnVmZmVyIHtcbiAgICAvLy8gQ3JlYXRlIGEgdHJlZSBidWZmZXIuXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBidWZmZXIncyBjb250ZW50LlxuICAgIGJ1ZmZlciwgXG4gICAgLy8vIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGdyb3VwIG9mIG5vZGVzIGluIHRoZSBidWZmZXIuXG4gICAgbGVuZ3RoLCBcbiAgICAvLy8gVGhlIG5vZGUgc2V0IHVzZWQgaW4gdGhpcyBidWZmZXIuXG4gICAgc2V0KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIE5vZGVUeXBlLm5vbmU7IH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuYnVmZmVyLmxlbmd0aDspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuY2hpbGRTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIsXCIpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgY2hpbGRTdHJpbmcoaW5kZXgpIHtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5idWZmZXJbaW5kZXhdLCBlbmRJbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5zZXQudHlwZXNbaWRdLCByZXN1bHQgPSB0eXBlLm5hbWU7XG4gICAgICAgIGlmICgvXFxXLy50ZXN0KHJlc3VsdCkgJiYgIXR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgIGlmIChlbmRJbmRleCA9PSBpbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIFwiKFwiICsgY2hpbGRyZW4uam9pbihcIixcIikgKyBcIilcIjtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZpbmRDaGlsZChzdGFydEluZGV4LCBlbmRJbmRleCwgZGlyLCBwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLCBwaWNrID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpICE9IGVuZEluZGV4OyBpID0gYnVmZmVyW2kgKyAzXSkge1xuICAgICAgICAgICAgaWYgKGNoZWNrU2lkZShzaWRlLCBwb3MsIGJ1ZmZlcltpICsgMV0sIGJ1ZmZlcltpICsgMl0pKSB7XG4gICAgICAgICAgICAgICAgcGljayA9IGk7XG4gICAgICAgICAgICAgICAgaWYgKGRpciA+IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaWNrO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2xpY2Uoc3RhcnRJLCBlbmRJLCBmcm9tKSB7XG4gICAgICAgIGxldCBiID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGxldCBjb3B5ID0gbmV3IFVpbnQxNkFycmF5KGVuZEkgLSBzdGFydEkpLCBsZW4gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJLCBqID0gMDsgaSA8IGVuZEk7KSB7XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK107XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xuICAgICAgICAgICAgbGV0IHRvID0gY29weVtqKytdID0gYltpKytdIC0gZnJvbTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIHN0YXJ0STtcbiAgICAgICAgICAgIGxlbiA9IE1hdGgubWF4KGxlbiwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUJ1ZmZlcihjb3B5LCBsZW4sIHRoaXMuc2V0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1NpZGUoc2lkZSwgcG9zLCBmcm9tLCB0bykge1xuICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlIC0yIC8qIFNpZGUuQmVmb3JlICovOiByZXR1cm4gZnJvbSA8IHBvcztcbiAgICAgICAgY2FzZSAtMSAvKiBTaWRlLkF0T3JCZWZvcmUgKi86IHJldHVybiB0byA+PSBwb3MgJiYgZnJvbSA8IHBvcztcbiAgICAgICAgY2FzZSAwIC8qIFNpZGUuQXJvdW5kICovOiByZXR1cm4gZnJvbSA8IHBvcyAmJiB0byA+IHBvcztcbiAgICAgICAgY2FzZSAxIC8qIFNpZGUuQXRPckFmdGVyICovOiByZXR1cm4gZnJvbSA8PSBwb3MgJiYgdG8gPiBwb3M7XG4gICAgICAgIGNhc2UgMiAvKiBTaWRlLkFmdGVyICovOiByZXR1cm4gdG8gPiBwb3M7XG4gICAgICAgIGNhc2UgNCAvKiBTaWRlLkRvbnRDYXJlICovOiByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShub2RlLCBwb3MpIHtcbiAgICBsZXQgc2NhbiA9IG5vZGUuY2hpbGRCZWZvcmUocG9zKTtcbiAgICB3aGlsZSAoc2Nhbikge1xuICAgICAgICBsZXQgbGFzdCA9IHNjYW4ubGFzdENoaWxkO1xuICAgICAgICBpZiAoIWxhc3QgfHwgbGFzdC50byAhPSBzY2FuLnRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChsYXN0LnR5cGUuaXNFcnJvciAmJiBsYXN0LmZyb20gPT0gbGFzdC50bykge1xuICAgICAgICAgICAgbm9kZSA9IHNjYW47XG4gICAgICAgICAgICBzY2FuID0gbGFzdC5wcmV2U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjYW4gPSBsYXN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZU5vZGUobm9kZSwgcG9zLCBzaWRlLCBvdmVybGF5cykge1xuICAgIHZhciBfYTtcbiAgICAvLyBNb3ZlIHVwIHRvIGEgbm9kZSB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBwb3NpdGlvbiwgaWYgcG9zc2libGVcbiAgICB3aGlsZSAobm9kZS5mcm9tID09IG5vZGUudG8gfHxcbiAgICAgICAgKHNpZGUgPCAxID8gbm9kZS5mcm9tID49IHBvcyA6IG5vZGUuZnJvbSA+IHBvcykgfHxcbiAgICAgICAgKHNpZGUgPiAtMSA/IG5vZGUudG8gPD0gcG9zIDogbm9kZS50byA8IHBvcykpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9ICFvdmVybGF5cyAmJiBub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUgJiYgbm9kZS5pbmRleCA8IDAgPyBudWxsIDogbm9kZS5wYXJlbnQ7XG4gICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfVxuICAgIGxldCBtb2RlID0gb3ZlcmxheXMgPyAwIDogSXRlck1vZGUuSWdub3JlT3ZlcmxheXM7XG4gICAgLy8gTXVzdCBnbyB1cCBvdXQgb2Ygb3ZlcmxheXMgd2hlbiB0aG9zZSBkbyBub3Qgb3ZlcmxhcCB3aXRoIHBvc1xuICAgIGlmIChvdmVybGF5cylcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IG5vZGUsIHBhcmVudCA9IHNjYW4ucGFyZW50OyBwYXJlbnQ7IHNjYW4gPSBwYXJlbnQsIHBhcmVudCA9IHNjYW4ucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoc2NhbiBpbnN0YW5jZW9mIFRyZWVOb2RlICYmIHNjYW4uaW5kZXggPCAwICYmICgoX2EgPSBwYXJlbnQuZW50ZXIocG9zLCBzaWRlLCBtb2RlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZyb20pICE9IHNjYW4uZnJvbSlcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgaW5uZXIgPSBub2RlLmVudGVyKHBvcywgc2lkZSwgbW9kZSk7XG4gICAgICAgIGlmICghaW5uZXIpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgbm9kZSA9IGlubmVyO1xuICAgIH1cbn1cbmNsYXNzIFRyZWVOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihfdHJlZSwgZnJvbSwgXG4gICAgLy8gSW5kZXggaW4gcGFyZW50IG5vZGUsIHNldCB0byAtMSBpZiB0aGUgbm9kZSBpcyBub3QgYSBkaXJlY3QgY2hpbGQgb2YgX3BhcmVudC5ub2RlIChvdmVybGF5KVxuICAgIGluZGV4LCBfcGFyZW50KSB7XG4gICAgICAgIHRoaXMuX3RyZWUgPSBfdHJlZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWUudHlwZTsgfVxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy5fdHJlZS50eXBlLm5hbWU7IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLl90cmVlLmxlbmd0aDsgfVxuICAgIG5leHRDaGlsZChpLCBkaXIsIHBvcywgc2lkZSwgbW9kZSA9IDApIHtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpczs7KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB7IGNoaWxkcmVuLCBwb3NpdGlvbnMgfSA9IHBhcmVudC5fdHJlZSwgZSA9IGRpciA+IDAgPyBjaGlsZHJlbi5sZW5ndGggOiAtMTsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY2hpbGRyZW5baV0sIHN0YXJ0ID0gcG9zaXRpb25zW2ldICsgcGFyZW50LmZyb207XG4gICAgICAgICAgICAgICAgaWYgKCFjaGVja1NpZGUoc2lkZSwgcG9zLCBzdGFydCwgc3RhcnQgKyBuZXh0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVHJlZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSAmIEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IG5leHQuZmluZENoaWxkKDAsIG5leHQuYnVmZmVyLmxlbmd0aCwgZGlyLCBwb3MgLSBzdGFydCwgc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKG5ldyBCdWZmZXJDb250ZXh0KHBhcmVudCwgbmV4dCwgaSwgc3RhcnQpLCBudWxsLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHwgKCFuZXh0LnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQobmV4dCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShtb2RlICYgSXRlck1vZGUuSWdub3JlTW91bnRzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5wcm9wcyAmJiAobW91bnRlZCA9IG5leHQucHJvcChOb2RlUHJvcC5tb3VudGVkKSkgJiYgIW1vdW50ZWQub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBzdGFydCwgaSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlubmVyID0gbmV3IFRyZWVOb2RlKG5leHQsIHN0YXJ0LCBpLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fCAhaW5uZXIudHlwZS5pc0Fub255bW91cyA/IGlubmVyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGlubmVyLm5leHRDaGlsZChkaXIgPCAwID8gbmV4dC5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8ICFwYXJlbnQudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuaW5kZXggPj0gMClcbiAgICAgICAgICAgICAgICBpID0gcGFyZW50LmluZGV4ICsgZGlyO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGkgPSBkaXIgPCAwID8gLTEgOiBwYXJlbnQuX3BhcmVudC5fdHJlZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLl90cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIHBvcywgMiAvKiBTaWRlLkFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICBpZiAoIShtb2RlICYgSXRlck1vZGUuSWdub3JlT3ZlcmxheXMpICYmIChtb3VudGVkID0gdGhpcy5fdHJlZS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpKSAmJiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCByUG9zID0gcG9zIC0gdGhpcy5mcm9tO1xuICAgICAgICAgICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA+IDAgPyBmcm9tIDw9IHJQb3MgOiBmcm9tIDwgclBvcykgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNpZGUgPCAwID8gdG8gPj0gclBvcyA6IHRvID4gclBvcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBtb3VudGVkLm92ZXJsYXlbMF0uZnJvbSArIHRoaXMuZnJvbSwgLTEsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MsIHNpZGUsIG1vZGUpO1xuICAgIH1cbiAgICBuZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodmFsLnR5cGUuaXNBbm9ueW1vdXMgJiYgdmFsLl9wYXJlbnQpXG4gICAgICAgICAgICB2YWwgPSB2YWwuX3BhcmVudDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLmluZGV4ID49IDAgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggKyAxLCAxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuaW5kZXggPj0gMCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCAtIDEsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgY3Vyc29yKG1vZGUgPSAwKSB7IHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLCBtb2RlKTsgfVxuICAgIGdldCB0cmVlKCkgeyByZXR1cm4gdGhpcy5fdHJlZTsgfVxuICAgIHRvVHJlZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWU7IH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCB0cnVlKTtcbiAgICB9XG4gICAgZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKSB7IHJldHVybiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZSh0aGlzLCBwb3MpOyB9XG4gICAgZ2V0Q2hpbGQodHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIGxldCByID0gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgICAgIHJldHVybiByLmxlbmd0aCA/IHJbMF0gOiBudWxsO1xuICAgIH1cbiAgICBnZXRDaGlsZHJlbih0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7IH1cbiAgICBnZXQgbm9kZSgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICBtYXRjaENvbnRleHQoY29udGV4dCkgeyByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLCBjb250ZXh0KTsgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW4obm9kZSwgdHlwZSwgYmVmb3JlLCBhZnRlcikge1xuICAgIGxldCBjdXIgPSBub2RlLmN1cnNvcigpLCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIWN1ci5maXJzdENoaWxkKCkpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKGJlZm9yZSAhPSBudWxsKVxuICAgICAgICB3aGlsZSAoIWN1ci50eXBlLmlzKGJlZm9yZSkpXG4gICAgICAgICAgICBpZiAoIWN1ci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoYWZ0ZXIgIT0gbnVsbCAmJiBjdXIudHlwZS5pcyhhZnRlcikpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAoY3VyLnR5cGUuaXModHlwZSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXIubm9kZSk7XG4gICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICByZXR1cm4gYWZ0ZXIgPT0gbnVsbCA/IHJlc3VsdCA6IFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hdGNoTm9kZUNvbnRleHQobm9kZSwgY29udGV4dCwgaSA9IGNvbnRleHQubGVuZ3RoIC0gMSkge1xuICAgIGZvciAobGV0IHAgPSBub2RlLnBhcmVudDsgaSA+PSAwOyBwID0gcC5wYXJlbnQpIHtcbiAgICAgICAgaWYgKCFwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXAudHlwZS5pc0Fub255bW91cykge1xuICAgICAgICAgICAgaWYgKGNvbnRleHRbaV0gJiYgY29udGV4dFtpXSAhPSBwLm5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuY2xhc3MgQnVmZmVyQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBidWZmZXIsIGluZGV4LCBzdGFydCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIH1cbn1cbmNsYXNzIEJ1ZmZlck5vZGUge1xuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy50eXBlLm5hbWU7IH1cbiAgICBnZXQgZnJvbSgpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXTsgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAyXTsgfVxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIF9wYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gY29udGV4dC5idWZmZXIuc2V0LnR5cGVzW2NvbnRleHQuYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgIH1cbiAgICBjaGlsZChkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIHBvcywgMiAvKiBTaWRlLkFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGlmIChtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBzaWRlID4gMCA/IDEgOiAtMSwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCB8fCB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgIH1cbiAgICBleHRlcm5hbFNpYmxpbmcoZGlyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyBudWxsIDogdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0Q2hpbGQodGhpcy5jb250ZXh0LmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoYWZ0ZXIgPCAodGhpcy5fcGFyZW50ID8gYnVmZmVyLmJ1ZmZlclt0aGlzLl9wYXJlbnQuaW5kZXggKyAzXSA6IGJ1ZmZlci5idWZmZXIubGVuZ3RoKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlcm5hbFNpYmxpbmcoMSk7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBwYXJlbnRTdGFydCA9IHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5pbmRleCArIDQgOiAwO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygtMSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykpO1xuICAgIH1cbiAgICBjdXJzb3IobW9kZSA9IDApIHsgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMsIG1vZGUpOyB9XG4gICAgZ2V0IHRyZWUoKSB7IHJldHVybiBudWxsOyB9XG4gICAgdG9UcmVlKCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXSwgcG9zaXRpb25zID0gW107XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgc3RhcnRJID0gdGhpcy5pbmRleCArIDQsIGVuZEkgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgaWYgKGVuZEkgPiBzdGFydEkpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMV07XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGJ1ZmZlci5zbGljZShzdGFydEksIGVuZEksIGZyb20pKTtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0aGlzLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIHRoaXMudG8gLSB0aGlzLmZyb20pO1xuICAgIH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCB0cnVlKTtcbiAgICB9XG4gICAgZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKSB7IHJldHVybiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZSh0aGlzLCBwb3MpOyB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KTsgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG4gICAgZ2V0IG5vZGUoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgbWF0Y2hDb250ZXh0KGNvbnRleHQpIHsgcmV0dXJuIG1hdGNoTm9kZUNvbnRleHQodGhpcywgY29udGV4dCk7IH1cbn1cbi8vLyBBIHRyZWUgY3Vyc29yIG9iamVjdCBmb2N1c2VzIG9uIGEgZ2l2ZW4gbm9kZSBpbiBhIHN5bnRheCB0cmVlLCBhbmRcbi8vLyBhbGxvd3MgeW91IHRvIG1vdmUgdG8gYWRqYWNlbnQgbm9kZXMuXG5jbGFzcyBUcmVlQ3Vyc29yIHtcbiAgICAvLy8gU2hvcnRoYW5kIGZvciBgLnR5cGUubmFtZWAuXG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLnR5cGUubmFtZTsgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgbW9kZSA9IDApIHtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5idWZmZXJOb2RlID0gbnVsbDtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy55aWVsZE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmVlID0gbm9kZS5jb250ZXh0LnBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbm9kZS5jb250ZXh0O1xuICAgICAgICAgICAgZm9yIChsZXQgbiA9IG5vZGUuX3BhcmVudDsgbjsgbiA9IG4uX3BhcmVudClcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnVuc2hpZnQobi5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy55aWVsZEJ1Zihub2RlLmluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB5aWVsZE5vZGUobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RyZWUgPSBub2RlO1xuICAgICAgICB0aGlzLnR5cGUgPSBub2RlLnR5cGU7XG4gICAgICAgIHRoaXMuZnJvbSA9IG5vZGUuZnJvbTtcbiAgICAgICAgdGhpcy50byA9IG5vZGUudG87XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB5aWVsZEJ1ZihpbmRleCwgdHlwZSkge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IGJ1ZmZlci5zZXQudHlwZXNbYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgICAgICB0aGlzLmZyb20gPSBzdGFydCArIGJ1ZmZlci5idWZmZXJbaW5kZXggKyAxXTtcbiAgICAgICAgdGhpcy50byA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDJdO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgeWllbGQobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYobm9kZS5pbmRleCwgbm9kZS50eXBlKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlci5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCkgOiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBlbnRlckNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLm5leHRDaGlsZChkaXIgPCAwID8gdGhpcy5fdHJlZS5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUsIHRoaXMubW9kZSkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBwb3MgLSB0aGlzLmJ1ZmZlci5zdGFydCwgc2lkZSk7XG4gICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoaW5kZXgpO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGZpcnN0IGNoaWxkLiBXaGVuIHRoaXMgcmV0dXJuc1xuICAgIC8vLyBmYWxzZSwgdGhlIG5vZGUgaGFzIG5vIGNoaWxkLCBhbmQgdGhlIGN1cnNvciBoYXMgbm90IGJlZW4gbW92ZWQuXG4gICAgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGlzIG5vZGUncyBsYXN0IGNoaWxkLlxuICAgIGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGZpcnN0IGNoaWxkIHRoYXQgZW5kcyBhZnRlciBgcG9zYC5cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKDEsIHBvcywgMiAvKiBTaWRlLkFmdGVyICovKTsgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBsYXN0IGNoaWxkIHRoYXQgc3RhcnRzIGJlZm9yZSBgcG9zYC5cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBjaGlsZCBhcm91bmQgYHBvc2AuIElmIHNpZGUgaXMgLTEgdGhlXG4gICAgLy8vIGNoaWxkIG1heSBlbmQgYXQgdGhhdCBwb3NpdGlvbiwgd2hlbiAxIGl0IG1heSBzdGFydCB0aGVyZS4gVGhpc1xuICAgIC8vLyB3aWxsIGFsc28gZW50ZXIgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpXG4gICAgLy8vIFttb3VudGVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIHRyZWVzIHVubGVzcyBgb3ZlcmxheXNgIGlzXG4gICAgLy8vIHNldCB0byBmYWxzZS5cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSB0aGlzLm1vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuZW50ZXIocG9zLCBzaWRlLCBtb2RlKSk7XG4gICAgICAgIHJldHVybiBtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMgPyBmYWxzZSA6IHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbm9kZSdzIHBhcmVudCBub2RlLCBpZiB0aGlzIGlzbid0IHRoZSB0b3Agbm9kZS5cbiAgICBwYXJlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUoKHRoaXMubW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpID8gdGhpcy5fdHJlZS5fcGFyZW50IDogdGhpcy5fdHJlZS5wYXJlbnQpO1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1Zih0aGlzLnN0YWNrLnBvcCgpKTtcbiAgICAgICAgbGV0IHBhcmVudCA9ICh0aGlzLm1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSA/IHRoaXMuYnVmZmVyLnBhcmVudCA6IHRoaXMuYnVmZmVyLnBhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUocGFyZW50KTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNpYmxpbmcoZGlyKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuX3RyZWUuX3BhcmVudCA/IGZhbHNlXG4gICAgICAgICAgICAgICAgOiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuaW5kZXggPCAwID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX3RyZWUuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5fdHJlZS5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8sIHRoaXMubW9kZSkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyLCBkID0gdGhpcy5zdGFjay5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoZGlyIDwgMCkge1xuICAgICAgICAgICAgbGV0IHBhcmVudFN0YXJ0ID0gZCA8IDAgPyAwIDogdGhpcy5zdGFja1tkXSArIDQ7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleCAhPSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihidWZmZXIuZmluZENoaWxkKHBhcmVudFN0YXJ0LCB0aGlzLmluZGV4LCAtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgICAgIGlmIChhZnRlciA8IChkIDwgMCA/IGJ1ZmZlci5idWZmZXIubGVuZ3RoIDogYnVmZmVyLmJ1ZmZlclt0aGlzLnN0YWNrW2RdICsgM10pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZCA8IDAgPyB0aGlzLnlpZWxkKHRoaXMuYnVmZmVyLnBhcmVudC5uZXh0Q2hpbGQodGhpcy5idWZmZXIuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovLCB0aGlzLm1vZGUpKSA6IGZhbHNlO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0byB0aGlzIG5vZGUncyBuZXh0IHNpYmxpbmcsIGlmIGFueS5cbiAgICBuZXh0U2libGluZygpIHsgcmV0dXJuIHRoaXMuc2libGluZygxKTsgfVxuICAgIC8vLyBNb3ZlIHRvIHRoaXMgbm9kZSdzIHByZXZpb3VzIHNpYmxpbmcsIGlmIGFueS5cbiAgICBwcmV2U2libGluZygpIHsgcmV0dXJuIHRoaXMuc2libGluZygtMSk7IH1cbiAgICBhdExhc3ROb2RlKGRpcikge1xuICAgICAgICBsZXQgaW5kZXgsIHBhcmVudCwgeyBidWZmZXIgfSA9IHRoaXM7XG4gICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPCBidWZmZXIuYnVmZmVyLmJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbmRleDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLmJ1ZmZlci5idWZmZXJbaSArIDNdIDwgdGhpcy5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICh7IGluZGV4LCBwYXJlbnQgfSA9IGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSB0aGlzLl90cmVlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgcGFyZW50OyB7IGluZGV4LCBfcGFyZW50OiBwYXJlbnQgfSA9IHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4ICsgZGlyLCBlID0gZGlyIDwgMCA/IC0xIDogcGFyZW50Ll90cmVlLmNoaWxkcmVuLmxlbmd0aDsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSBwYXJlbnQuX3RyZWUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIGlmICgodGhpcy5tb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIWNoaWxkLnR5cGUuaXNBbm9ueW1vdXMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NoaWxkKGNoaWxkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG1vdmUoZGlyLCBlbnRlcikge1xuICAgICAgICBpZiAoZW50ZXIgJiYgdGhpcy5lbnRlckNoaWxkKGRpciwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zaWJsaW5nKGRpcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5hdExhc3ROb2RlKGRpcikgfHwgIXRoaXMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBuZXh0IG5vZGUgaW4gYVxuICAgIC8vLyBbcHJlLW9yZGVyXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmVlX3RyYXZlcnNhbCNQcmUtb3JkZXIsX05MUilcbiAgICAvLy8gdHJhdmVyc2FsLCBnb2luZyBmcm9tIGEgbm9kZSB0byBpdHMgZmlyc3QgY2hpbGQgb3IsIGlmIHRoZVxuICAgIC8vLyBjdXJyZW50IG5vZGUgaXMgZW1wdHkgb3IgYGVudGVyYCBpcyBmYWxzZSwgaXRzIG5leHQgc2libGluZyBvclxuICAgIC8vLyB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnQgbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgbmV4dChlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgxLCBlbnRlcik7IH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGEgbGFzdC10by1maXJzdCBwcmUtb3JkZXIgdHJhdmVyYWwuIEFcbiAgICAvLy8gbm9kZSBpcyBmb2xsb3dlZCBieSBpdHMgbGFzdCBjaGlsZCBvciwgaWYgaXQgaGFzIG5vbmUsIGl0c1xuICAgIC8vLyBwcmV2aW91cyBzaWJsaW5nIG9yIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnRcbiAgICAvLy8gbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgcHJldihlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgtMSwgZW50ZXIpOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgaW5uZXJtb3N0IG5vZGUgdGhhdCBjb3ZlcnMgYHBvc2AuIElmXG4gICAgLy8vIGBzaWRlYCBpcyAtMSwgaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IGVuZCBhdCBgcG9zYC4gSWYgaXQgaXMgMSxcbiAgICAvLy8gaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IHN0YXJ0IGF0IGBwb3NgLlxuICAgIG1vdmVUbyhwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIC8vIE1vdmUgdXAgdG8gYSBub2RlIHRoYXQgYWN0dWFsbHkgaG9sZHMgdGhlIHBvc2l0aW9uLCBpZiBwb3NzaWJsZVxuICAgICAgICB3aGlsZSAodGhpcy5mcm9tID09IHRoaXMudG8gfHxcbiAgICAgICAgICAgIChzaWRlIDwgMSA/IHRoaXMuZnJvbSA+PSBwb3MgOiB0aGlzLmZyb20gPiBwb3MpIHx8XG4gICAgICAgICAgICAoc2lkZSA+IC0xID8gdGhpcy50byA8PSBwb3MgOiB0aGlzLnRvIDwgcG9zKSlcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gVGhlbiBzY2FuIGRvd24gaW50byBjaGlsZCBub2RlcyBhcyBmYXIgYXMgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpKSB7IH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGN1cnNvcidzIGN1cnJlbnRcbiAgICAvLy8gcG9zaXRpb24uXG4gICAgZ2V0IG5vZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgICAgICAgbGV0IGNhY2hlID0gdGhpcy5idWZmZXJOb2RlLCByZXN1bHQgPSBudWxsLCBkZXB0aCA9IDA7XG4gICAgICAgIGlmIChjYWNoZSAmJiBjYWNoZS5jb250ZXh0ID09IHRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgICBzY2FuOiBmb3IgKGxldCBpbmRleCA9IHRoaXMuaW5kZXgsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aDsgZCA+PSAwOykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGMgPSBjYWNoZTsgYzsgYyA9IGMuX3BhcmVudClcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuaW5kZXggPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoID0gZCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnN0YWNrWy0tZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IGRlcHRoOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuc3RhY2tbaV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJOb2RlID0gbmV3IEJ1ZmZlck5vZGUodGhpcy5idWZmZXIsIHJlc3VsdCwgdGhpcy5pbmRleCk7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIFt0cmVlXSgjY29tbW9uLlRyZWUpIHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBub2RlLCBpZlxuICAgIC8vLyBhbnkuIFdpbGwgcmV0dXJuIG51bGwgd2hlbiB0aGUgbm9kZSBpcyBpbiBhIFt0cmVlXG4gICAgLy8vIGJ1ZmZlcl0oI2NvbW1vbi5UcmVlQnVmZmVyKS5cbiAgICBnZXQgdHJlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gbnVsbCA6IHRoaXMuX3RyZWUuX3RyZWU7XG4gICAgfVxuICAgIC8vLyBJdGVyYXRlIG92ZXIgdGhlIGN1cnJlbnQgbm9kZSBhbmQgYWxsIGl0cyBkZXNjZW5kYW50cywgY2FsbGluZ1xuICAgIC8vLyBgZW50ZXJgIHdoZW4gZW50ZXJpbmcgYSBub2RlIGFuZCBgbGVhdmVgLCBpZiBnaXZlbiwgd2hlbiBsZWF2aW5nXG4gICAgLy8vIG9uZS4gV2hlbiBgZW50ZXJgIHJldHVybnMgYGZhbHNlYCwgYW55IGNoaWxkcmVuIG9mIHRoYXQgbm9kZSBhcmVcbiAgICAvLy8gc2tpcHBlZCwgYW5kIGBsZWF2ZWAgaXNuJ3QgY2FsbGVkIGZvciBpdC5cbiAgICBpdGVyYXRlKGVudGVyLCBsZWF2ZSkge1xuICAgICAgICBmb3IgKGxldCBkZXB0aCA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IG11c3RMZWF2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZS5pc0Fub255bW91cyB8fCBlbnRlcih0aGlzKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChtdXN0TGVhdmUgJiYgbGVhdmUpXG4gICAgICAgICAgICAgICAgICAgIGxlYXZlKHRoaXMpO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRoaXMudHlwZS5pc0Fub255bW91cztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIFRlc3Qgd2hldGhlciB0aGUgY3VycmVudCBub2RlIG1hdGNoZXMgYSBnaXZlbiBjb250ZXh04oCUYSBzZXF1ZW5jZVxuICAgIC8vLyBvZiBkaXJlY3QgcGFyZW50IG5vZGUgbmFtZXMuIEVtcHR5IHN0cmluZ3MgaW4gdGhlIGNvbnRleHQgYXJyYXlcbiAgICAvLy8gYXJlIHRyZWF0ZWQgYXMgd2lsZGNhcmRzLlxuICAgIG1hdGNoQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLm5vZGUsIGNvbnRleHQpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyLCB7IHR5cGVzIH0gPSBidWZmZXIuc2V0O1xuICAgICAgICBmb3IgKGxldCBpID0gY29udGV4dC5sZW5ndGggLSAxLCBkID0gdGhpcy5zdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGQtLSkge1xuICAgICAgICAgICAgaWYgKGQgPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMubm9kZSwgY29udGV4dCwgaSk7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2J1ZmZlci5idWZmZXJbdGhpcy5zdGFja1tkXV1dO1xuICAgICAgICAgICAgaWYgKCF0eXBlLmlzQW5vbnltb3VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHRbaV0gJiYgY29udGV4dFtpXSAhPSB0eXBlLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQ2hpbGQodHJlZSkge1xuICAgIHJldHVybiB0cmVlLmNoaWxkcmVuLnNvbWUoY2ggPT4gY2ggaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8ICFjaC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKGNoKSk7XG59XG5mdW5jdGlvbiBidWlsZFRyZWUoZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgeyBidWZmZXIsIG5vZGVTZXQsIG1heEJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGgsIHJldXNlZCA9IFtdLCBtaW5SZXBlYXRUeXBlID0gbm9kZVNldC50eXBlcy5sZW5ndGggfSA9IGRhdGE7XG4gICAgbGV0IGN1cnNvciA9IEFycmF5LmlzQXJyYXkoYnVmZmVyKSA/IG5ldyBGbGF0QnVmZmVyQ3Vyc29yKGJ1ZmZlciwgYnVmZmVyLmxlbmd0aCkgOiBidWZmZXI7XG4gICAgbGV0IHR5cGVzID0gbm9kZVNldC50eXBlcztcbiAgICBsZXQgY29udGV4dEhhc2ggPSAwLCBsb29rQWhlYWQgPSAwO1xuICAgIGZ1bmN0aW9uIHRha2VOb2RlKHBhcmVudFN0YXJ0LCBtaW5Qb3MsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGluUmVwZWF0KSB7XG4gICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgIGxldCBsb29rQWhlYWRBdFN0YXJ0ID0gbG9va0FoZWFkO1xuICAgICAgICB3aGlsZSAoc2l6ZSA8IDApIHtcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoc2l6ZSA9PSAtMSAvKiBTcGVjaWFsUmVjb3JkLlJldXNlICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSByZXVzZWRbaWRdO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnQgLSBwYXJlbnRTdGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtMyAvKiBTcGVjaWFsUmVjb3JkLkNvbnRleHRDaGFuZ2UgKi8pIHsgLy8gQ29udGV4dCBjaGFuZ2VcbiAgICAgICAgICAgICAgICBjb250ZXh0SGFzaCA9IGlkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTQgLyogU3BlY2lhbFJlY29yZC5Mb29rQWhlYWQgKi8pIHtcbiAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBpZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5yZWNvZ25pemVkIHJlY29yZCBzaXplOiAke3NpemV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpZF0sIG5vZGUsIGJ1ZmZlcjtcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgaWYgKGVuZCAtIHN0YXJ0IDw9IG1heEJ1ZmZlckxlbmd0aCAmJiAoYnVmZmVyID0gZmluZEJ1ZmZlclNpemUoY3Vyc29yLnBvcyAtIG1pblBvcywgaW5SZXBlYXQpKSkge1xuICAgICAgICAgICAgLy8gU21hbGwgZW5vdWdoIGZvciBhIGJ1ZmZlciwgYW5kIG5vIHJldXNlZCBub2RlcyBpbnNpZGVcbiAgICAgICAgICAgIGxldCBkYXRhID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlci5zaXplIC0gYnVmZmVyLnNraXApO1xuICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSBidWZmZXIuc2l6ZSwgaW5kZXggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgIGluZGV4ID0gY29weVRvQnVmZmVyKGJ1ZmZlci5zdGFydCwgZGF0YSwgaW5kZXgpO1xuICAgICAgICAgICAgbm9kZSA9IG5ldyBUcmVlQnVmZmVyKGRhdGEsIGVuZCAtIGJ1ZmZlci5zdGFydCwgbm9kZVNldCk7XG4gICAgICAgICAgICBzdGFydFBvcyA9IGJ1ZmZlci5zdGFydCAtIHBhcmVudFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBNYWtlIGl0IGEgbm9kZVxuICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSBzaXplO1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgICAgICAgICBsZXQgbG9jYWxJblJlcGVhdCA9IGlkID49IG1pblJlcGVhdFR5cGUgPyBpZCA6IC0xO1xuICAgICAgICAgICAgbGV0IGxhc3RHcm91cCA9IDAsIGxhc3RFbmQgPSBlbmQ7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID49IDAgJiYgY3Vyc29yLmlkID09IGxvY2FsSW5SZXBlYXQgJiYgY3Vyc29yLnNpemUgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLmVuZCA8PSBsYXN0RW5kIC0gbWF4QnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUmVwZWF0TGVhZihsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgc3RhcnQsIGxhc3RHcm91cCwgY3Vyc29yLmVuZCwgbGFzdEVuZCwgbG9jYWxJblJlcGVhdCwgbG9va0FoZWFkQXRTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0R3JvdXAgPSBsb2NhbENoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RFbmQgPSBjdXJzb3IuZW5kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YWtlTm9kZShzdGFydCwgZW5kUG9zLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbG9jYWxJblJlcGVhdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPj0gMCAmJiBsYXN0R3JvdXAgPiAwICYmIGxhc3RHcm91cCA8IGxvY2FsQ2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIG1ha2VSZXBlYXRMZWFmKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBzdGFydCwgbGFzdEdyb3VwLCBzdGFydCwgbGFzdEVuZCwgbG9jYWxJblJlcGVhdCwgbG9va0FoZWFkQXRTdGFydCk7XG4gICAgICAgICAgICBsb2NhbENoaWxkcmVuLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID4gLTEgJiYgbGFzdEdyb3VwID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBtYWtlID0gbWFrZUJhbGFuY2VkKHR5cGUpO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBiYWxhbmNlUmFuZ2UodHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIDAsIGxvY2FsQ2hpbGRyZW4ubGVuZ3RoLCAwLCBlbmQgLSBzdGFydCwgbWFrZSwgbWFrZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbWFrZVRyZWUodHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGVuZCAtIHN0YXJ0LCBsb29rQWhlYWRBdFN0YXJ0IC0gZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydFBvcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VCYWxhbmNlZCh0eXBlKSB7XG4gICAgICAgIHJldHVybiAoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICBsZXQgbG9va0FoZWFkID0gMCwgbGFzdEkgPSBjaGlsZHJlbi5sZW5ndGggLSAxLCBsYXN0LCBsb29rQWhlYWRQcm9wO1xuICAgICAgICAgICAgaWYgKGxhc3RJID49IDAgJiYgKGxhc3QgPSBjaGlsZHJlbltsYXN0SV0pIGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgICAgIGlmICghbGFzdEkgJiYgbGFzdC50eXBlID09IHR5cGUgJiYgbGFzdC5sZW5ndGggPT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFzdDtcbiAgICAgICAgICAgICAgICBpZiAobG9va0FoZWFkUHJvcCA9IGxhc3QucHJvcChOb2RlUHJvcC5sb29rQWhlYWQpKVxuICAgICAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBwb3NpdGlvbnNbbGFzdEldICsgbGFzdC5sZW5ndGggKyBsb29rQWhlYWRQcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1ha2VUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgbG9va0FoZWFkKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVJlcGVhdExlYWYoY2hpbGRyZW4sIHBvc2l0aW9ucywgYmFzZSwgaSwgZnJvbSwgdG8sIHR5cGUsIGxvb2tBaGVhZCkge1xuICAgICAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICB3aGlsZSAoY2hpbGRyZW4ubGVuZ3RoID4gaSkge1xuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGNoaWxkcmVuLnBvcCgpKTtcbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2gocG9zaXRpb25zLnBvcCgpICsgYmFzZSAtIGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnB1c2gobWFrZVRyZWUobm9kZVNldC50eXBlc1t0eXBlXSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHRvIC0gZnJvbSwgbG9va0FoZWFkIC0gdG8pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIGJhc2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIGxvb2tBaGVhZCA9IDAsIHByb3BzKSB7XG4gICAgICAgIGlmIChjb250ZXh0SGFzaCkge1xuICAgICAgICAgICAgbGV0IHBhaXIgPSBbTm9kZVByb3AuY29udGV4dEhhc2gsIGNvbnRleHRIYXNoXTtcbiAgICAgICAgICAgIHByb3BzID0gcHJvcHMgPyBbcGFpcl0uY29uY2F0KHByb3BzKSA6IFtwYWlyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9va0FoZWFkID4gMjUpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gW05vZGVQcm9wLmxvb2tBaGVhZCwgbG9va0FoZWFkXTtcbiAgICAgICAgICAgIHByb3BzID0gcHJvcHMgPyBbcGFpcl0uY29uY2F0KHByb3BzKSA6IFtwYWlyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBwcm9wcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRCdWZmZXJTaXplKG1heFNpemUsIGluUmVwZWF0KSB7XG4gICAgICAgIC8vIFNjYW4gdGhyb3VnaCB0aGUgYnVmZmVyIHRvIGZpbmQgcHJldmlvdXMgc2libGluZ3MgdGhhdCBmaXRcbiAgICAgICAgLy8gdG9nZXRoZXIgaW4gYSBUcmVlQnVmZmVyLCBhbmQgZG9uJ3QgY29udGFpbiBhbnkgcmV1c2VkIG5vZGVzXG4gICAgICAgIC8vICh3aGljaCBjYW4ndCBiZSBzdG9yZWQgaW4gYSBidWZmZXIpLlxuICAgICAgICAvLyBJZiBgaW5SZXBlYXRgIGlzID4gLTEsIGlnbm9yZSBub2RlIGJvdW5kYXJpZXMgb2YgdGhhdCB0eXBlIGZvclxuICAgICAgICAvLyBuZXN0aW5nLCBidXQgbWFrZSBzdXJlIHRoZSBlbmQgZmFsbHMgZWl0aGVyIGF0IHRoZSBzdGFydFxuICAgICAgICAvLyAoYG1heFNpemVgKSBvciBiZWZvcmUgc3VjaCBhIG5vZGUuXG4gICAgICAgIGxldCBmb3JrID0gY3Vyc29yLmZvcmsoKTtcbiAgICAgICAgbGV0IHNpemUgPSAwLCBzdGFydCA9IDAsIHNraXAgPSAwLCBtaW5TdGFydCA9IGZvcmsuZW5kIC0gbWF4QnVmZmVyTGVuZ3RoO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyBzaXplOiAwLCBzdGFydDogMCwgc2tpcDogMCB9O1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBtaW5Qb3MgPSBmb3JrLnBvcyAtIG1heFNpemU7IGZvcmsucG9zID4gbWluUG9zOykge1xuICAgICAgICAgICAgbGV0IG5vZGVTaXplID0gZm9yay5zaXplO1xuICAgICAgICAgICAgLy8gUHJldGVuZCBuZXN0ZWQgcmVwZWF0IG5vZGVzIG9mIHRoZSBzYW1lIHR5cGUgZG9uJ3QgZXhpc3RcbiAgICAgICAgICAgIGlmIChmb3JrLmlkID09IGluUmVwZWF0ICYmIG5vZGVTaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyBFeGNlcHQgdGhhdCB3ZSBzdG9yZSB0aGUgY3VycmVudCBzdGF0ZSBhcyBhIHZhbGlkIHJldHVyblxuICAgICAgICAgICAgICAgIC8vIHZhbHVlLlxuICAgICAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgICAgICAgICAgc2tpcCArPSA0O1xuICAgICAgICAgICAgICAgIHNpemUgKz0gNDtcbiAgICAgICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdGFydFBvcyA9IGZvcmsucG9zIC0gbm9kZVNpemU7XG4gICAgICAgICAgICBpZiAobm9kZVNpemUgPCAwIHx8IHN0YXJ0UG9zIDwgbWluUG9zIHx8IGZvcmsuc3RhcnQgPCBtaW5TdGFydClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBsb2NhbFNraXBwZWQgPSBmb3JrLmlkID49IG1pblJlcGVhdFR5cGUgPyA0IDogMDtcbiAgICAgICAgICAgIGxldCBub2RlU3RhcnQgPSBmb3JrLnN0YXJ0O1xuICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoZm9yay5wb3MgPiBzdGFydFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTa2lwcGVkICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcmsuaWQgPj0gbWluUmVwZWF0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFNraXBwZWQgKz0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCA9IG5vZGVTdGFydDtcbiAgICAgICAgICAgIHNpemUgKz0gbm9kZVNpemU7XG4gICAgICAgICAgICBza2lwICs9IGxvY2FsU2tpcHBlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5SZXBlYXQgPCAwIHx8IHNpemUgPT0gbWF4U2l6ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zaXplID4gNCA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weVRvQnVmZmVyKGJ1ZmZlclN0YXJ0LCBidWZmZXIsIGluZGV4KSB7XG4gICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgIGlmIChzaXplID49IDAgJiYgaWQgPCBtaW5SZXBlYXRUeXBlKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgaWYgKHNpemUgPiA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSAoc2l6ZSAtIDQpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydEluZGV4O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gZW5kIC0gYnVmZmVyU3RhcnQ7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtMyAvKiBTcGVjaWFsUmVjb3JkLkNvbnRleHRDaGFuZ2UgKi8pIHtcbiAgICAgICAgICAgIGNvbnRleHRIYXNoID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtNCAvKiBTcGVjaWFsUmVjb3JkLkxvb2tBaGVhZCAqLykge1xuICAgICAgICAgICAgbG9va0FoZWFkID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICBsZXQgY2hpbGRyZW4gPSBbXSwgcG9zaXRpb25zID0gW107XG4gICAgd2hpbGUgKGN1cnNvci5wb3MgPiAwKVxuICAgICAgICB0YWtlTm9kZShkYXRhLnN0YXJ0IHx8IDAsIGRhdGEuYnVmZmVyU3RhcnQgfHwgMCwgY2hpbGRyZW4sIHBvc2l0aW9ucywgLTEpO1xuICAgIGxldCBsZW5ndGggPSAoX2EgPSBkYXRhLmxlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGNoaWxkcmVuLmxlbmd0aCA/IHBvc2l0aW9uc1swXSArIGNoaWxkcmVuWzBdLmxlbmd0aCA6IDApO1xuICAgIHJldHVybiBuZXcgVHJlZSh0eXBlc1tkYXRhLnRvcElEXSwgY2hpbGRyZW4ucmV2ZXJzZSgpLCBwb3NpdGlvbnMucmV2ZXJzZSgpLCBsZW5ndGgpO1xufVxuY29uc3Qgbm9kZVNpemVDYWNoZSA9IG5ldyBXZWFrTWFwO1xuZnVuY3Rpb24gbm9kZVNpemUoYmFsYW5jZVR5cGUsIG5vZGUpIHtcbiAgICBpZiAoIWJhbGFuY2VUeXBlLmlzQW5vbnltb3VzIHx8IG5vZGUgaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8IG5vZGUudHlwZSAhPSBiYWxhbmNlVHlwZSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgbGV0IHNpemUgPSBub2RlU2l6ZUNhY2hlLmdldChub2RlKTtcbiAgICBpZiAoc2l6ZSA9PSBudWxsKSB7XG4gICAgICAgIHNpemUgPSAxO1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPSBiYWxhbmNlVHlwZSB8fCAhKGNoaWxkIGluc3RhbmNlb2YgVHJlZSkpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpemUgKz0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlU2l6ZUNhY2hlLnNldChub2RlLCBzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59XG5mdW5jdGlvbiBiYWxhbmNlUmFuZ2UoXG4vLyBUaGUgdHlwZSB0aGUgYmFsYW5jZWQgdHJlZSdzIGlubmVyIG5vZGVzLlxuYmFsYW5jZVR5cGUsIFxuLy8gVGhlIGRpcmVjdCBjaGlsZHJlbiBhbmQgdGhlaXIgcG9zaXRpb25zXG5jaGlsZHJlbiwgcG9zaXRpb25zLCBcbi8vIFRoZSBpbmRleCByYW5nZSBpbiBjaGlsZHJlbi9wb3NpdGlvbnMgdG8gdXNlXG5mcm9tLCB0bywgXG4vLyBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIG5vZGVzLCByZWxhdGl2ZSB0byB0aGVpciBwYXJlbnQuXG5zdGFydCwgXG4vLyBMZW5ndGggb2YgdGhlIG91dGVyIG5vZGVcbmxlbmd0aCwgXG4vLyBGdW5jdGlvbiB0byBidWlsZCB0aGUgdG9wIG5vZGUgb2YgdGhlIGJhbGFuY2VkIHRyZWVcbm1rVG9wLCBcbi8vIEZ1bmN0aW9uIHRvIGJ1aWxkIGludGVybmFsIG5vZGVzIGZvciB0aGUgYmFsYW5jZWQgdHJlZVxubWtUcmVlKSB7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspXG4gICAgICAgIHRvdGFsICs9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgbGV0IG1heENoaWxkID0gTWF0aC5jZWlsKCh0b3RhbCAqIDEuNSkgLyA4IC8qIEJhbGFuY2UuQnJhbmNoRmFjdG9yICovKTtcbiAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgIGZ1bmN0aW9uIGRpdmlkZShjaGlsZHJlbiwgcG9zaXRpb25zLCBmcm9tLCB0bywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBGcm9tID0gaSwgZ3JvdXBTdGFydCA9IHBvc2l0aW9uc1tpXSwgZ3JvdXBTaXplID0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGZvciAoOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0U2l6ZSA9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwU2l6ZSArIG5leHRTaXplID49IG1heENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBncm91cFNpemUgKz0gbmV4dFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PSBncm91cEZyb20gKyAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwU2l6ZSA+IG1heENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvbmx5ID0gY2hpbGRyZW5bZ3JvdXBGcm9tXTsgLy8gT25seSB0cmVlcyBjYW4gaGF2ZSBhIHNpemUgPiAxXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZShvbmx5LmNoaWxkcmVuLCBvbmx5LnBvc2l0aW9ucywgMCwgb25seS5jaGlsZHJlbi5sZW5ndGgsIHBvc2l0aW9uc1tncm91cEZyb21dICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbltncm91cEZyb21dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSBwb3NpdGlvbnNbaSAtIDFdICsgY2hpbGRyZW5baSAtIDFdLmxlbmd0aCAtIGdyb3VwU3RhcnQ7XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGJhbGFuY2VSYW5nZShiYWxhbmNlVHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgZ3JvdXBGcm9tLCBpLCBncm91cFN0YXJ0LCBsZW5ndGgsIG51bGwsIG1rVHJlZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChncm91cFN0YXJ0ICsgb2Zmc2V0IC0gc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpdmlkZShjaGlsZHJlbiwgcG9zaXRpb25zLCBmcm9tLCB0bywgMCk7XG4gICAgcmV0dXJuIChta1RvcCB8fCBta1RyZWUpKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBsZW5ndGgpO1xufVxuLy8vIFByb3ZpZGVzIGEgd2F5IHRvIGFzc29jaWF0ZSB2YWx1ZXMgd2l0aCBwaWVjZXMgb2YgdHJlZXMuIEFzIGxvbmdcbi8vLyBhcyB0aGF0IHBhcnQgb2YgdGhlIHRyZWUgaXMgcmV1c2VkLCB0aGUgYXNzb2NpYXRlZCB2YWx1ZXMgY2FuIGJlXG4vLy8gcmV0cmlldmVkIGZyb20gYW4gdXBkYXRlZCB0cmVlLlxuY2xhc3MgTm9kZVdlYWtNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgfVxuICAgIHNldEJ1ZmZlcihidWZmZXIsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLm1hcC5nZXQoYnVmZmVyKTtcbiAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChidWZmZXIsIGlubmVyID0gbmV3IE1hcCk7XG4gICAgICAgIGlubmVyLnNldChpbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgICBnZXRCdWZmZXIoYnVmZmVyLCBpbmRleCkge1xuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLm1hcC5nZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIGlubmVyICYmIGlubmVyLmdldChpbmRleCk7XG4gICAgfVxuICAgIC8vLyBTZXQgdGhlIHZhbHVlIGZvciB0aGlzIHN5bnRheCBub2RlLlxuICAgIHNldChub2RlLCB2YWx1ZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEJ1ZmZlck5vZGUpXG4gICAgICAgICAgICB0aGlzLnNldEJ1ZmZlcihub2RlLmNvbnRleHQuYnVmZmVyLCBub2RlLmluZGV4LCB2YWx1ZSk7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSlcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChub2RlLnRyZWUsIHZhbHVlKTtcbiAgICB9XG4gICAgLy8vIFJldHJpZXZlIHZhbHVlIGZvciB0aGlzIHN5bnRheCBub2RlLCBpZiBpdCBleGlzdHMgaW4gdGhlIG1hcC5cbiAgICBnZXQobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEJ1ZmZlck5vZGUgPyB0aGlzLmdldEJ1ZmZlcihub2RlLmNvbnRleHQuYnVmZmVyLCBub2RlLmluZGV4KVxuICAgICAgICAgICAgOiBub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUgPyB0aGlzLm1hcC5nZXQobm9kZS50cmVlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8vIFNldCB0aGUgdmFsdWUgZm9yIHRoZSBub2RlIHRoYXQgYSBjdXJzb3IgY3VycmVudGx5IHBvaW50cyB0by5cbiAgICBjdXJzb3JTZXQoY3Vyc29yLCB2YWx1ZSkge1xuICAgICAgICBpZiAoY3Vyc29yLmJ1ZmZlcilcbiAgICAgICAgICAgIHRoaXMuc2V0QnVmZmVyKGN1cnNvci5idWZmZXIuYnVmZmVyLCBjdXJzb3IuaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KGN1cnNvci50cmVlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vLyBSZXRyaWV2ZSB0aGUgdmFsdWUgZm9yIHRoZSBub2RlIHRoYXQgYSBjdXJzb3IgY3VycmVudGx5IHBvaW50c1xuICAgIC8vLyB0by5cbiAgICBjdXJzb3JHZXQoY3Vyc29yKSB7XG4gICAgICAgIHJldHVybiBjdXJzb3IuYnVmZmVyID8gdGhpcy5nZXRCdWZmZXIoY3Vyc29yLmJ1ZmZlci5idWZmZXIsIGN1cnNvci5pbmRleCkgOiB0aGlzLm1hcC5nZXQoY3Vyc29yLnRyZWUpO1xuICAgIH1cbn1cblxuLy8vIFRyZWUgZnJhZ21lbnRzIGFyZSB1c2VkIGR1cmluZyBbaW5jcmVtZW50YWxcbi8vLyBwYXJzaW5nXSgjY29tbW9uLlBhcnNlci5zdGFydFBhcnNlKSB0byB0cmFjayBwYXJ0cyBvZiBvbGQgdHJlZXNcbi8vLyB0aGF0IGNhbiBiZSByZXVzZWQgaW4gYSBuZXcgcGFyc2UuIEFuIGFycmF5IG9mIGZyYWdtZW50cyBpcyB1c2VkXG4vLy8gdG8gdHJhY2sgcmVnaW9ucyBvZiBhbiBvbGQgdHJlZSB3aG9zZSBub2RlcyBtaWdodCBiZSByZXVzZWQgaW4gbmV3XG4vLy8gcGFyc2VzLiBVc2UgdGhlIHN0YXRpY1xuLy8vIFtgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBtZXRob2QgdG9cbi8vLyB1cGRhdGUgZnJhZ21lbnRzIGZvciBkb2N1bWVudCBjaGFuZ2VzLlxuY2xhc3MgVHJlZUZyYWdtZW50IHtcbiAgICAvLy8gQ29uc3RydWN0IGEgdHJlZSBmcmFnbWVudC4gWW91J2xsIHVzdWFsbHkgd2FudCB0byB1c2VcbiAgICAvLy8gW2BhZGRUcmVlYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYWRkVHJlZSkgYW5kXG4gICAgLy8vIFtgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBpbnN0ZWFkIG9mXG4gICAgLy8vIGNhbGxpbmcgdGhpcyBkaXJlY3RseS5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHN0YXJ0IG9mIHRoZSB1bmNoYW5nZWQgcmFuZ2UgcG9pbnRlZCB0byBieSB0aGlzIGZyYWdtZW50LlxuICAgIC8vLyBUaGlzIHJlZmVycyB0byBhbiBvZmZzZXQgaW4gdGhlIF91cGRhdGVkXyBkb2N1bWVudCAoYXMgb3Bwb3NlZFxuICAgIC8vLyB0byB0aGUgb3JpZ2luYWwgdHJlZSkuXG4gICAgZnJvbSwgXG4gICAgLy8vIFRoZSBlbmQgb2YgdGhlIHVuY2hhbmdlZCByYW5nZS5cbiAgICB0bywgXG4gICAgLy8vIFRoZSB0cmVlIHRoYXQgdGhpcyBmcmFnbWVudCBpcyBiYXNlZCBvbi5cbiAgICB0cmVlLCBcbiAgICAvLy8gVGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBmcmFnbWVudCdzIHRyZWUgYW5kIHRoZSBkb2N1bWVudCB0aGF0XG4gICAgLy8vIHRoaXMgZnJhZ21lbnQgY2FuIGJlIHVzZWQgYWdhaW5zdC4gQWRkIHRoaXMgd2hlbiBnb2luZyBmcm9tXG4gICAgLy8vIGRvY3VtZW50IHRvIHRyZWUgcG9zaXRpb25zLCBzdWJ0cmFjdCBpdCB0byBnbyBmcm9tIHRyZWUgdG9cbiAgICAvLy8gZG9jdW1lbnQgcG9zaXRpb25zLlxuICAgIG9mZnNldCwgb3BlblN0YXJ0ID0gZmFsc2UsIG9wZW5FbmQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLm9wZW4gPSAob3BlblN0YXJ0ID8gMSAvKiBPcGVuLlN0YXJ0ICovIDogMCkgfCAob3BlbkVuZCA/IDIgLyogT3Blbi5FbmQgKi8gOiAwKTtcbiAgICB9XG4gICAgLy8vIFdoZXRoZXIgdGhlIHN0YXJ0IG9mIHRoZSBmcmFnbWVudCByZXByZXNlbnRzIHRoZSBzdGFydCBvZiBhXG4gICAgLy8vIHBhcnNlLCBvciB0aGUgZW5kIG9mIGEgY2hhbmdlLiAoSW4gdGhlIHNlY29uZCBjYXNlLCBpdCBtYXkgbm90XG4gICAgLy8vIGJlIHNhZmUgdG8gcmV1c2Ugc29tZSBub2RlcyBhdCB0aGUgc3RhcnQsIGRlcGVuZGluZyBvbiB0aGVcbiAgICAvLy8gcGFyc2luZyBhbGdvcml0aG0uKVxuICAgIGdldCBvcGVuU3RhcnQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMSAvKiBPcGVuLlN0YXJ0ICovKSA+IDA7IH1cbiAgICAvLy8gV2hldGhlciB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudCByZXByZXNlbnRzIHRoZSBlbmQgb2YgYVxuICAgIC8vLyBmdWxsLWRvY3VtZW50IHBhcnNlLCBvciB0aGUgc3RhcnQgb2YgYSBjaGFuZ2UuXG4gICAgZ2V0IG9wZW5FbmQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMiAvKiBPcGVuLkVuZCAqLykgPiAwOyB9XG4gICAgLy8vIENyZWF0ZSBhIHNldCBvZiBmcmFnbWVudHMgZnJvbSBhIGZyZXNobHkgcGFyc2VkIHRyZWUsIG9yIHVwZGF0ZVxuICAgIC8vLyBhbiBleGlzdGluZyBzZXQgb2YgZnJhZ21lbnRzIGJ5IHJlcGxhY2luZyB0aGUgb25lcyB0aGF0IG92ZXJsYXBcbiAgICAvLy8gd2l0aCBhIHRyZWUgd2l0aCBjb250ZW50IGZyb20gdGhlIG5ldyB0cmVlLiBXaGVuIGBwYXJ0aWFsYCBpc1xuICAgIC8vLyB0cnVlLCB0aGUgcGFyc2UgaXMgdHJlYXRlZCBhcyBpbmNvbXBsZXRlLCBhbmQgdGhlIHJlc3VsdGluZ1xuICAgIC8vLyBmcmFnbWVudCBoYXMgW2BvcGVuRW5kYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQub3BlbkVuZCkgc2V0IHRvXG4gICAgLy8vIHRydWUuXG4gICAgc3RhdGljIGFkZFRyZWUodHJlZSwgZnJhZ21lbnRzID0gW10sIHBhcnRpYWwgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW25ldyBUcmVlRnJhZ21lbnQoMCwgdHJlZS5sZW5ndGgsIHRyZWUsIDAsIGZhbHNlLCBwYXJ0aWFsKV07XG4gICAgICAgIGZvciAobGV0IGYgb2YgZnJhZ21lbnRzKVxuICAgICAgICAgICAgaWYgKGYudG8gPiB0cmVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8vIEFwcGx5IGEgc2V0IG9mIGVkaXRzIHRvIGFuIGFycmF5IG9mIGZyYWdtZW50cywgcmVtb3Zpbmcgb3JcbiAgICAvLy8gc3BsaXR0aW5nIGZyYWdtZW50cyBhcyBuZWNlc3NhcnkgdG8gcmVtb3ZlIGVkaXRlZCByYW5nZXMsIGFuZFxuICAgIC8vLyBhZGp1c3Rpbmcgb2Zmc2V0cyBmb3IgZnJhZ21lbnRzIHRoYXQgbW92ZWQuXG4gICAgc3RhdGljIGFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIGNoYW5nZXMsIG1pbkdhcCA9IDEyOCkge1xuICAgICAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50cztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgZkkgPSAxLCBuZXh0RiA9IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbMF0gOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBjSSA9IDAsIHBvcyA9IDAsIG9mZiA9IDA7OyBjSSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dEMgPSBjSSA8IGNoYW5nZXMubGVuZ3RoID8gY2hhbmdlc1tjSV0gOiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBuZXh0QyA/IG5leHRDLmZyb21BIDogMWU5O1xuICAgICAgICAgICAgaWYgKG5leHRQb3MgLSBwb3MgPj0gbWluR2FwKVxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0RiAmJiBuZXh0Ri5mcm9tIDwgbmV4dFBvcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3V0ID0gbmV4dEY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gY3V0LmZyb20gfHwgbmV4dFBvcyA8PSBjdXQudG8gfHwgb2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZkZyb20gPSBNYXRoLm1heChjdXQuZnJvbSwgcG9zKSAtIG9mZiwgZlRvID0gTWF0aC5taW4oY3V0LnRvLCBuZXh0UG9zKSAtIG9mZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1dCA9IGZGcm9tID49IGZUbyA/IG51bGwgOiBuZXcgVHJlZUZyYWdtZW50KGZGcm9tLCBmVG8sIGN1dC50cmVlLCBjdXQub2Zmc2V0ICsgb2ZmLCBjSSA+IDAsICEhbmV4dEMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEYudG8gPiBuZXh0UG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIG5leHRGID0gZkkgPCBmcmFnbWVudHMubGVuZ3RoID8gZnJhZ21lbnRzW2ZJKytdIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHRDKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gbmV4dEMudG9BO1xuICAgICAgICAgICAgb2ZmID0gbmV4dEMudG9BIC0gbmV4dEMudG9CO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8vIEEgc3VwZXJjbGFzcyB0aGF0IHBhcnNlcnMgc2hvdWxkIGV4dGVuZC5cbmNsYXNzIFBhcnNlciB7XG4gICAgLy8vIFN0YXJ0IGEgcGFyc2UsIHJldHVybmluZyBhIFtwYXJ0aWFsIHBhcnNlXSgjY29tbW9uLlBhcnRpYWxQYXJzZSlcbiAgICAvLy8gb2JqZWN0LiBbYGZyYWdtZW50c2BdKCNjb21tb24uVHJlZUZyYWdtZW50KSBjYW4gYmUgcGFzc2VkIGluIHRvXG4gICAgLy8vIG1ha2UgdGhlIHBhcnNlIGluY3JlbWVudGFsLlxuICAgIC8vL1xuICAgIC8vLyBCeSBkZWZhdWx0LCB0aGUgZW50aXJlIGlucHV0IGlzIHBhcnNlZC4gWW91IGNhbiBwYXNzIGByYW5nZXNgLFxuICAgIC8vLyB3aGljaCBzaG91bGQgYmUgYSBzb3J0ZWQgYXJyYXkgb2Ygbm9uLWVtcHR5LCBub24tb3ZlcmxhcHBpbmdcbiAgICAvLy8gcmFuZ2VzLCB0byBwYXJzZSBvbmx5IHRob3NlIHJhbmdlcy4gVGhlIHRyZWUgcmV0dXJuZWQgaW4gdGhhdFxuICAgIC8vLyBjYXNlIHdpbGwgc3RhcnQgYXQgYHJhbmdlc1swXS5mcm9tYC5cbiAgICBzdGFydFBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBpbnB1dCA9IG5ldyBTdHJpbmdJbnB1dChpbnB1dCk7XG4gICAgICAgIHJhbmdlcyA9ICFyYW5nZXMgPyBbbmV3IFJhbmdlKDAsIGlucHV0Lmxlbmd0aCldIDogcmFuZ2VzLmxlbmd0aCA/IHJhbmdlcy5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tLCByLnRvKSkgOiBbbmV3IFJhbmdlKDAsIDApXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cyB8fCBbXSwgcmFuZ2VzKTtcbiAgICB9XG4gICAgLy8vIFJ1biBhIGZ1bGwgcGFyc2UsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIHRyZWUuXG4gICAgcGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IHRoaXMuc3RhcnRQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU3RyaW5nSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmxlbmd0aDsgfVxuICAgIGNodW5rKGZyb20pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20pOyB9XG4gICAgZ2V0IGxpbmVDaHVua3MoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20sIHRvKTsgfVxufVxuXG4vLy8gQ3JlYXRlIGEgcGFyc2Ugd3JhcHBlciB0aGF0LCBhZnRlciB0aGUgaW5uZXIgcGFyc2UgY29tcGxldGVzLFxuLy8vIHNjYW5zIGl0cyB0cmVlIGZvciBtaXhlZCBsYW5ndWFnZSByZWdpb25zIHdpdGggdGhlIGBuZXN0YFxuLy8vIGZ1bmN0aW9uLCBydW5zIHRoZSByZXN1bHRpbmcgW2lubmVyIHBhcnNlc10oI2NvbW1vbi5OZXN0ZWRQYXJzZSksXG4vLy8gYW5kIHRoZW4gW21vdW50c10oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSB0aGVpciByZXN1bHRzIG9udG8gdGhlXG4vLy8gdHJlZS5cbmZ1bmN0aW9uIHBhcnNlTWl4ZWQobmVzdCkge1xuICAgIHJldHVybiAocGFyc2UsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykgPT4gbmV3IE1peGVkUGFyc2UocGFyc2UsIG5lc3QsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG59XG5jbGFzcyBJbm5lclBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHBhcnNlLCBvdmVybGF5LCB0YXJnZXQsIHJhbmdlcykge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IHBhcnNlO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIGlmICghcmFuZ2VzLmxlbmd0aCB8fCByYW5nZXMuc29tZShyID0+IHIuZnJvbSA+PSByLnRvKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbm5lciBwYXJzZSByYW5nZXMgZ2l2ZW46IFwiICsgSlNPTi5zdHJpbmdpZnkocmFuZ2VzKSk7XG4gICAgfVxufVxuY2xhc3MgQWN0aXZlT3ZlcmxheSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwcmVkaWNhdGUsIG1vdW50cywgaW5kZXgsIHN0YXJ0LCB0YXJnZXQsIHByZXYpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLm1vdW50cyA9IG1vdW50cztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgICAgICB0aGlzLmRlcHRoID0gMDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICB9XG59XG5jb25zdCBzdG9wcGVkSW5uZXIgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuY2xhc3MgTWl4ZWRQYXJzZSB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgbmVzdCwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMubmVzdCA9IG5lc3Q7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLmlubmVyID0gW107XG4gICAgICAgIHRoaXMuaW5uZXJEb25lID0gMDtcbiAgICAgICAgdGhpcy5iYXNlVHJlZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBiYXNlO1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpIHtcbiAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5iYXNlUGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlVHJlZSA9IGRvbmU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0SW5uZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlubmVyIG9mIHRoaXMuaW5uZXIpXG4gICAgICAgICAgICAgICAgICAgIGlubmVyLnBhcnNlLnN0b3BBdCh0aGlzLnN0b3BwZWRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5uZXJEb25lID09IHRoaXMuaW5uZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5iYXNlVHJlZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUcmVlKHJlc3VsdC50eXBlLCByZXN1bHQuY2hpbGRyZW4sIHJlc3VsdC5wb3NpdGlvbnMsIHJlc3VsdC5sZW5ndGgsIHJlc3VsdC5wcm9wVmFsdWVzLmNvbmNhdChbW3N0b3BwZWRJbm5lciwgdGhpcy5zdG9wcGVkQXRdXSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLmlubmVyW3RoaXMuaW5uZXJEb25lXSwgZG9uZSA9IGlubmVyLnBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJEb25lKys7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgc29tZXdoYXQgZG9kZ3kgYnV0IHN1cGVyIGhlbHBmdWwgaGFjayB3aGVyZSB3ZVxuICAgICAgICAgICAgLy8gcGF0Y2ggdXAgbm9kZXMgY3JlYXRlZCBieSB0aGUgaW5uZXIgcGFyc2UgKGFuZCB0aHVzXG4gICAgICAgICAgICAvLyBwcmVzdW1hYmx5IG5vdCBhbGlhc2VkIGFueXdoZXJlIGVsc2UpIHRvIGhvbGQgdGhlIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAvLyBhYm91dCB0aGUgaW5uZXIgcGFyc2UuXG4gICAgICAgICAgICBsZXQgcHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGlubmVyLnRhcmdldC5wcm9wcyk7XG4gICAgICAgICAgICBwcm9wc1tOb2RlUHJvcC5tb3VudGVkLmlkXSA9IG5ldyBNb3VudGVkVHJlZShkb25lLCBpbm5lci5vdmVybGF5LCBpbm5lci5wYXJzZXIpO1xuICAgICAgICAgICAgaW5uZXIudGFyZ2V0LnByb3BzID0gcHJvcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBwYXJzZWRQb3MoKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5pbnB1dC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmlubmVyRG9uZTsgaSA8IHRoaXMuaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlubmVyW2ldLnJhbmdlc1swXS5mcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgIHBvcyA9IE1hdGgubWluKHBvcywgdGhpcy5pbm5lcltpXS5wYXJzZS5wYXJzZWRQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlLnN0b3BBdChwb3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJbaV0ucGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgfVxuICAgIHN0YXJ0SW5uZXIoKSB7XG4gICAgICAgIGxldCBmcmFnbWVudEN1cnNvciA9IG5ldyBGcmFnbWVudEN1cnNvcih0aGlzLmZyYWdtZW50cyk7XG4gICAgICAgIGxldCBvdmVybGF5ID0gbnVsbDtcbiAgICAgICAgbGV0IGNvdmVyZWQgPSBudWxsO1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFRyZWVDdXJzb3IobmV3IFRyZWVOb2RlKHRoaXMuYmFzZVRyZWUsIHRoaXMucmFuZ2VzWzBdLmZyb20sIDAsIG51bGwpLCBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzIHwgSXRlck1vZGUuSWdub3JlTW91bnRzKTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbmVzdCwgaXNDb3ZlcmVkOyB0aGlzLnN0b3BwZWRBdCA9PSBudWxsIHx8IGN1cnNvci5mcm9tIDwgdGhpcy5zdG9wcGVkQXQ7KSB7XG4gICAgICAgICAgICBsZXQgZW50ZXIgPSB0cnVlLCByYW5nZTtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudEN1cnNvci5oYXNOb2RlKGN1cnNvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSBvdmVybGF5Lm1vdW50cy5maW5kKG0gPT4gbS5mcmFnLmZyb20gPD0gY3Vyc29yLmZyb20gJiYgbS5mcmFnLnRvID49IGN1cnNvci50byAmJiBtLm1vdW50Lm92ZXJsYXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG1hdGNoLm1vdW50Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHIuZnJvbSArIG1hdGNoLnBvcywgdG8gPSByLnRvICsgbWF0Y2gucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tID49IGN1cnNvci5mcm9tICYmIHRvIDw9IGN1cnNvci50byAmJiAhb3ZlcmxheS5yYW5nZXMuc29tZShyID0+IHIuZnJvbSA8IHRvICYmIHIudG8gPiBmcm9tKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY292ZXJlZCAmJiAoaXNDb3ZlcmVkID0gY2hlY2tDb3Zlcihjb3ZlcmVkLnJhbmdlcywgY3Vyc29yLmZyb20sIGN1cnNvci50bykpKSB7XG4gICAgICAgICAgICAgICAgZW50ZXIgPSBpc0NvdmVyZWQgIT0gMiAvKiBDb3Zlci5GdWxsICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnNvci50eXBlLmlzQW5vbnltb3VzICYmIGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvICYmIChuZXN0ID0gdGhpcy5uZXN0KGN1cnNvciwgdGhpcy5pbnB1dCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxpemUoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICBsZXQgb2xkTW91bnRzID0gZnJhZ21lbnRDdXJzb3IuZmluZE1vdW50cyhjdXJzb3IuZnJvbSwgbmVzdC5wYXJzZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmVzdC5vdmVybGF5ID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBvdmVybGF5ID0gbmV3IEFjdGl2ZU92ZXJsYXkobmVzdC5wYXJzZXIsIG5lc3Qub3ZlcmxheSwgb2xkTW91bnRzLCB0aGlzLmlubmVyLmxlbmd0aCwgY3Vyc29yLmZyb20sIGN1cnNvci50cmVlLCBvdmVybGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBwdW5jaFJhbmdlcyh0aGlzLnJhbmdlcywgbmVzdC5vdmVybGF5IHx8IFtuZXcgUmFuZ2UoY3Vyc29yLmZyb20sIGN1cnNvci50byldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyLnB1c2gobmV3IElubmVyUGFyc2UobmVzdC5wYXJzZXIsIG5lc3QucGFyc2VyLnN0YXJ0UGFyc2UodGhpcy5pbnB1dCwgZW50ZXJGcmFnbWVudHMob2xkTW91bnRzLCByYW5nZXMpLCByYW5nZXMpLCBuZXN0Lm92ZXJsYXkgPyBuZXN0Lm92ZXJsYXkubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSAtIGN1cnNvci5mcm9tLCByLnRvIC0gY3Vyc29yLmZyb20pKSA6IG51bGwsIGN1cnNvci50cmVlLCByYW5nZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXN0Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY292ZXJlZCA9IHsgcmFuZ2VzLCBkZXB0aDogMCwgcHJldjogY292ZXJlZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG92ZXJsYXkgJiYgKHJhbmdlID0gb3ZlcmxheS5wcmVkaWNhdGUoY3Vyc29yKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKGN1cnNvci5mcm9tLCBjdXJzb3IudG8pO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tIDwgcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkucmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGVyICYmIGN1cnNvci5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5kZXB0aCsrO1xuICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkKVxuICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkLmRlcHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnNvci5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGF5ICYmICEtLW92ZXJsYXkuZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBwdW5jaFJhbmdlcyh0aGlzLnJhbmdlcywgb3ZlcmxheS5yYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbm5lci5zcGxpY2Uob3ZlcmxheS5pbmRleCwgMCwgbmV3IElubmVyUGFyc2Uob3ZlcmxheS5wYXJzZXIsIG92ZXJsYXkucGFyc2VyLnN0YXJ0UGFyc2UodGhpcy5pbnB1dCwgZW50ZXJGcmFnbWVudHMob3ZlcmxheS5tb3VudHMsIHJhbmdlcyksIHJhbmdlcyksIG92ZXJsYXkucmFuZ2VzLm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gLSBvdmVybGF5LnN0YXJ0LCByLnRvIC0gb3ZlcmxheS5zdGFydCkpLCBvdmVybGF5LnRhcmdldCwgcmFuZ2VzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5ID0gb3ZlcmxheS5wcmV2O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkICYmICEtLWNvdmVyZWQuZGVwdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkID0gY292ZXJlZC5wcmV2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQ292ZXIoY292ZXJlZCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBjb3ZlcmVkKSB7XG4gICAgICAgIGlmIChyYW5nZS5mcm9tID49IHRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChyYW5nZS50byA+IGZyb20pXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2UuZnJvbSA8PSBmcm9tICYmIHJhbmdlLnRvID49IHRvID8gMiAvKiBDb3Zlci5GdWxsICovIDogMSAvKiBDb3Zlci5QYXJ0aWFsICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBDb3Zlci5Ob25lICovO1xufVxuLy8gVGFrZSBhIHBpZWNlIG9mIGJ1ZmZlciBhbmQgY29udmVydCBpdCBpbnRvIGEgc3RhbmQtYWxvbmVcbi8vIFRyZWVCdWZmZXIuXG5mdW5jdGlvbiBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgZW5kSSwgbm9kZXMsIHBvc2l0aW9ucywgb2ZmKSB7XG4gICAgaWYgKHN0YXJ0SSA8IGVuZEkpIHtcbiAgICAgICAgbGV0IGZyb20gPSBidWYuYnVmZmVyW3N0YXJ0SSArIDFdO1xuICAgICAgICBub2Rlcy5wdXNoKGJ1Zi5zbGljZShzdGFydEksIGVuZEksIGZyb20pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIG9mZik7XG4gICAgfVxufVxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIG5vZGUgdGhhdCdzIGluIGEgYnVmZmVyLCBhbmQgY29udmVydHMgaXQsIGFuZFxuLy8gaXRzIHBhcmVudCBidWZmZXIgbm9kZXMsIGludG8gYSBUcmVlLiBUaGlzIGlzIGFnYWluIGFjdGluZyBvbiB0aGVcbi8vIGFzc3VtcHRpb24gdGhhdCB0aGUgdHJlZXMgYW5kIGJ1ZmZlcnMgaGF2ZSBiZWVuIGNvbnN0cnVjdGVkIGJ5IHRoZVxuLy8gcGFyc2UgdGhhdCB3YXMgcmFuIHZpYSB0aGUgbWl4IHBhcnNlciwgYW5kIHRodXMgYXJlbid0IHNoYXJlZCB3aXRoXG4vLyBhbnkgb3RoZXIgY29kZSwgbWFraW5nIHZpb2xhdGlvbnMgb2YgdGhlIGltbXV0YWJpbGl0eSBzYWZlLlxuZnVuY3Rpb24gbWF0ZXJpYWxpemUoY3Vyc29yKSB7XG4gICAgbGV0IHsgbm9kZSB9ID0gY3Vyc29yLCBkZXB0aCA9IDA7XG4gICAgLy8gU2NhbiB1cCB0byB0aGUgbmVhcmVzdCB0cmVlXG4gICAgZG8ge1xuICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgICAgIGRlcHRoKys7XG4gICAgfSB3aGlsZSAoIWN1cnNvci50cmVlKTtcbiAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgYnVmZmVyIGluIHRoYXQgdHJlZVxuICAgIGxldCBpID0gMCwgYmFzZSA9IGN1cnNvci50cmVlLCBvZmYgPSAwO1xuICAgIGZvciAoOzsgaSsrKSB7XG4gICAgICAgIG9mZiA9IGJhc2UucG9zaXRpb25zW2ldICsgY3Vyc29yLmZyb207XG4gICAgICAgIGlmIChvZmYgPD0gbm9kZS5mcm9tICYmIG9mZiArIGJhc2UuY2hpbGRyZW5baV0ubGVuZ3RoID49IG5vZGUudG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IGJ1ZiA9IGJhc2UuY2hpbGRyZW5baV0sIGIgPSBidWYuYnVmZmVyO1xuICAgIC8vIFNwbGl0IGEgbGV2ZWwgaW4gdGhlIGJ1ZmZlciwgcHV0dGluZyB0aGUgbm9kZXMgYmVmb3JlIGFuZCBhZnRlclxuICAgIC8vIHRoZSBjaGlsZCB0aGF0IGNvbnRhaW5zIGBub2RlYCBpbnRvIG5ldyBidWZmZXJzLlxuICAgIGZ1bmN0aW9uIHNwbGl0KHN0YXJ0SSwgZW5kSSwgdHlwZSwgaW5uZXJPZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICBsZXQgaSA9IHN0YXJ0STtcbiAgICAgICAgd2hpbGUgKGJbaSArIDJdICsgb2ZmIDw9IG5vZGUuZnJvbSlcbiAgICAgICAgICAgIGkgPSBiW2kgKyAzXTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgaSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5uZXJPZmZzZXQpO1xuICAgICAgICBsZXQgZnJvbSA9IGJbaSArIDFdLCB0byA9IGJbaSArIDJdO1xuICAgICAgICBsZXQgaXNUYXJnZXQgPSBmcm9tICsgb2ZmID09IG5vZGUuZnJvbSAmJiB0byArIG9mZiA9PSBub2RlLnRvICYmIGJbaV0gPT0gbm9kZS50eXBlLmlkO1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGlzVGFyZ2V0ID8gbm9kZS50b1RyZWUoKSA6IHNwbGl0KGkgKyA0LCBiW2kgKyAzXSwgYnVmLnNldC50eXBlc1tiW2ldXSwgZnJvbSwgdG8gLSBmcm9tKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBpbm5lck9mZnNldCk7XG4gICAgICAgIHNsaWNlQnVmKGJ1ZiwgYltpICsgM10sIGVuZEksIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCk7XG4gICAgfVxuICAgIGJhc2UuY2hpbGRyZW5baV0gPSBzcGxpdCgwLCBiLmxlbmd0aCwgTm9kZVR5cGUubm9uZSwgMCwgYnVmLmxlbmd0aCk7XG4gICAgLy8gTW92ZSB0aGUgY3Vyc29yIGJhY2sgdG8gdGhlIHRhcmdldCBub2RlXG4gICAgZm9yIChsZXQgZCA9IDA7IGQgPD0gZGVwdGg7IGQrKylcbiAgICAgICAgY3Vyc29yLmNoaWxkQWZ0ZXIobm9kZS5mcm9tKTtcbn1cbmNsYXNzIFN0cnVjdHVyZUN1cnNvciB7XG4gICAgY29uc3RydWN0b3Iocm9vdCwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSByb290LmN1cnNvcihJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzIHwgSXRlck1vZGUuSWdub3JlTW91bnRzKTtcbiAgICB9XG4gICAgLy8gTW92ZSB0byB0aGUgZmlyc3Qgbm9kZSAoaW4gcHJlLW9yZGVyKSB0aGF0IHN0YXJ0cyBhdCBvciBhZnRlciBgcG9zYC5cbiAgICBtb3ZlVG8ocG9zKSB7XG4gICAgICAgIGxldCB7IGN1cnNvciB9ID0gdGhpcywgcCA9IHBvcyAtIHRoaXMub2Zmc2V0O1xuICAgICAgICB3aGlsZSAoIXRoaXMuZG9uZSAmJiBjdXJzb3IuZnJvbSA8IHApIHtcbiAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPj0gcG9zICYmIGN1cnNvci5lbnRlcihwLCAxLCBJdGVyTW9kZS5JZ25vcmVPdmVybGF5cyB8IEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzKSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnNvci5uZXh0KGZhbHNlKSlcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc05vZGUoY3Vyc29yKSB7XG4gICAgICAgIHRoaXMubW92ZVRvKGN1cnNvci5mcm9tKTtcbiAgICAgICAgaWYgKCF0aGlzLmRvbmUgJiYgdGhpcy5jdXJzb3IuZnJvbSArIHRoaXMub2Zmc2V0ID09IGN1cnNvci5mcm9tICYmIHRoaXMuY3Vyc29yLnRyZWUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHRyZWUgPSB0aGlzLmN1cnNvci50cmVlOzspIHtcbiAgICAgICAgICAgICAgICBpZiAodHJlZSA9PSBjdXJzb3IudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWUuY2hpbGRyZW4ubGVuZ3RoICYmIHRyZWUucG9zaXRpb25zWzBdID09IDAgJiYgdHJlZS5jaGlsZHJlblswXSBpbnN0YW5jZW9mIFRyZWUpXG4gICAgICAgICAgICAgICAgICAgIHRyZWUgPSB0cmVlLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNsYXNzIEZyYWdtZW50Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5jdXJUbyA9IDA7XG4gICAgICAgIHRoaXMuZnJhZ0kgPSAwO1xuICAgICAgICBpZiAoZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gdGhpcy5jdXJGcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5jdXJUbyA9IChfYSA9IGZpcnN0LnRyZWUucHJvcChzdG9wcGVkSW5uZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaXJzdC50bztcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBuZXcgU3RydWN0dXJlQ3Vyc29yKGZpcnN0LnRyZWUsIC1maXJzdC5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJGcmFnID0gdGhpcy5pbm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzTm9kZShub2RlKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmN1ckZyYWcgJiYgbm9kZS5mcm9tID49IHRoaXMuY3VyVG8pXG4gICAgICAgICAgICB0aGlzLm5leHRGcmFnKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmN1ckZyYWcgJiYgdGhpcy5jdXJGcmFnLmZyb20gPD0gbm9kZS5mcm9tICYmIHRoaXMuY3VyVG8gPj0gbm9kZS50byAmJiB0aGlzLmlubmVyLmhhc05vZGUobm9kZSk7XG4gICAgfVxuICAgIG5leHRGcmFnKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZnJhZ0krKztcbiAgICAgICAgaWYgKHRoaXMuZnJhZ0kgPT0gdGhpcy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmN1ckZyYWcgPSB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmcmFnID0gdGhpcy5jdXJGcmFnID0gdGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnSV07XG4gICAgICAgICAgICB0aGlzLmN1clRvID0gKF9hID0gZnJhZy50cmVlLnByb3Aoc3RvcHBlZElubmVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZnJhZy50bztcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBuZXcgU3RydWN0dXJlQ3Vyc29yKGZyYWcudHJlZSwgLWZyYWcub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kTW91bnRzKHBvcywgcGFyc2VyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5pbm5lcikge1xuICAgICAgICAgICAgdGhpcy5pbm5lci5jdXJzb3IubW92ZVRvKHBvcywgMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBwb3MgPSB0aGlzLmlubmVyLmN1cnNvci5ub2RlOyBwb3M7IHBvcyA9IHBvcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbW91bnQgPSAoX2EgPSBwb3MudHJlZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgICAgICAgICAgaWYgKG1vdW50ICYmIG1vdW50LnBhcnNlciA9PSBwYXJzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZnJhZ0k7IGkgPCB0aGlzLmZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyYWcgPSB0aGlzLmZyYWdtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLmZyb20gPj0gcG9zLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcudHJlZSA9PSB0aGlzLmN1ckZyYWcudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogcG9zLmZyb20gLSBmcmFnLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91bnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHB1bmNoUmFuZ2VzKG91dGVyLCByYW5nZXMpIHtcbiAgICBsZXQgY29weSA9IG51bGwsIGN1cnJlbnQgPSByYW5nZXM7XG4gICAgZm9yIChsZXQgaSA9IDEsIGogPSAwOyBpIDwgb3V0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGdhcEZyb20gPSBvdXRlcltpIC0gMV0udG8sIGdhcFRvID0gb3V0ZXJbaV0uZnJvbTtcbiAgICAgICAgZm9yICg7IGogPCBjdXJyZW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgciA9IGN1cnJlbnRbal07XG4gICAgICAgICAgICBpZiAoci5mcm9tID49IGdhcFRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHIudG8gPD0gZ2FwRnJvbSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY29weSA9IHJhbmdlcy5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKHIuZnJvbSA8IGdhcEZyb20pIHtcbiAgICAgICAgICAgICAgICBjb3B5W2pdID0gbmV3IFJhbmdlKHIuZnJvbSwgZ2FwRnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKHIudG8gPiBnYXBUbylcbiAgICAgICAgICAgICAgICAgICAgY29weS5zcGxpY2UoaiArIDEsIDAsIG5ldyBSYW5nZShnYXBUbywgci50bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoci50byA+IGdhcFRvKSB7XG4gICAgICAgICAgICAgICAgY29weVtqLS1dID0gbmV3IFJhbmdlKGdhcFRvLCByLnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcHkuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiBmaW5kQ292ZXJDaGFuZ2VzKGEsIGIsIGZyb20sIHRvKSB7XG4gICAgbGV0IGlBID0gMCwgaUIgPSAwLCBpbkEgPSBmYWxzZSwgaW5CID0gZmFsc2UsIHBvcyA9IC0xZTk7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IG5leHRBID0gaUEgPT0gYS5sZW5ndGggPyAxZTkgOiBpbkEgPyBhW2lBXS50byA6IGFbaUFdLmZyb207XG4gICAgICAgIGxldCBuZXh0QiA9IGlCID09IGIubGVuZ3RoID8gMWU5IDogaW5CID8gYltpQl0udG8gOiBiW2lCXS5mcm9tO1xuICAgICAgICBpZiAoaW5BICE9IGluQikge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgocG9zLCBmcm9tKSwgZW5kID0gTWF0aC5taW4obmV4dEEsIG5leHRCLCB0byk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCBlbmQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFJhbmdlKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBNYXRoLm1pbihuZXh0QSwgbmV4dEIpO1xuICAgICAgICBpZiAocG9zID09IDFlOSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAobmV4dEEgPT0gcG9zKSB7XG4gICAgICAgICAgICBpZiAoIWluQSlcbiAgICAgICAgICAgICAgICBpbkEgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5BID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaUErKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dEIgPT0gcG9zKSB7XG4gICAgICAgICAgICBpZiAoIWluQilcbiAgICAgICAgICAgICAgICBpbkIgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5CID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaUIrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gR2l2ZW4gYSBudW1iZXIgb2YgZnJhZ21lbnRzIGZvciB0aGUgb3V0ZXIgdHJlZSwgYW5kIGEgc2V0IG9mIHJhbmdlc1xuLy8gdG8gcGFyc2UsIGZpbmQgZnJhZ21lbnRzIGZvciBpbm5lciB0cmVlcyBtb3VudGVkIGFyb3VuZCB0aG9zZVxuLy8gcmFuZ2VzLCBpZiBhbnkuXG5mdW5jdGlvbiBlbnRlckZyYWdtZW50cyhtb3VudHMsIHJhbmdlcykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCB7IHBvcywgbW91bnQsIGZyYWcgfSBvZiBtb3VudHMpIHtcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gcG9zICsgKG1vdW50Lm92ZXJsYXkgPyBtb3VudC5vdmVybGF5WzBdLmZyb20gOiAwKSwgZW5kUG9zID0gc3RhcnRQb3MgKyBtb3VudC50cmVlLmxlbmd0aDtcbiAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChmcmFnLmZyb20sIHN0YXJ0UG9zKSwgdG8gPSBNYXRoLm1pbihmcmFnLnRvLCBlbmRQb3MpO1xuICAgICAgICBpZiAobW91bnQub3ZlcmxheSkge1xuICAgICAgICAgICAgbGV0IG92ZXJsYXkgPSBtb3VudC5vdmVybGF5Lm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gKyBwb3MsIHIudG8gKyBwb3MpKTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VzID0gZmluZENvdmVyQ2hhbmdlcyhyYW5nZXMsIG92ZXJsYXksIGZyb20sIHRvKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBmcm9tOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBpID09IGNoYW5nZXMubGVuZ3RoLCBlbmQgPSBsYXN0ID8gdG8gOiBjaGFuZ2VzW2ldLmZyb207XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFRyZWVGcmFnbWVudChwb3MsIGVuZCwgbW91bnQudHJlZSwgLXN0YXJ0UG9zLCBmcmFnLmZyb20gPj0gcG9zIHx8IGZyYWcub3BlblN0YXJ0LCBmcmFnLnRvIDw9IGVuZCB8fCBmcmFnLm9wZW5FbmQpKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcG9zID0gY2hhbmdlc1tpXS50bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBUcmVlRnJhZ21lbnQoZnJvbSwgdG8sIG1vdW50LnRyZWUsIC1zdGFydFBvcywgZnJhZy5mcm9tID49IHN0YXJ0UG9zIHx8IGZyYWcub3BlblN0YXJ0LCBmcmFnLnRvIDw9IGVuZFBvcyB8fCBmcmFnLm9wZW5FbmQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBEZWZhdWx0QnVmZmVyTGVuZ3RoLCBJdGVyTW9kZSwgTW91bnRlZFRyZWUsIE5vZGVQcm9wLCBOb2RlU2V0LCBOb2RlVHlwZSwgTm9kZVdlYWtNYXAsIFBhcnNlciwgVHJlZSwgVHJlZUJ1ZmZlciwgVHJlZUN1cnNvciwgVHJlZUZyYWdtZW50LCBwYXJzZU1peGVkIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/common/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/highlight/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lezer/highlight/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tag: () => (/* binding */ Tag),\n/* harmony export */   classHighlighter: () => (/* binding */ classHighlighter),\n/* harmony export */   getStyleTags: () => (/* binding */ getStyleTags),\n/* harmony export */   highlightTree: () => (/* binding */ highlightTree),\n/* harmony export */   styleTags: () => (/* binding */ styleTags),\n/* harmony export */   tagHighlighter: () => (/* binding */ tagHighlighter),\n/* harmony export */   tags: () => (/* binding */ tags)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\n\nlet nextTagID = 0;\n/**\nHighlighting tags are markers that denote a highlighting category.\nThey are [associated](#highlight.styleTags) with parts of a syntax\ntree by a language mode, and then mapped to an actual CSS style by\na [highlighter](#highlight.Highlighter).\n\nBecause syntax tree node types and highlight styles have to be\nable to talk the same language, CodeMirror uses a mostly _closed_\n[vocabulary](#highlight.tags) of syntax tags (as opposed to\ntraditional open string-based systems, which make it hard for\nhighlighting themes to cover all the tokens produced by the\nvarious languages).\n\nIt _is_ possible to [define](#highlight.Tag^define) your own\nhighlighting tags for system-internal use (where you control both\nthe language package and the highlighter), but such tags will not\nbe picked up by regular highlighters (though you can derive them\nfrom standard tags to allow highlighters to fall back to those).\n*/\nclass Tag {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The set of this tag and all its parent tags, starting with\n    this one itself and sorted in order of decreasing specificity.\n    */\n    set, \n    /**\n    The base unmodified tag that this one is based on, if it's\n    modified @internal\n    */\n    base, \n    /**\n    The modifiers applied to this.base @internal\n    */\n    modified) {\n        this.set = set;\n        this.base = base;\n        this.modified = modified;\n        /**\n        @internal\n        */\n        this.id = nextTagID++;\n    }\n    /**\n    Define a new tag. If `parent` is given, the tag is treated as a\n    sub-tag of that parent, and\n    [highlighters](#highlight.tagHighlighter) that don't mention\n    this tag will try to fall back to the parent tag (or grandparent\n    tag, etc).\n    */\n    static define(parent) {\n        if (parent === null || parent === void 0 ? void 0 : parent.base)\n            throw new Error(\"Can not derive from a modified tag\");\n        let tag = new Tag([], null, []);\n        tag.set.push(tag);\n        if (parent)\n            for (let t of parent.set)\n                tag.set.push(t);\n        return tag;\n    }\n    /**\n    Define a tag _modifier_, which is a function that, given a tag,\n    will return a tag that is a subtag of the original. Applying the\n    same modifier to a twice tag will return the same value (`m1(t1)\n    == m1(t1)`) and applying multiple modifiers will, regardless or\n    order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n    \n    When multiple modifiers are applied to a given base tag, each\n    smaller set of modifiers is registered as a parent, so that for\n    example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n    `m1(m3(t1)`, and so on.\n    */\n    static defineModifier() {\n        let mod = new Modifier;\n        return (tag) => {\n            if (tag.modified.indexOf(mod) > -1)\n                return tag;\n            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\n        };\n    }\n}\nlet nextModifierID = 0;\nclass Modifier {\n    constructor() {\n        this.instances = [];\n        this.id = nextModifierID++;\n    }\n    static get(base, mods) {\n        if (!mods.length)\n            return base;\n        let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\n        if (exists)\n            return exists;\n        let set = [], tag = new Tag(set, base, mods);\n        for (let m of mods)\n            m.instances.push(tag);\n        let configs = powerSet(mods);\n        for (let parent of base.set)\n            if (!parent.modified.length)\n                for (let config of configs)\n                    set.push(Modifier.get(parent, config));\n        return tag;\n    }\n}\nfunction sameArray(a, b) {\n    return a.length == b.length && a.every((x, i) => x == b[i]);\n}\nfunction powerSet(array) {\n    let sets = [[]];\n    for (let i = 0; i < array.length; i++) {\n        for (let j = 0, e = sets.length; j < e; j++) {\n            sets.push(sets[j].concat(array[i]));\n        }\n    }\n    return sets.sort((a, b) => b.length - a.length);\n}\n/**\nThis function is used to add a set of tags to a language syntax\nvia [`NodeSet.extend`](#common.NodeSet.extend) or\n[`LRParser.configure`](#lr.LRParser.configure).\n\nThe argument object maps node selectors to [highlighting\ntags](#highlight.Tag) or arrays of tags.\n\nNode selectors may hold one or more (space-separated) node paths.\nSuch a path can be a [node name](#common.NodeType.name), or\nmultiple node names (or `*` wildcards) separated by slash\ncharacters, as in `\"Block/Declaration/VariableName\"`. Such a path\nmatches the final node but only if its direct parent nodes are the\nother nodes mentioned. A `*` in such a path matches any parent,\nbut only a single levelâ€”wildcards that match multiple parents\naren't supported, both for efficiency reasons and because Lezer\ntrees make it rather hard to reason about what they would match.)\n\nA path can be ended with `/...` to indicate that the tag assigned\nto the node should also apply to all child nodes, even if they\nmatch their own style (by default, only the innermost style is\nused).\n\nWhen a path ends in `!`, as in `Attribute!`, no further matching\nhappens for the node's child nodes, and the entire node gets the\ngiven style.\n\nIn this notation, node names that contain `/`, `!`, `*`, or `...`\nmust be quoted as JSON strings.\n\nFor example:\n\n```javascript\nparser.withProps(\n  styleTags({\n    // Style Number and BigNumber nodes\n    \"Number BigNumber\": tags.number,\n    // Style Escape nodes whose parent is String\n    \"String/Escape\": tags.escape,\n    // Style anything inside Attributes nodes\n    \"Attributes!\": tags.meta,\n    // Add a style to all content inside Italic nodes\n    \"Italic/...\": tags.emphasis,\n    // Style InvalidString nodes as both `string` and `invalid`\n    \"InvalidString\": [tags.string, tags.invalid],\n    // Style the node named \"/\" as punctuation\n    '\"/\"': tags.punctuation\n  })\n)\n```\n*/\nfunction styleTags(spec) {\n    let byName = Object.create(null);\n    for (let prop in spec) {\n        let tags = spec[prop];\n        if (!Array.isArray(tags))\n            tags = [tags];\n        for (let part of prop.split(\" \"))\n            if (part) {\n                let pieces = [], mode = 2 /* Normal */, rest = part;\n                for (let pos = 0;;) {\n                    if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n                        mode = 1 /* Inherit */;\n                        break;\n                    }\n                    let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n                    if (!m)\n                        throw new RangeError(\"Invalid path: \" + part);\n                    pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n                    pos += m[0].length;\n                    if (pos == part.length)\n                        break;\n                    let next = part[pos++];\n                    if (pos == part.length && next == \"!\") {\n                        mode = 0 /* Opaque */;\n                        break;\n                    }\n                    if (next != \"/\")\n                        throw new RangeError(\"Invalid path: \" + part);\n                    rest = part.slice(pos);\n                }\n                let last = pieces.length - 1, inner = pieces[last];\n                if (!inner)\n                    throw new RangeError(\"Invalid path: \" + part);\n                let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n                byName[inner] = rule.sort(byName[inner]);\n            }\n    }\n    return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\nclass Rule {\n    constructor(tags, mode, context, next) {\n        this.tags = tags;\n        this.mode = mode;\n        this.context = context;\n        this.next = next;\n    }\n    get opaque() { return this.mode == 0 /* Opaque */; }\n    get inherit() { return this.mode == 1 /* Inherit */; }\n    sort(other) {\n        if (!other || other.depth < this.depth) {\n            this.next = other;\n            return this;\n        }\n        other.next = this.sort(other.next);\n        return other;\n    }\n    get depth() { return this.context ? this.context.length : 0; }\n}\nRule.empty = new Rule([], 2 /* Normal */, null);\n/**\nDefine a [highlighter](#highlight.Highlighter) from an array of\ntag/class pairs. Classes associated with more specific tags will\ntake precedence.\n*/\nfunction tagHighlighter(tags, options) {\n    let map = Object.create(null);\n    for (let style of tags) {\n        if (!Array.isArray(style.tag))\n            map[style.tag.id] = style.class;\n        else\n            for (let tag of style.tag)\n                map[tag.id] = style.class;\n    }\n    let { scope, all = null } = options || {};\n    return {\n        style: (tags) => {\n            let cls = all;\n            for (let tag of tags) {\n                for (let sub of tag.set) {\n                    let tagClass = map[sub.id];\n                    if (tagClass) {\n                        cls = cls ? cls + \" \" + tagClass : tagClass;\n                        break;\n                    }\n                }\n            }\n            return cls;\n        },\n        scope\n    };\n}\nfunction highlightTags(highlighters, tags) {\n    let result = null;\n    for (let highlighter of highlighters) {\n        let value = highlighter.style(tags);\n        if (value)\n            result = result ? result + \" \" + value : value;\n    }\n    return result;\n}\n/**\nHighlight the given [tree](#common.Tree) with the given\n[highlighter](#highlight.Highlighter).\n*/\nfunction highlightTree(tree, highlighter, \n/**\nAssign styling to a region of the text. Will be called, in order\nof position, for any ranges where more than zero classes apply.\n`classes` is a space separated string of CSS classes.\n*/\nputStyle, \n/**\nThe start of the range to highlight.\n*/\nfrom = 0, \n/**\nThe end of the range.\n*/\nto = tree.length) {\n    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);\n    builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\n    builder.flush(to);\n}\nclass HighlightBuilder {\n    constructor(at, highlighters, span) {\n        this.at = at;\n        this.highlighters = highlighters;\n        this.span = span;\n        this.class = \"\";\n    }\n    startSpan(at, cls) {\n        if (cls != this.class) {\n            this.flush(at);\n            if (at > this.at)\n                this.at = at;\n            this.class = cls;\n        }\n    }\n    flush(to) {\n        if (to > this.at && this.class)\n            this.span(this.at, to, this.class);\n    }\n    highlightRange(cursor, from, to, inheritedClass, highlighters) {\n        let { type, from: start, to: end } = cursor;\n        if (start >= to || end <= from)\n            return;\n        if (type.isTop)\n            highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));\n        let cls = inheritedClass;\n        let rule = getStyleTags(cursor) || Rule.empty;\n        let tagCls = highlightTags(highlighters, rule.tags);\n        if (tagCls) {\n            if (cls)\n                cls += \" \";\n            cls += tagCls;\n            if (rule.mode == 1 /* Inherit */)\n                inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;\n        }\n        this.startSpan(Math.max(from, start), cls);\n        if (rule.opaque)\n            return;\n        let mounted = cursor.tree && cursor.tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n        if (mounted && mounted.overlay) {\n            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n            let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));\n            let hasChild = cursor.firstChild();\n            for (let i = 0, pos = start;; i++) {\n                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n                let nextPos = next ? next.from + start : end;\n                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);\n                if (rangeFrom < rangeTo && hasChild) {\n                    while (cursor.from < rangeTo) {\n                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\n                        this.startSpan(Math.min(rangeTo, cursor.to), cls);\n                        if (cursor.to >= nextPos || !cursor.nextSibling())\n                            break;\n                    }\n                }\n                if (!next || nextPos > to)\n                    break;\n                pos = next.to + start;\n                if (pos > from) {\n                    this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), \"\", innerHighlighters);\n                    this.startSpan(Math.min(to, pos), cls);\n                }\n            }\n            if (hasChild)\n                cursor.parent();\n        }\n        else if (cursor.firstChild()) {\n            if (mounted)\n                inheritedClass = \"\";\n            do {\n                if (cursor.to <= from)\n                    continue;\n                if (cursor.from >= to)\n                    break;\n                this.highlightRange(cursor, from, to, inheritedClass, highlighters);\n                this.startSpan(Math.min(to, cursor.to), cls);\n            } while (cursor.nextSibling());\n            cursor.parent();\n        }\n    }\n}\n/**\nMatch a syntax node's [highlight rules](#highlight.styleTags). If\nthere's a match, return its set of tags, and whether it is\nopaque (uses a `!`) or applies to all child nodes (`/...`).\n*/\nfunction getStyleTags(node) {\n    let rule = node.type.prop(ruleNodeProp);\n    while (rule && rule.context && !node.matchContext(rule.context))\n        rule = rule.next;\n    return rule || null;\n}\nconst t = Tag.define;\nconst comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();\n/**\nThe default set of highlighting [tags](#highlight.Tag).\n\nThis collection is heavily biased towards programming languages,\nand necessarily incomplete. A full ontology of syntactic\nconstructs would fill a stack of books, and be impractical to\nwrite themes for. So try to make do with this set. If all else\nfails, [open an\nissue](https://github.com/codemirror/codemirror.next) to propose a\nnew tag, or [define](#highlight.Tag^define) a local custom tag for\nyour use case.\n\nNote that it is not obligatory to always attach the most specific\ntag possible to an elementâ€”if your grammar can't easily\ndistinguish a certain type of element (such as a local variable),\nit is okay to style it as its more general variant (a variable).\n\nFor tags that extend some parent tag, the documentation links to\nthe parent.\n*/\nconst tags = {\n    /**\n    A comment.\n    */\n    comment,\n    /**\n    A line [comment](#highlight.tags.comment).\n    */\n    lineComment: t(comment),\n    /**\n    A block [comment](#highlight.tags.comment).\n    */\n    blockComment: t(comment),\n    /**\n    A documentation [comment](#highlight.tags.comment).\n    */\n    docComment: t(comment),\n    /**\n    Any kind of identifier.\n    */\n    name,\n    /**\n    The [name](#highlight.tags.name) of a variable.\n    */\n    variableName: t(name),\n    /**\n    A type [name](#highlight.tags.name).\n    */\n    typeName: typeName,\n    /**\n    A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n    */\n    tagName: t(typeName),\n    /**\n    A property or field [name](#highlight.tags.name).\n    */\n    propertyName: propertyName,\n    /**\n    An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n    */\n    attributeName: t(propertyName),\n    /**\n    The [name](#highlight.tags.name) of a class.\n    */\n    className: t(name),\n    /**\n    A label [name](#highlight.tags.name).\n    */\n    labelName: t(name),\n    /**\n    A namespace [name](#highlight.tags.name).\n    */\n    namespace: t(name),\n    /**\n    The [name](#highlight.tags.name) of a macro.\n    */\n    macroName: t(name),\n    /**\n    A literal value.\n    */\n    literal,\n    /**\n    A string [literal](#highlight.tags.literal).\n    */\n    string,\n    /**\n    A documentation [string](#highlight.tags.string).\n    */\n    docString: t(string),\n    /**\n    A character literal (subtag of [string](#highlight.tags.string)).\n    */\n    character: t(string),\n    /**\n    An attribute value (subtag of [string](#highlight.tags.string)).\n    */\n    attributeValue: t(string),\n    /**\n    A number [literal](#highlight.tags.literal).\n    */\n    number,\n    /**\n    An integer [number](#highlight.tags.number) literal.\n    */\n    integer: t(number),\n    /**\n    A floating-point [number](#highlight.tags.number) literal.\n    */\n    float: t(number),\n    /**\n    A boolean [literal](#highlight.tags.literal).\n    */\n    bool: t(literal),\n    /**\n    Regular expression [literal](#highlight.tags.literal).\n    */\n    regexp: t(literal),\n    /**\n    An escape [literal](#highlight.tags.literal), for example a\n    backslash escape in a string.\n    */\n    escape: t(literal),\n    /**\n    A color [literal](#highlight.tags.literal).\n    */\n    color: t(literal),\n    /**\n    A URL [literal](#highlight.tags.literal).\n    */\n    url: t(literal),\n    /**\n    A language keyword.\n    */\n    keyword,\n    /**\n    The [keyword](#highlight.tags.keyword) for the self or this\n    object.\n    */\n    self: t(keyword),\n    /**\n    The [keyword](#highlight.tags.keyword) for null.\n    */\n    null: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) denoting some atomic value.\n    */\n    atom: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that represents a unit.\n    */\n    unit: t(keyword),\n    /**\n    A modifier [keyword](#highlight.tags.keyword).\n    */\n    modifier: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that acts as an operator.\n    */\n    operatorKeyword: t(keyword),\n    /**\n    A control-flow related [keyword](#highlight.tags.keyword).\n    */\n    controlKeyword: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that defines something.\n    */\n    definitionKeyword: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) related to defining or\n    interfacing with modules.\n    */\n    moduleKeyword: t(keyword),\n    /**\n    An operator.\n    */\n    operator,\n    /**\n    An [operator](#highlight.tags.operator) that dereferences something.\n    */\n    derefOperator: t(operator),\n    /**\n    Arithmetic-related [operator](#highlight.tags.operator).\n    */\n    arithmeticOperator: t(operator),\n    /**\n    Logical [operator](#highlight.tags.operator).\n    */\n    logicOperator: t(operator),\n    /**\n    Bit [operator](#highlight.tags.operator).\n    */\n    bitwiseOperator: t(operator),\n    /**\n    Comparison [operator](#highlight.tags.operator).\n    */\n    compareOperator: t(operator),\n    /**\n    [Operator](#highlight.tags.operator) that updates its operand.\n    */\n    updateOperator: t(operator),\n    /**\n    [Operator](#highlight.tags.operator) that defines something.\n    */\n    definitionOperator: t(operator),\n    /**\n    Type-related [operator](#highlight.tags.operator).\n    */\n    typeOperator: t(operator),\n    /**\n    Control-flow [operator](#highlight.tags.operator).\n    */\n    controlOperator: t(operator),\n    /**\n    Program or markup punctuation.\n    */\n    punctuation,\n    /**\n    [Punctuation](#highlight.tags.punctuation) that separates\n    things.\n    */\n    separator: t(punctuation),\n    /**\n    Bracket-style [punctuation](#highlight.tags.punctuation).\n    */\n    bracket,\n    /**\n    Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n    tokens).\n    */\n    angleBracket: t(bracket),\n    /**\n    Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n    tokens).\n    */\n    squareBracket: t(bracket),\n    /**\n    Parentheses (usually `(` and `)` tokens). Subtag of\n    [bracket](#highlight.tags.bracket).\n    */\n    paren: t(bracket),\n    /**\n    Braces (usually `{` and `}` tokens). Subtag of\n    [bracket](#highlight.tags.bracket).\n    */\n    brace: t(bracket),\n    /**\n    Content, for example plain text in XML or markup documents.\n    */\n    content,\n    /**\n    [Content](#highlight.tags.content) that represents a heading.\n    */\n    heading,\n    /**\n    A level 1 [heading](#highlight.tags.heading).\n    */\n    heading1: t(heading),\n    /**\n    A level 2 [heading](#highlight.tags.heading).\n    */\n    heading2: t(heading),\n    /**\n    A level 3 [heading](#highlight.tags.heading).\n    */\n    heading3: t(heading),\n    /**\n    A level 4 [heading](#highlight.tags.heading).\n    */\n    heading4: t(heading),\n    /**\n    A level 5 [heading](#highlight.tags.heading).\n    */\n    heading5: t(heading),\n    /**\n    A level 6 [heading](#highlight.tags.heading).\n    */\n    heading6: t(heading),\n    /**\n    A prose separator (such as a horizontal rule).\n    */\n    contentSeparator: t(content),\n    /**\n    [Content](#highlight.tags.content) that represents a list.\n    */\n    list: t(content),\n    /**\n    [Content](#highlight.tags.content) that represents a quote.\n    */\n    quote: t(content),\n    /**\n    [Content](#highlight.tags.content) that is emphasized.\n    */\n    emphasis: t(content),\n    /**\n    [Content](#highlight.tags.content) that is styled strong.\n    */\n    strong: t(content),\n    /**\n    [Content](#highlight.tags.content) that is part of a link.\n    */\n    link: t(content),\n    /**\n    [Content](#highlight.tags.content) that is styled as code or\n    monospace.\n    */\n    monospace: t(content),\n    /**\n    [Content](#highlight.tags.content) that has a strike-through\n    style.\n    */\n    strikethrough: t(content),\n    /**\n    Inserted text in a change-tracking format.\n    */\n    inserted: t(),\n    /**\n    Deleted text.\n    */\n    deleted: t(),\n    /**\n    Changed text.\n    */\n    changed: t(),\n    /**\n    An invalid or unsyntactic element.\n    */\n    invalid: t(),\n    /**\n    Metadata or meta-instruction.\n    */\n    meta,\n    /**\n    [Metadata](#highlight.tags.meta) that applies to the entire\n    document.\n    */\n    documentMeta: t(meta),\n    /**\n    [Metadata](#highlight.tags.meta) that annotates or adds\n    attributes to a given syntactic element.\n    */\n    annotation: t(meta),\n    /**\n    Processing instruction or preprocessor directive. Subtag of\n    [meta](#highlight.tags.meta).\n    */\n    processingInstruction: t(meta),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates that a\n    given element is being defined. Expected to be used with the\n    various [name](#highlight.tags.name) tags.\n    */\n    definition: Tag.defineModifier(),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates that\n    something is constant. Mostly expected to be used with\n    [variable names](#highlight.tags.variableName).\n    */\n    constant: Tag.defineModifier(),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) used to indicate that\n    a [variable](#highlight.tags.variableName) or [property\n    name](#highlight.tags.propertyName) is being called or defined\n    as a function.\n    */\n    function: Tag.defineModifier(),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that can be applied to\n    [names](#highlight.tags.name) to indicate that they belong to\n    the language's standard environment.\n    */\n    standard: Tag.defineModifier(),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates a given\n    [names](#highlight.tags.name) is local to some scope.\n    */\n    local: Tag.defineModifier(),\n    /**\n    A generic variant [modifier](#highlight.Tag^defineModifier) that\n    can be used to tag language-specific alternative variants of\n    some common tag. It is recommended for themes to define special\n    forms of at least the [string](#highlight.tags.string) and\n    [variable name](#highlight.tags.variableName) tags, since those\n    come up a lot.\n    */\n    special: Tag.defineModifier()\n};\n/**\nThis is a highlighter that adds stable, predictable classes to\ntokens, for styling with external CSS.\n\nThe following tags are mapped to their name prefixed with `\"tok-\"`\n(for example `\"tok-comment\"`):\n\n* [`link`](#highlight.tags.link)\n* [`heading`](#highlight.tags.heading)\n* [`emphasis`](#highlight.tags.emphasis)\n* [`strong`](#highlight.tags.strong)\n* [`keyword`](#highlight.tags.keyword)\n* [`atom`](#highlight.tags.atom)\n* [`bool`](#highlight.tags.bool)\n* [`url`](#highlight.tags.url)\n* [`labelName`](#highlight.tags.labelName)\n* [`inserted`](#highlight.tags.inserted)\n* [`deleted`](#highlight.tags.deleted)\n* [`literal`](#highlight.tags.literal)\n* [`string`](#highlight.tags.string)\n* [`number`](#highlight.tags.number)\n* [`variableName`](#highlight.tags.variableName)\n* [`typeName`](#highlight.tags.typeName)\n* [`namespace`](#highlight.tags.namespace)\n* [`className`](#highlight.tags.className)\n* [`macroName`](#highlight.tags.macroName)\n* [`propertyName`](#highlight.tags.propertyName)\n* [`operator`](#highlight.tags.operator)\n* [`comment`](#highlight.tags.comment)\n* [`meta`](#highlight.tags.meta)\n* [`punctuation`](#highlight.tags.punctuation)\n* [`invalid`](#highlight.tags.invalid)\n\nIn addition, these mappings are provided:\n\n* [`regexp`](#highlight.tags.regexp),\n  [`escape`](#highlight.tags.escape), and\n  [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n  are mapped to `\"tok-string2\"`\n* [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName2\"`\n* [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-local\"`\n* [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-definition\"`\n* [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\n  to `\"tok-propertyName tok-definition\"`\n*/\nconst classHighlighter = tagHighlighter([\n    { tag: tags.link, class: \"tok-link\" },\n    { tag: tags.heading, class: \"tok-heading\" },\n    { tag: tags.emphasis, class: \"tok-emphasis\" },\n    { tag: tags.strong, class: \"tok-strong\" },\n    { tag: tags.keyword, class: \"tok-keyword\" },\n    { tag: tags.atom, class: \"tok-atom\" },\n    { tag: tags.bool, class: \"tok-bool\" },\n    { tag: tags.url, class: \"tok-url\" },\n    { tag: tags.labelName, class: \"tok-labelName\" },\n    { tag: tags.inserted, class: \"tok-inserted\" },\n    { tag: tags.deleted, class: \"tok-deleted\" },\n    { tag: tags.literal, class: \"tok-literal\" },\n    { tag: tags.string, class: \"tok-string\" },\n    { tag: tags.number, class: \"tok-number\" },\n    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: \"tok-string2\" },\n    { tag: tags.variableName, class: \"tok-variableName\" },\n    { tag: tags.local(tags.variableName), class: \"tok-variableName tok-local\" },\n    { tag: tags.definition(tags.variableName), class: \"tok-variableName tok-definition\" },\n    { tag: tags.special(tags.variableName), class: \"tok-variableName2\" },\n    { tag: tags.definition(tags.propertyName), class: \"tok-propertyName tok-definition\" },\n    { tag: tags.typeName, class: \"tok-typeName\" },\n    { tag: tags.namespace, class: \"tok-namespace\" },\n    { tag: tags.className, class: \"tok-className\" },\n    { tag: tags.macroName, class: \"tok-macroName\" },\n    { tag: tags.propertyName, class: \"tok-propertyName\" },\n    { tag: tags.operator, class: \"tok-operator\" },\n    { tag: tags.comment, class: \"tok-comment\" },\n    { tag: tags.meta, class: \"tok-meta\" },\n    { tag: tags.invalid, class: \"tok-invalid\" },\n    { tag: tags.punctuation, class: \"tok-punctuation\" }\n]);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2hpZ2hsaWdodC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEMseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtREFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2QkFBNkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtREFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1DQUFtQztBQUN6QyxNQUFNLHlDQUF5QztBQUMvQyxNQUFNLDJDQUEyQztBQUNqRCxNQUFNLHVDQUF1QztBQUM3QyxNQUFNLHlDQUF5QztBQUMvQyxNQUFNLG1DQUFtQztBQUN6QyxNQUFNLG1DQUFtQztBQUN6QyxNQUFNLGlDQUFpQztBQUN2QyxNQUFNLDZDQUE2QztBQUNuRCxNQUFNLDJDQUEyQztBQUNqRCxNQUFNLHlDQUF5QztBQUMvQyxNQUFNLHlDQUF5QztBQUMvQyxNQUFNLHVDQUF1QztBQUM3QyxNQUFNLHVDQUF1QztBQUM3QyxNQUFNLGtGQUFrRjtBQUN4RixNQUFNLG1EQUFtRDtBQUN6RCxNQUFNLHlFQUF5RTtBQUMvRSxNQUFNLG1GQUFtRjtBQUN6RixNQUFNLGtFQUFrRTtBQUN4RSxNQUFNLG1GQUFtRjtBQUN6RixNQUFNLDJDQUEyQztBQUNqRCxNQUFNLDZDQUE2QztBQUNuRCxNQUFNLDZDQUE2QztBQUNuRCxNQUFNLDZDQUE2QztBQUNuRCxNQUFNLG1EQUFtRDtBQUN6RCxNQUFNLDJDQUEyQztBQUNqRCxNQUFNLHlDQUF5QztBQUMvQyxNQUFNLG1DQUFtQztBQUN6QyxNQUFNLHlDQUF5QztBQUMvQyxNQUFNO0FBQ047O0FBRStGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGxpdmVibG9ja3MtZXhhbXBsZXMvbmV4dGpzLXlqcy1jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL0BsZXplci9oaWdobGlnaHQvZGlzdC9pbmRleC5qcz9lMmZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGVQcm9wIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5cbmxldCBuZXh0VGFnSUQgPSAwO1xuLyoqXG5IaWdobGlnaHRpbmcgdGFncyBhcmUgbWFya2VycyB0aGF0IGRlbm90ZSBhIGhpZ2hsaWdodGluZyBjYXRlZ29yeS5cblRoZXkgYXJlIFthc3NvY2lhdGVkXSgjaGlnaGxpZ2h0LnN0eWxlVGFncykgd2l0aCBwYXJ0cyBvZiBhIHN5bnRheFxudHJlZSBieSBhIGxhbmd1YWdlIG1vZGUsIGFuZCB0aGVuIG1hcHBlZCB0byBhbiBhY3R1YWwgQ1NTIHN0eWxlIGJ5XG5hIFtoaWdobGlnaHRlcl0oI2hpZ2hsaWdodC5IaWdobGlnaHRlcikuXG5cbkJlY2F1c2Ugc3ludGF4IHRyZWUgbm9kZSB0eXBlcyBhbmQgaGlnaGxpZ2h0IHN0eWxlcyBoYXZlIHRvIGJlXG5hYmxlIHRvIHRhbGsgdGhlIHNhbWUgbGFuZ3VhZ2UsIENvZGVNaXJyb3IgdXNlcyBhIG1vc3RseSBfY2xvc2VkX1xuW3ZvY2FidWxhcnldKCNoaWdobGlnaHQudGFncykgb2Ygc3ludGF4IHRhZ3MgKGFzIG9wcG9zZWQgdG9cbnRyYWRpdGlvbmFsIG9wZW4gc3RyaW5nLWJhc2VkIHN5c3RlbXMsIHdoaWNoIG1ha2UgaXQgaGFyZCBmb3JcbmhpZ2hsaWdodGluZyB0aGVtZXMgdG8gY292ZXIgYWxsIHRoZSB0b2tlbnMgcHJvZHVjZWQgYnkgdGhlXG52YXJpb3VzIGxhbmd1YWdlcykuXG5cbkl0IF9pc18gcG9zc2libGUgdG8gW2RlZmluZV0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lKSB5b3VyIG93blxuaGlnaGxpZ2h0aW5nIHRhZ3MgZm9yIHN5c3RlbS1pbnRlcm5hbCB1c2UgKHdoZXJlIHlvdSBjb250cm9sIGJvdGhcbnRoZSBsYW5ndWFnZSBwYWNrYWdlIGFuZCB0aGUgaGlnaGxpZ2h0ZXIpLCBidXQgc3VjaCB0YWdzIHdpbGwgbm90XG5iZSBwaWNrZWQgdXAgYnkgcmVndWxhciBoaWdobGlnaHRlcnMgKHRob3VnaCB5b3UgY2FuIGRlcml2ZSB0aGVtXG5mcm9tIHN0YW5kYXJkIHRhZ3MgdG8gYWxsb3cgaGlnaGxpZ2h0ZXJzIHRvIGZhbGwgYmFjayB0byB0aG9zZSkuXG4qL1xuY2xhc3MgVGFnIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzZXQgb2YgdGhpcyB0YWcgYW5kIGFsbCBpdHMgcGFyZW50IHRhZ3MsIHN0YXJ0aW5nIHdpdGhcbiAgICB0aGlzIG9uZSBpdHNlbGYgYW5kIHNvcnRlZCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nIHNwZWNpZmljaXR5LlxuICAgICovXG4gICAgc2V0LCBcbiAgICAvKipcbiAgICBUaGUgYmFzZSB1bm1vZGlmaWVkIHRhZyB0aGF0IHRoaXMgb25lIGlzIGJhc2VkIG9uLCBpZiBpdCdzXG4gICAgbW9kaWZpZWQgQGludGVybmFsXG4gICAgKi9cbiAgICBiYXNlLCBcbiAgICAvKipcbiAgICBUaGUgbW9kaWZpZXJzIGFwcGxpZWQgdG8gdGhpcy5iYXNlIEBpbnRlcm5hbFxuICAgICovXG4gICAgbW9kaWZpZWQpIHtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgICAgIHRoaXMubW9kaWZpZWQgPSBtb2RpZmllZDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gbmV4dFRhZ0lEKys7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyB0YWcuIElmIGBwYXJlbnRgIGlzIGdpdmVuLCB0aGUgdGFnIGlzIHRyZWF0ZWQgYXMgYVxuICAgIHN1Yi10YWcgb2YgdGhhdCBwYXJlbnQsIGFuZFxuICAgIFtoaWdobGlnaHRlcnNdKCNoaWdobGlnaHQudGFnSGlnaGxpZ2h0ZXIpIHRoYXQgZG9uJ3QgbWVudGlvblxuICAgIHRoaXMgdGFnIHdpbGwgdHJ5IHRvIGZhbGwgYmFjayB0byB0aGUgcGFyZW50IHRhZyAob3IgZ3JhbmRwYXJlbnRcbiAgICB0YWcsIGV0YykuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmJhc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGRlcml2ZSBmcm9tIGEgbW9kaWZpZWQgdGFnXCIpO1xuICAgICAgICBsZXQgdGFnID0gbmV3IFRhZyhbXSwgbnVsbCwgW10pO1xuICAgICAgICB0YWcuc2V0LnB1c2godGFnKTtcbiAgICAgICAgaWYgKHBhcmVudClcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgcGFyZW50LnNldClcbiAgICAgICAgICAgICAgICB0YWcuc2V0LnB1c2godCk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHRhZyBfbW9kaWZpZXJfLCB3aGljaCBpcyBhIGZ1bmN0aW9uIHRoYXQsIGdpdmVuIGEgdGFnLFxuICAgIHdpbGwgcmV0dXJuIGEgdGFnIHRoYXQgaXMgYSBzdWJ0YWcgb2YgdGhlIG9yaWdpbmFsLiBBcHBseWluZyB0aGVcbiAgICBzYW1lIG1vZGlmaWVyIHRvIGEgdHdpY2UgdGFnIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHZhbHVlIChgbTEodDEpXG4gICAgPT0gbTEodDEpYCkgYW5kIGFwcGx5aW5nIG11bHRpcGxlIG1vZGlmaWVycyB3aWxsLCByZWdhcmRsZXNzIG9yXG4gICAgb3JkZXIsIHByb2R1Y2UgdGhlIHNhbWUgdGFnIChgbTEobTIodDEpKSA9PSBtMihtMSh0MSkpYCkuXG4gICAgXG4gICAgV2hlbiBtdWx0aXBsZSBtb2RpZmllcnMgYXJlIGFwcGxpZWQgdG8gYSBnaXZlbiBiYXNlIHRhZywgZWFjaFxuICAgIHNtYWxsZXIgc2V0IG9mIG1vZGlmaWVycyBpcyByZWdpc3RlcmVkIGFzIGEgcGFyZW50LCBzbyB0aGF0IGZvclxuICAgIGV4YW1wbGUgYG0xKG0yKG0zKHQxKSkpYCBpcyBhIHN1YnR5cGUgb2YgYG0xKG0yKHQxKSlgLFxuICAgIGBtMShtMyh0MSlgLCBhbmQgc28gb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lTW9kaWZpZXIoKSB7XG4gICAgICAgIGxldCBtb2QgPSBuZXcgTW9kaWZpZXI7XG4gICAgICAgIHJldHVybiAodGFnKSA9PiB7XG4gICAgICAgICAgICBpZiAodGFnLm1vZGlmaWVkLmluZGV4T2YobW9kKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICAgICAgICByZXR1cm4gTW9kaWZpZXIuZ2V0KHRhZy5iYXNlIHx8IHRhZywgdGFnLm1vZGlmaWVkLmNvbmNhdChtb2QpLnNvcnQoKGEsIGIpID0+IGEuaWQgLSBiLmlkKSk7XG4gICAgICAgIH07XG4gICAgfVxufVxubGV0IG5leHRNb2RpZmllcklEID0gMDtcbmNsYXNzIE1vZGlmaWVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRNb2RpZmllcklEKys7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQoYmFzZSwgbW9kcykge1xuICAgICAgICBpZiAoIW1vZHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIGxldCBleGlzdHMgPSBtb2RzWzBdLmluc3RhbmNlcy5maW5kKHQgPT4gdC5iYXNlID09IGJhc2UgJiYgc2FtZUFycmF5KG1vZHMsIHQubW9kaWZpZWQpKTtcbiAgICAgICAgaWYgKGV4aXN0cylcbiAgICAgICAgICAgIHJldHVybiBleGlzdHM7XG4gICAgICAgIGxldCBzZXQgPSBbXSwgdGFnID0gbmV3IFRhZyhzZXQsIGJhc2UsIG1vZHMpO1xuICAgICAgICBmb3IgKGxldCBtIG9mIG1vZHMpXG4gICAgICAgICAgICBtLmluc3RhbmNlcy5wdXNoKHRhZyk7XG4gICAgICAgIGxldCBjb25maWdzID0gcG93ZXJTZXQobW9kcyk7XG4gICAgICAgIGZvciAobGV0IHBhcmVudCBvZiBiYXNlLnNldClcbiAgICAgICAgICAgIGlmICghcGFyZW50Lm1vZGlmaWVkLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb25maWcgb2YgY29uZmlncylcbiAgICAgICAgICAgICAgICAgICAgc2V0LnB1c2goTW9kaWZpZXIuZ2V0KHBhcmVudCwgY29uZmlnKSk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZUFycmF5KGEsIGIpIHtcbiAgICByZXR1cm4gYS5sZW5ndGggPT0gYi5sZW5ndGggJiYgYS5ldmVyeSgoeCwgaSkgPT4geCA9PSBiW2ldKTtcbn1cbmZ1bmN0aW9uIHBvd2VyU2V0KGFycmF5KSB7XG4gICAgbGV0IHNldHMgPSBbW11dO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIGUgPSBzZXRzLmxlbmd0aDsgaiA8IGU7IGorKykge1xuICAgICAgICAgICAgc2V0cy5wdXNoKHNldHNbal0uY29uY2F0KGFycmF5W2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNldHMuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aCk7XG59XG4vKipcblRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhZGQgYSBzZXQgb2YgdGFncyB0byBhIGxhbmd1YWdlIHN5bnRheFxudmlhIFtgTm9kZVNldC5leHRlbmRgXSgjY29tbW9uLk5vZGVTZXQuZXh0ZW5kKSBvclxuW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuTFJQYXJzZXIuY29uZmlndXJlKS5cblxuVGhlIGFyZ3VtZW50IG9iamVjdCBtYXBzIG5vZGUgc2VsZWN0b3JzIHRvIFtoaWdobGlnaHRpbmdcbnRhZ3NdKCNoaWdobGlnaHQuVGFnKSBvciBhcnJheXMgb2YgdGFncy5cblxuTm9kZSBzZWxlY3RvcnMgbWF5IGhvbGQgb25lIG9yIG1vcmUgKHNwYWNlLXNlcGFyYXRlZCkgbm9kZSBwYXRocy5cblN1Y2ggYSBwYXRoIGNhbiBiZSBhIFtub2RlIG5hbWVdKCNjb21tb24uTm9kZVR5cGUubmFtZSksIG9yXG5tdWx0aXBsZSBub2RlIG5hbWVzIChvciBgKmAgd2lsZGNhcmRzKSBzZXBhcmF0ZWQgYnkgc2xhc2hcbmNoYXJhY3RlcnMsIGFzIGluIGBcIkJsb2NrL0RlY2xhcmF0aW9uL1ZhcmlhYmxlTmFtZVwiYC4gU3VjaCBhIHBhdGhcbm1hdGNoZXMgdGhlIGZpbmFsIG5vZGUgYnV0IG9ubHkgaWYgaXRzIGRpcmVjdCBwYXJlbnQgbm9kZXMgYXJlIHRoZVxub3RoZXIgbm9kZXMgbWVudGlvbmVkLiBBIGAqYCBpbiBzdWNoIGEgcGF0aCBtYXRjaGVzIGFueSBwYXJlbnQsXG5idXQgb25seSBhIHNpbmdsZSBsZXZlbOKAlHdpbGRjYXJkcyB0aGF0IG1hdGNoIG11bHRpcGxlIHBhcmVudHNcbmFyZW4ndCBzdXBwb3J0ZWQsIGJvdGggZm9yIGVmZmljaWVuY3kgcmVhc29ucyBhbmQgYmVjYXVzZSBMZXplclxudHJlZXMgbWFrZSBpdCByYXRoZXIgaGFyZCB0byByZWFzb24gYWJvdXQgd2hhdCB0aGV5IHdvdWxkIG1hdGNoLilcblxuQSBwYXRoIGNhbiBiZSBlbmRlZCB3aXRoIGAvLi4uYCB0byBpbmRpY2F0ZSB0aGF0IHRoZSB0YWcgYXNzaWduZWRcbnRvIHRoZSBub2RlIHNob3VsZCBhbHNvIGFwcGx5IHRvIGFsbCBjaGlsZCBub2RlcywgZXZlbiBpZiB0aGV5XG5tYXRjaCB0aGVpciBvd24gc3R5bGUgKGJ5IGRlZmF1bHQsIG9ubHkgdGhlIGlubmVybW9zdCBzdHlsZSBpc1xudXNlZCkuXG5cbldoZW4gYSBwYXRoIGVuZHMgaW4gYCFgLCBhcyBpbiBgQXR0cmlidXRlIWAsIG5vIGZ1cnRoZXIgbWF0Y2hpbmdcbmhhcHBlbnMgZm9yIHRoZSBub2RlJ3MgY2hpbGQgbm9kZXMsIGFuZCB0aGUgZW50aXJlIG5vZGUgZ2V0cyB0aGVcbmdpdmVuIHN0eWxlLlxuXG5JbiB0aGlzIG5vdGF0aW9uLCBub2RlIG5hbWVzIHRoYXQgY29udGFpbiBgL2AsIGAhYCwgYCpgLCBvciBgLi4uYFxubXVzdCBiZSBxdW90ZWQgYXMgSlNPTiBzdHJpbmdzLlxuXG5Gb3IgZXhhbXBsZTpcblxuYGBgamF2YXNjcmlwdFxucGFyc2VyLndpdGhQcm9wcyhcbiAgc3R5bGVUYWdzKHtcbiAgICAvLyBTdHlsZSBOdW1iZXIgYW5kIEJpZ051bWJlciBub2Rlc1xuICAgIFwiTnVtYmVyIEJpZ051bWJlclwiOiB0YWdzLm51bWJlcixcbiAgICAvLyBTdHlsZSBFc2NhcGUgbm9kZXMgd2hvc2UgcGFyZW50IGlzIFN0cmluZ1xuICAgIFwiU3RyaW5nL0VzY2FwZVwiOiB0YWdzLmVzY2FwZSxcbiAgICAvLyBTdHlsZSBhbnl0aGluZyBpbnNpZGUgQXR0cmlidXRlcyBub2Rlc1xuICAgIFwiQXR0cmlidXRlcyFcIjogdGFncy5tZXRhLFxuICAgIC8vIEFkZCBhIHN0eWxlIHRvIGFsbCBjb250ZW50IGluc2lkZSBJdGFsaWMgbm9kZXNcbiAgICBcIkl0YWxpYy8uLi5cIjogdGFncy5lbXBoYXNpcyxcbiAgICAvLyBTdHlsZSBJbnZhbGlkU3RyaW5nIG5vZGVzIGFzIGJvdGggYHN0cmluZ2AgYW5kIGBpbnZhbGlkYFxuICAgIFwiSW52YWxpZFN0cmluZ1wiOiBbdGFncy5zdHJpbmcsIHRhZ3MuaW52YWxpZF0sXG4gICAgLy8gU3R5bGUgdGhlIG5vZGUgbmFtZWQgXCIvXCIgYXMgcHVuY3R1YXRpb25cbiAgICAnXCIvXCInOiB0YWdzLnB1bmN0dWF0aW9uXG4gIH0pXG4pXG5gYGBcbiovXG5mdW5jdGlvbiBzdHlsZVRhZ3Moc3BlYykge1xuICAgIGxldCBieU5hbWUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHByb3AgaW4gc3BlYykge1xuICAgICAgICBsZXQgdGFncyA9IHNwZWNbcHJvcF07XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWdzKSlcbiAgICAgICAgICAgIHRhZ3MgPSBbdGFnc107XG4gICAgICAgIGZvciAobGV0IHBhcnQgb2YgcHJvcC5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICBpZiAocGFydCkge1xuICAgICAgICAgICAgICAgIGxldCBwaWVjZXMgPSBbXSwgbW9kZSA9IDIgLyogTm9ybWFsICovLCByZXN0ID0gcGFydDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3MgPSAwOzspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3QgPT0gXCIuLi5cIiAmJiBwb3MgPiAwICYmIHBvcyArIDMgPT0gcGFydC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSAxIC8qIEluaGVyaXQgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IC9eXCIoPzpbXlwiXFxcXF18XFxcXC4pKj9cInxbXlxcLyFdKy8uZXhlYyhyZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHBhdGg6IFwiICsgcGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHBpZWNlcy5wdXNoKG1bMF0gPT0gXCIqXCIgPyBcIlwiIDogbVswXVswXSA9PSAnXCInID8gSlNPTi5wYXJzZShtWzBdKSA6IG1bMF0pO1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gbVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPT0gcGFydC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBwYXJ0W3BvcysrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA9PSBwYXJ0Lmxlbmd0aCAmJiBuZXh0ID09IFwiIVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gMCAvKiBPcGFxdWUgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSBcIi9cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgICAgICByZXN0ID0gcGFydC5zbGljZShwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IHBpZWNlcy5sZW5ndGggLSAxLCBpbm5lciA9IHBpZWNlc1tsYXN0XTtcbiAgICAgICAgICAgICAgICBpZiAoIWlubmVyKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICBsZXQgcnVsZSA9IG5ldyBSdWxlKHRhZ3MsIG1vZGUsIGxhc3QgPiAwID8gcGllY2VzLnNsaWNlKDAsIGxhc3QpIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgYnlOYW1lW2lubmVyXSA9IHJ1bGUuc29ydChieU5hbWVbaW5uZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ1bGVOb2RlUHJvcC5hZGQoYnlOYW1lKTtcbn1cbmNvbnN0IHJ1bGVOb2RlUHJvcCA9IG5ldyBOb2RlUHJvcCgpO1xuY2xhc3MgUnVsZSB7XG4gICAgY29uc3RydWN0b3IodGFncywgbW9kZSwgY29udGV4dCwgbmV4dCkge1xuICAgICAgICB0aGlzLnRhZ3MgPSB0YWdzO1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLm5leHQgPSBuZXh0O1xuICAgIH1cbiAgICBnZXQgb3BhcXVlKCkgeyByZXR1cm4gdGhpcy5tb2RlID09IDAgLyogT3BhcXVlICovOyB9XG4gICAgZ2V0IGluaGVyaXQoKSB7IHJldHVybiB0aGlzLm1vZGUgPT0gMSAvKiBJbmhlcml0ICovOyB9XG4gICAgc29ydChvdGhlcikge1xuICAgICAgICBpZiAoIW90aGVyIHx8IG90aGVyLmRlcHRoIDwgdGhpcy5kZXB0aCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0ID0gb3RoZXI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBvdGhlci5uZXh0ID0gdGhpcy5zb3J0KG90aGVyLm5leHQpO1xuICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgfVxuICAgIGdldCBkZXB0aCgpIHsgcmV0dXJuIHRoaXMuY29udGV4dCA/IHRoaXMuY29udGV4dC5sZW5ndGggOiAwOyB9XG59XG5SdWxlLmVtcHR5ID0gbmV3IFJ1bGUoW10sIDIgLyogTm9ybWFsICovLCBudWxsKTtcbi8qKlxuRGVmaW5lIGEgW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKSBmcm9tIGFuIGFycmF5IG9mXG50YWcvY2xhc3MgcGFpcnMuIENsYXNzZXMgYXNzb2NpYXRlZCB3aXRoIG1vcmUgc3BlY2lmaWMgdGFncyB3aWxsXG50YWtlIHByZWNlZGVuY2UuXG4qL1xuZnVuY3Rpb24gdGFnSGlnaGxpZ2h0ZXIodGFncywgb3B0aW9ucykge1xuICAgIGxldCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHN0eWxlIG9mIHRhZ3MpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHN0eWxlLnRhZykpXG4gICAgICAgICAgICBtYXBbc3R5bGUudGFnLmlkXSA9IHN0eWxlLmNsYXNzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCB0YWcgb2Ygc3R5bGUudGFnKVxuICAgICAgICAgICAgICAgIG1hcFt0YWcuaWRdID0gc3R5bGUuY2xhc3M7XG4gICAgfVxuICAgIGxldCB7IHNjb3BlLCBhbGwgPSBudWxsIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0eWxlOiAodGFncykgPT4ge1xuICAgICAgICAgICAgbGV0IGNscyA9IGFsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHRhZyBvZiB0YWdzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc3ViIG9mIHRhZy5zZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhZ0NsYXNzID0gbWFwW3N1Yi5pZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xzID0gY2xzID8gY2xzICsgXCIgXCIgKyB0YWdDbGFzcyA6IHRhZ0NsYXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xzO1xuICAgICAgICB9LFxuICAgICAgICBzY29wZVxuICAgIH07XG59XG5mdW5jdGlvbiBoaWdobGlnaHRUYWdzKGhpZ2hsaWdodGVycywgdGFncykge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGZvciAobGV0IGhpZ2hsaWdodGVyIG9mIGhpZ2hsaWdodGVycykge1xuICAgICAgICBsZXQgdmFsdWUgPSBoaWdobGlnaHRlci5zdHlsZSh0YWdzKTtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID8gcmVzdWx0ICsgXCIgXCIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5IaWdobGlnaHQgdGhlIGdpdmVuIFt0cmVlXSgjY29tbW9uLlRyZWUpIHdpdGggdGhlIGdpdmVuXG5baGlnaGxpZ2h0ZXJdKCNoaWdobGlnaHQuSGlnaGxpZ2h0ZXIpLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodFRyZWUodHJlZSwgaGlnaGxpZ2h0ZXIsIFxuLyoqXG5Bc3NpZ24gc3R5bGluZyB0byBhIHJlZ2lvbiBvZiB0aGUgdGV4dC4gV2lsbCBiZSBjYWxsZWQsIGluIG9yZGVyXG5vZiBwb3NpdGlvbiwgZm9yIGFueSByYW5nZXMgd2hlcmUgbW9yZSB0aGFuIHplcm8gY2xhc3NlcyBhcHBseS5cbmBjbGFzc2VzYCBpcyBhIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2YgQ1NTIGNsYXNzZXMuXG4qL1xucHV0U3R5bGUsIFxuLyoqXG5UaGUgc3RhcnQgb2YgdGhlIHJhbmdlIHRvIGhpZ2hsaWdodC5cbiovXG5mcm9tID0gMCwgXG4vKipcblRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuKi9cbnRvID0gdHJlZS5sZW5ndGgpIHtcbiAgICBsZXQgYnVpbGRlciA9IG5ldyBIaWdobGlnaHRCdWlsZGVyKGZyb20sIEFycmF5LmlzQXJyYXkoaGlnaGxpZ2h0ZXIpID8gaGlnaGxpZ2h0ZXIgOiBbaGlnaGxpZ2h0ZXJdLCBwdXRTdHlsZSk7XG4gICAgYnVpbGRlci5oaWdobGlnaHRSYW5nZSh0cmVlLmN1cnNvcigpLCBmcm9tLCB0bywgXCJcIiwgYnVpbGRlci5oaWdobGlnaHRlcnMpO1xuICAgIGJ1aWxkZXIuZmx1c2godG8pO1xufVxuY2xhc3MgSGlnaGxpZ2h0QnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoYXQsIGhpZ2hsaWdodGVycywgc3Bhbikge1xuICAgICAgICB0aGlzLmF0ID0gYXQ7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZXJzID0gaGlnaGxpZ2h0ZXJzO1xuICAgICAgICB0aGlzLnNwYW4gPSBzcGFuO1xuICAgICAgICB0aGlzLmNsYXNzID0gXCJcIjtcbiAgICB9XG4gICAgc3RhcnRTcGFuKGF0LCBjbHMpIHtcbiAgICAgICAgaWYgKGNscyAhPSB0aGlzLmNsYXNzKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKGF0KTtcbiAgICAgICAgICAgIGlmIChhdCA+IHRoaXMuYXQpXG4gICAgICAgICAgICAgICAgdGhpcy5hdCA9IGF0O1xuICAgICAgICAgICAgdGhpcy5jbGFzcyA9IGNscztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaCh0bykge1xuICAgICAgICBpZiAodG8gPiB0aGlzLmF0ICYmIHRoaXMuY2xhc3MpXG4gICAgICAgICAgICB0aGlzLnNwYW4odGhpcy5hdCwgdG8sIHRoaXMuY2xhc3MpO1xuICAgIH1cbiAgICBoaWdobGlnaHRSYW5nZShjdXJzb3IsIGZyb20sIHRvLCBpbmhlcml0ZWRDbGFzcywgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgIGxldCB7IHR5cGUsIGZyb206IHN0YXJ0LCB0bzogZW5kIH0gPSBjdXJzb3I7XG4gICAgICAgIGlmIChzdGFydCA+PSB0byB8fCBlbmQgPD0gZnJvbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGUuaXNUb3ApXG4gICAgICAgICAgICBoaWdobGlnaHRlcnMgPSB0aGlzLmhpZ2hsaWdodGVycy5maWx0ZXIoaCA9PiAhaC5zY29wZSB8fCBoLnNjb3BlKHR5cGUpKTtcbiAgICAgICAgbGV0IGNscyA9IGluaGVyaXRlZENsYXNzO1xuICAgICAgICBsZXQgcnVsZSA9IGdldFN0eWxlVGFncyhjdXJzb3IpIHx8IFJ1bGUuZW1wdHk7XG4gICAgICAgIGxldCB0YWdDbHMgPSBoaWdobGlnaHRUYWdzKGhpZ2hsaWdodGVycywgcnVsZS50YWdzKTtcbiAgICAgICAgaWYgKHRhZ0Nscykge1xuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICBjbHMgKz0gXCIgXCI7XG4gICAgICAgICAgICBjbHMgKz0gdGFnQ2xzO1xuICAgICAgICAgICAgaWYgKHJ1bGUubW9kZSA9PSAxIC8qIEluaGVyaXQgKi8pXG4gICAgICAgICAgICAgICAgaW5oZXJpdGVkQ2xhc3MgKz0gKGluaGVyaXRlZENsYXNzID8gXCIgXCIgOiBcIlwiKSArIHRhZ0NscztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1heChmcm9tLCBzdGFydCksIGNscyk7XG4gICAgICAgIGlmIChydWxlLm9wYXF1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG1vdW50ZWQgPSBjdXJzb3IudHJlZSAmJiBjdXJzb3IudHJlZS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICBpZiAobW91bnRlZCAmJiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IGN1cnNvci5ub2RlLmVudGVyKG1vdW50ZWQub3ZlcmxheVswXS5mcm9tICsgc3RhcnQsIDEpO1xuICAgICAgICAgICAgbGV0IGlubmVySGlnaGxpZ2h0ZXJzID0gdGhpcy5oaWdobGlnaHRlcnMuZmlsdGVyKGggPT4gIWguc2NvcGUgfHwgaC5zY29wZShtb3VudGVkLnRyZWUudHlwZSkpO1xuICAgICAgICAgICAgbGV0IGhhc0NoaWxkID0gY3Vyc29yLmZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBzdGFydDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gaSA8IG1vdW50ZWQub3ZlcmxheS5sZW5ndGggPyBtb3VudGVkLm92ZXJsYXlbaV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0UG9zID0gbmV4dCA/IG5leHQuZnJvbSArIHN0YXJ0IDogZW5kO1xuICAgICAgICAgICAgICAgIGxldCByYW5nZUZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpLCByYW5nZVRvID0gTWF0aC5taW4odG8sIG5leHRQb3MpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZUZyb20gPCByYW5nZVRvICYmIGhhc0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IuZnJvbSA8IHJhbmdlVG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCByYW5nZUZyb20sIHJhbmdlVG8sIGluaGVyaXRlZENsYXNzLCBoaWdobGlnaHRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFNwYW4oTWF0aC5taW4ocmFuZ2VUbywgY3Vyc29yLnRvKSwgY2xzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPj0gbmV4dFBvcyB8fCAhY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHRQb3MgPiB0bylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcG9zID0gbmV4dC50byArIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoaW5uZXIuY3Vyc29yKCksIE1hdGgubWF4KGZyb20sIG5leHQuZnJvbSArIHN0YXJ0KSwgTWF0aC5taW4odG8sIHBvcyksIFwiXCIsIGlubmVySGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFNwYW4oTWF0aC5taW4odG8sIHBvcyksIGNscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0NoaWxkKVxuICAgICAgICAgICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJzb3IuZmlyc3RDaGlsZCgpKSB7XG4gICAgICAgICAgICBpZiAobW91bnRlZClcbiAgICAgICAgICAgICAgICBpbmhlcml0ZWRDbGFzcyA9IFwiXCI7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvci50byA8PSBmcm9tKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLmZyb20gPj0gdG8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCBmcm9tLCB0bywgaW5oZXJpdGVkQ2xhc3MsIGhpZ2hsaWdodGVycyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFNwYW4oTWF0aC5taW4odG8sIGN1cnNvci50byksIGNscyk7XG4gICAgICAgICAgICB9IHdoaWxlIChjdXJzb3IubmV4dFNpYmxpbmcoKSk7XG4gICAgICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbk1hdGNoIGEgc3ludGF4IG5vZGUncyBbaGlnaGxpZ2h0IHJ1bGVzXSgjaGlnaGxpZ2h0LnN0eWxlVGFncykuIElmXG50aGVyZSdzIGEgbWF0Y2gsIHJldHVybiBpdHMgc2V0IG9mIHRhZ3MsIGFuZCB3aGV0aGVyIGl0IGlzXG5vcGFxdWUgKHVzZXMgYSBgIWApIG9yIGFwcGxpZXMgdG8gYWxsIGNoaWxkIG5vZGVzIChgLy4uLmApLlxuKi9cbmZ1bmN0aW9uIGdldFN0eWxlVGFncyhub2RlKSB7XG4gICAgbGV0IHJ1bGUgPSBub2RlLnR5cGUucHJvcChydWxlTm9kZVByb3ApO1xuICAgIHdoaWxlIChydWxlICYmIHJ1bGUuY29udGV4dCAmJiAhbm9kZS5tYXRjaENvbnRleHQocnVsZS5jb250ZXh0KSlcbiAgICAgICAgcnVsZSA9IHJ1bGUubmV4dDtcbiAgICByZXR1cm4gcnVsZSB8fCBudWxsO1xufVxuY29uc3QgdCA9IFRhZy5kZWZpbmU7XG5jb25zdCBjb21tZW50ID0gdCgpLCBuYW1lID0gdCgpLCB0eXBlTmFtZSA9IHQobmFtZSksIHByb3BlcnR5TmFtZSA9IHQobmFtZSksIGxpdGVyYWwgPSB0KCksIHN0cmluZyA9IHQobGl0ZXJhbCksIG51bWJlciA9IHQobGl0ZXJhbCksIGNvbnRlbnQgPSB0KCksIGhlYWRpbmcgPSB0KGNvbnRlbnQpLCBrZXl3b3JkID0gdCgpLCBvcGVyYXRvciA9IHQoKSwgcHVuY3R1YXRpb24gPSB0KCksIGJyYWNrZXQgPSB0KHB1bmN0dWF0aW9uKSwgbWV0YSA9IHQoKTtcbi8qKlxuVGhlIGRlZmF1bHQgc2V0IG9mIGhpZ2hsaWdodGluZyBbdGFnc10oI2hpZ2hsaWdodC5UYWcpLlxuXG5UaGlzIGNvbGxlY3Rpb24gaXMgaGVhdmlseSBiaWFzZWQgdG93YXJkcyBwcm9ncmFtbWluZyBsYW5ndWFnZXMsXG5hbmQgbmVjZXNzYXJpbHkgaW5jb21wbGV0ZS4gQSBmdWxsIG9udG9sb2d5IG9mIHN5bnRhY3RpY1xuY29uc3RydWN0cyB3b3VsZCBmaWxsIGEgc3RhY2sgb2YgYm9va3MsIGFuZCBiZSBpbXByYWN0aWNhbCB0b1xud3JpdGUgdGhlbWVzIGZvci4gU28gdHJ5IHRvIG1ha2UgZG8gd2l0aCB0aGlzIHNldC4gSWYgYWxsIGVsc2VcbmZhaWxzLCBbb3BlbiBhblxuaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2NvZGVtaXJyb3IubmV4dCkgdG8gcHJvcG9zZSBhXG5uZXcgdGFnLCBvciBbZGVmaW5lXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmUpIGEgbG9jYWwgY3VzdG9tIHRhZyBmb3JcbnlvdXIgdXNlIGNhc2UuXG5cbk5vdGUgdGhhdCBpdCBpcyBub3Qgb2JsaWdhdG9yeSB0byBhbHdheXMgYXR0YWNoIHRoZSBtb3N0IHNwZWNpZmljXG50YWcgcG9zc2libGUgdG8gYW4gZWxlbWVudOKAlGlmIHlvdXIgZ3JhbW1hciBjYW4ndCBlYXNpbHlcbmRpc3Rpbmd1aXNoIGEgY2VydGFpbiB0eXBlIG9mIGVsZW1lbnQgKHN1Y2ggYXMgYSBsb2NhbCB2YXJpYWJsZSksXG5pdCBpcyBva2F5IHRvIHN0eWxlIGl0IGFzIGl0cyBtb3JlIGdlbmVyYWwgdmFyaWFudCAoYSB2YXJpYWJsZSkuXG5cbkZvciB0YWdzIHRoYXQgZXh0ZW5kIHNvbWUgcGFyZW50IHRhZywgdGhlIGRvY3VtZW50YXRpb24gbGlua3MgdG9cbnRoZSBwYXJlbnQuXG4qL1xuY29uc3QgdGFncyA9IHtcbiAgICAvKipcbiAgICBBIGNvbW1lbnQuXG4gICAgKi9cbiAgICBjb21tZW50LFxuICAgIC8qKlxuICAgIEEgbGluZSBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgICovXG4gICAgbGluZUNvbW1lbnQ6IHQoY29tbWVudCksXG4gICAgLyoqXG4gICAgQSBibG9jayBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgICovXG4gICAgYmxvY2tDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8qKlxuICAgIEEgZG9jdW1lbnRhdGlvbiBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgICovXG4gICAgZG9jQ29tbWVudDogdChjb21tZW50KSxcbiAgICAvKipcbiAgICBBbnkga2luZCBvZiBpZGVudGlmaWVyLlxuICAgICovXG4gICAgbmFtZSxcbiAgICAvKipcbiAgICBUaGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSBvZiBhIHZhcmlhYmxlLlxuICAgICovXG4gICAgdmFyaWFibGVOYW1lOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIEEgdHlwZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgICovXG4gICAgdHlwZU5hbWU6IHR5cGVOYW1lLFxuICAgIC8qKlxuICAgIEEgdGFnIG5hbWUgKHN1YnRhZyBvZiBbYHR5cGVOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnR5cGVOYW1lKSkuXG4gICAgKi9cbiAgICB0YWdOYW1lOiB0KHR5cGVOYW1lKSxcbiAgICAvKipcbiAgICBBIHByb3BlcnR5IG9yIGZpZWxkIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSxcbiAgICAvKipcbiAgICBBbiBhdHRyaWJ1dGUgbmFtZSAoc3VidGFnIG9mIFtgcHJvcGVydHlOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSkpLlxuICAgICovXG4gICAgYXR0cmlidXRlTmFtZTogdChwcm9wZXJ0eU5hbWUpLFxuICAgIC8qKlxuICAgIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgY2xhc3MuXG4gICAgKi9cbiAgICBjbGFzc05hbWU6IHQobmFtZSksXG4gICAgLyoqXG4gICAgQSBsYWJlbCBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgICovXG4gICAgbGFiZWxOYW1lOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIEEgbmFtZXNwYWNlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICBuYW1lc3BhY2U6IHQobmFtZSksXG4gICAgLyoqXG4gICAgVGhlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSBtYWNyby5cbiAgICAqL1xuICAgIG1hY3JvTmFtZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBBIGxpdGVyYWwgdmFsdWUuXG4gICAgKi9cbiAgICBsaXRlcmFsLFxuICAgIC8qKlxuICAgIEEgc3RyaW5nIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICBzdHJpbmcsXG4gICAgLyoqXG4gICAgQSBkb2N1bWVudGF0aW9uIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpLlxuICAgICovXG4gICAgZG9jU3RyaW5nOiB0KHN0cmluZyksXG4gICAgLyoqXG4gICAgQSBjaGFyYWN0ZXIgbGl0ZXJhbCAoc3VidGFnIG9mIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpKS5cbiAgICAqL1xuICAgIGNoYXJhY3RlcjogdChzdHJpbmcpLFxuICAgIC8qKlxuICAgIEFuIGF0dHJpYnV0ZSB2YWx1ZSAoc3VidGFnIG9mIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpKS5cbiAgICAqL1xuICAgIGF0dHJpYnV0ZVZhbHVlOiB0KHN0cmluZyksXG4gICAgLyoqXG4gICAgQSBudW1iZXIgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIG51bWJlcixcbiAgICAvKipcbiAgICBBbiBpbnRlZ2VyIFtudW1iZXJdKCNoaWdobGlnaHQudGFncy5udW1iZXIpIGxpdGVyYWwuXG4gICAgKi9cbiAgICBpbnRlZ2VyOiB0KG51bWJlciksXG4gICAgLyoqXG4gICAgQSBmbG9hdGluZy1wb2ludCBbbnVtYmVyXSgjaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKSBsaXRlcmFsLlxuICAgICovXG4gICAgZmxvYXQ6IHQobnVtYmVyKSxcbiAgICAvKipcbiAgICBBIGJvb2xlYW4gW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIGJvb2w6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgUmVndWxhciBleHByZXNzaW9uIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICByZWdleHA6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQW4gZXNjYXBlIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCksIGZvciBleGFtcGxlIGFcbiAgICBiYWNrc2xhc2ggZXNjYXBlIGluIGEgc3RyaW5nLlxuICAgICovXG4gICAgZXNjYXBlOiB0KGxpdGVyYWwpLFxuICAgIC8qKlxuICAgIEEgY29sb3IgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIGNvbG9yOiB0KGxpdGVyYWwpLFxuICAgIC8qKlxuICAgIEEgVVJMIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICB1cmw6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQSBsYW5ndWFnZSBrZXl3b3JkLlxuICAgICovXG4gICAga2V5d29yZCxcbiAgICAvKipcbiAgICBUaGUgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBmb3IgdGhlIHNlbGYgb3IgdGhpc1xuICAgIG9iamVjdC5cbiAgICAqL1xuICAgIHNlbGY6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgVGhlIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgZm9yIG51bGwuXG4gICAgKi9cbiAgICBudWxsOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBkZW5vdGluZyBzb21lIGF0b21pYyB2YWx1ZS5cbiAgICAqL1xuICAgIGF0b206IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgcmVwcmVzZW50cyBhIHVuaXQuXG4gICAgKi9cbiAgICB1bml0OiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgbW9kaWZpZXIgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKS5cbiAgICAqL1xuICAgIG1vZGlmaWVyOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IGFjdHMgYXMgYW4gb3BlcmF0b3IuXG4gICAgKi9cbiAgICBvcGVyYXRvcktleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBjb250cm9sLWZsb3cgcmVsYXRlZCBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpLlxuICAgICovXG4gICAgY29udHJvbEtleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgZGVmaW5lcyBzb21ldGhpbmcuXG4gICAgKi9cbiAgICBkZWZpbml0aW9uS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgcmVsYXRlZCB0byBkZWZpbmluZyBvclxuICAgIGludGVyZmFjaW5nIHdpdGggbW9kdWxlcy5cbiAgICAqL1xuICAgIG1vZHVsZUtleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQW4gb3BlcmF0b3IuXG4gICAgKi9cbiAgICBvcGVyYXRvcixcbiAgICAvKipcbiAgICBBbiBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCBkZXJlZmVyZW5jZXMgc29tZXRoaW5nLlxuICAgICovXG4gICAgZGVyZWZPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgQXJpdGhtZXRpYy1yZWxhdGVkIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGFyaXRobWV0aWNPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgTG9naWNhbCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICBsb2dpY09wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBCaXQgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgYml0d2lzZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBDb21wYXJpc29uIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGNvbXBhcmVPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgW09wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpIHRoYXQgdXBkYXRlcyBpdHMgb3BlcmFuZC5cbiAgICAqL1xuICAgIHVwZGF0ZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBbT3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCBkZWZpbmVzIHNvbWV0aGluZy5cbiAgICAqL1xuICAgIGRlZmluaXRpb25PcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgVHlwZS1yZWxhdGVkIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIHR5cGVPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgQ29udHJvbC1mbG93IFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGNvbnRyb2xPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgUHJvZ3JhbSBvciBtYXJrdXAgcHVuY3R1YXRpb24uXG4gICAgKi9cbiAgICBwdW5jdHVhdGlvbixcbiAgICAvKipcbiAgICBbUHVuY3R1YXRpb25dKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbikgdGhhdCBzZXBhcmF0ZXNcbiAgICB0aGluZ3MuXG4gICAgKi9cbiAgICBzZXBhcmF0b3I6IHQocHVuY3R1YXRpb24pLFxuICAgIC8qKlxuICAgIEJyYWNrZXQtc3R5bGUgW3B1bmN0dWF0aW9uXSgjaGlnaGxpZ2h0LnRhZ3MucHVuY3R1YXRpb24pLlxuICAgICovXG4gICAgYnJhY2tldCxcbiAgICAvKipcbiAgICBBbmdsZSBbYnJhY2tldHNdKCNoaWdobGlnaHQudGFncy5icmFja2V0KSAodXN1YWxseSBgPGAgYW5kIGA+YFxuICAgIHRva2VucykuXG4gICAgKi9cbiAgICBhbmdsZUJyYWNrZXQ6IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgU3F1YXJlIFticmFja2V0c10oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpICh1c3VhbGx5IGBbYCBhbmQgYF1gXG4gICAgdG9rZW5zKS5cbiAgICAqL1xuICAgIHNxdWFyZUJyYWNrZXQ6IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgUGFyZW50aGVzZXMgKHVzdWFsbHkgYChgIGFuZCBgKWAgdG9rZW5zKS4gU3VidGFnIG9mXG4gICAgW2JyYWNrZXRdKCNoaWdobGlnaHQudGFncy5icmFja2V0KS5cbiAgICAqL1xuICAgIHBhcmVuOiB0KGJyYWNrZXQpLFxuICAgIC8qKlxuICAgIEJyYWNlcyAodXN1YWxseSBge2AgYW5kIGB9YCB0b2tlbnMpLiBTdWJ0YWcgb2ZcbiAgICBbYnJhY2tldF0oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpLlxuICAgICovXG4gICAgYnJhY2U6IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgQ29udGVudCwgZm9yIGV4YW1wbGUgcGxhaW4gdGV4dCBpbiBYTUwgb3IgbWFya3VwIGRvY3VtZW50cy5cbiAgICAqL1xuICAgIGNvbnRlbnQsXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IHJlcHJlc2VudHMgYSBoZWFkaW5nLlxuICAgICovXG4gICAgaGVhZGluZyxcbiAgICAvKipcbiAgICBBIGxldmVsIDEgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmcxOiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgMiBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzI6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCAzIFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nMzogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDQgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmc0OiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgNSBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzU6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCA2IFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nNjogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIHByb3NlIHNlcGFyYXRvciAoc3VjaCBhcyBhIGhvcml6b250YWwgcnVsZSkuXG4gICAgKi9cbiAgICBjb250ZW50U2VwYXJhdG9yOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgbGlzdC5cbiAgICAqL1xuICAgIGxpc3Q6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IHJlcHJlc2VudHMgYSBxdW90ZS5cbiAgICAqL1xuICAgIHF1b3RlOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBlbXBoYXNpemVkLlxuICAgICovXG4gICAgZW1waGFzaXM6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHN0eWxlZCBzdHJvbmcuXG4gICAgKi9cbiAgICBzdHJvbmc6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHBhcnQgb2YgYSBsaW5rLlxuICAgICovXG4gICAgbGluazogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgc3R5bGVkIGFzIGNvZGUgb3JcbiAgICBtb25vc3BhY2UuXG4gICAgKi9cbiAgICBtb25vc3BhY2U6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGhhcyBhIHN0cmlrZS10aHJvdWdoXG4gICAgc3R5bGUuXG4gICAgKi9cbiAgICBzdHJpa2V0aHJvdWdoOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIEluc2VydGVkIHRleHQgaW4gYSBjaGFuZ2UtdHJhY2tpbmcgZm9ybWF0LlxuICAgICovXG4gICAgaW5zZXJ0ZWQ6IHQoKSxcbiAgICAvKipcbiAgICBEZWxldGVkIHRleHQuXG4gICAgKi9cbiAgICBkZWxldGVkOiB0KCksXG4gICAgLyoqXG4gICAgQ2hhbmdlZCB0ZXh0LlxuICAgICovXG4gICAgY2hhbmdlZDogdCgpLFxuICAgIC8qKlxuICAgIEFuIGludmFsaWQgb3IgdW5zeW50YWN0aWMgZWxlbWVudC5cbiAgICAqL1xuICAgIGludmFsaWQ6IHQoKSxcbiAgICAvKipcbiAgICBNZXRhZGF0YSBvciBtZXRhLWluc3RydWN0aW9uLlxuICAgICovXG4gICAgbWV0YSxcbiAgICAvKipcbiAgICBbTWV0YWRhdGFdKCNoaWdobGlnaHQudGFncy5tZXRhKSB0aGF0IGFwcGxpZXMgdG8gdGhlIGVudGlyZVxuICAgIGRvY3VtZW50LlxuICAgICovXG4gICAgZG9jdW1lbnRNZXRhOiB0KG1ldGEpLFxuICAgIC8qKlxuICAgIFtNZXRhZGF0YV0oI2hpZ2hsaWdodC50YWdzLm1ldGEpIHRoYXQgYW5ub3RhdGVzIG9yIGFkZHNcbiAgICBhdHRyaWJ1dGVzIHRvIGEgZ2l2ZW4gc3ludGFjdGljIGVsZW1lbnQuXG4gICAgKi9cbiAgICBhbm5vdGF0aW9uOiB0KG1ldGEpLFxuICAgIC8qKlxuICAgIFByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gb3IgcHJlcHJvY2Vzc29yIGRpcmVjdGl2ZS4gU3VidGFnIG9mXG4gICAgW21ldGFdKCNoaWdobGlnaHQudGFncy5tZXRhKS5cbiAgICAqL1xuICAgIHByb2Nlc3NpbmdJbnN0cnVjdGlvbjogdChtZXRhKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGluZGljYXRlcyB0aGF0IGFcbiAgICBnaXZlbiBlbGVtZW50IGlzIGJlaW5nIGRlZmluZWQuIEV4cGVjdGVkIHRvIGJlIHVzZWQgd2l0aCB0aGVcbiAgICB2YXJpb3VzIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgdGFncy5cbiAgICAqL1xuICAgIGRlZmluaXRpb246IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIHRoYXRcbiAgICBzb21ldGhpbmcgaXMgY29uc3RhbnQuIE1vc3RseSBleHBlY3RlZCB0byBiZSB1c2VkIHdpdGhcbiAgICBbdmFyaWFibGUgbmFtZXNdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpLlxuICAgICovXG4gICAgY29uc3RhbnQ6IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHVzZWQgdG8gaW5kaWNhdGUgdGhhdFxuICAgIGEgW3ZhcmlhYmxlXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKSBvciBbcHJvcGVydHlcbiAgICBuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKSBpcyBiZWluZyBjYWxsZWQgb3IgZGVmaW5lZFxuICAgIGFzIGEgZnVuY3Rpb24uXG4gICAgKi9cbiAgICBmdW5jdGlvbjogVGFnLmRlZmluZU1vZGlmaWVyKCksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBjYW4gYmUgYXBwbGllZCB0b1xuICAgIFtuYW1lc10oI2hpZ2hsaWdodC50YWdzLm5hbWUpIHRvIGluZGljYXRlIHRoYXQgdGhleSBiZWxvbmcgdG9cbiAgICB0aGUgbGFuZ3VhZ2UncyBzdGFuZGFyZCBlbnZpcm9ubWVudC5cbiAgICAqL1xuICAgIHN0YW5kYXJkOiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGluZGljYXRlcyBhIGdpdmVuXG4gICAgW25hbWVzXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgaXMgbG9jYWwgdG8gc29tZSBzY29wZS5cbiAgICAqL1xuICAgIGxvY2FsOiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvKipcbiAgICBBIGdlbmVyaWMgdmFyaWFudCBbbW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0XG4gICAgY2FuIGJlIHVzZWQgdG8gdGFnIGxhbmd1YWdlLXNwZWNpZmljIGFsdGVybmF0aXZlIHZhcmlhbnRzIG9mXG4gICAgc29tZSBjb21tb24gdGFnLiBJdCBpcyByZWNvbW1lbmRlZCBmb3IgdGhlbWVzIHRvIGRlZmluZSBzcGVjaWFsXG4gICAgZm9ybXMgb2YgYXQgbGVhc3QgdGhlIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpIGFuZFxuICAgIFt2YXJpYWJsZSBuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKSB0YWdzLCBzaW5jZSB0aG9zZVxuICAgIGNvbWUgdXAgYSBsb3QuXG4gICAgKi9cbiAgICBzcGVjaWFsOiBUYWcuZGVmaW5lTW9kaWZpZXIoKVxufTtcbi8qKlxuVGhpcyBpcyBhIGhpZ2hsaWdodGVyIHRoYXQgYWRkcyBzdGFibGUsIHByZWRpY3RhYmxlIGNsYXNzZXMgdG9cbnRva2VucywgZm9yIHN0eWxpbmcgd2l0aCBleHRlcm5hbCBDU1MuXG5cblRoZSBmb2xsb3dpbmcgdGFncyBhcmUgbWFwcGVkIHRvIHRoZWlyIG5hbWUgcHJlZml4ZWQgd2l0aCBgXCJ0b2stXCJgXG4oZm9yIGV4YW1wbGUgYFwidG9rLWNvbW1lbnRcImApOlxuXG4qIFtgbGlua2BdKCNoaWdobGlnaHQudGFncy5saW5rKVxuKiBbYGhlYWRpbmdgXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZylcbiogW2BlbXBoYXNpc2BdKCNoaWdobGlnaHQudGFncy5lbXBoYXNpcylcbiogW2BzdHJvbmdgXSgjaGlnaGxpZ2h0LnRhZ3Muc3Ryb25nKVxuKiBbYGtleXdvcmRgXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZClcbiogW2BhdG9tYF0oI2hpZ2hsaWdodC50YWdzLmF0b20pXG4qIFtgYm9vbGBdKCNoaWdobGlnaHQudGFncy5ib29sKVxuKiBbYHVybGBdKCNoaWdobGlnaHQudGFncy51cmwpXG4qIFtgbGFiZWxOYW1lYF0oI2hpZ2hsaWdodC50YWdzLmxhYmVsTmFtZSlcbiogW2BpbnNlcnRlZGBdKCNoaWdobGlnaHQudGFncy5pbnNlcnRlZClcbiogW2BkZWxldGVkYF0oI2hpZ2hsaWdodC50YWdzLmRlbGV0ZWQpXG4qIFtgbGl0ZXJhbGBdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKVxuKiBbYHN0cmluZ2BdKCNoaWdobGlnaHQudGFncy5zdHJpbmcpXG4qIFtgbnVtYmVyYF0oI2hpZ2hsaWdodC50YWdzLm51bWJlcilcbiogW2B2YXJpYWJsZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuKiBbYHR5cGVOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnR5cGVOYW1lKVxuKiBbYG5hbWVzcGFjZWBdKCNoaWdobGlnaHQudGFncy5uYW1lc3BhY2UpXG4qIFtgY2xhc3NOYW1lYF0oI2hpZ2hsaWdodC50YWdzLmNsYXNzTmFtZSlcbiogW2BtYWNyb05hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MubWFjcm9OYW1lKVxuKiBbYHByb3BlcnR5TmFtZWBdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpXG4qIFtgb3BlcmF0b3JgXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpXG4qIFtgY29tbWVudGBdKCNoaWdobGlnaHQudGFncy5jb21tZW50KVxuKiBbYG1ldGFgXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSlcbiogW2BwdW5jdHVhdGlvbmBdKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbilcbiogW2BpbnZhbGlkYF0oI2hpZ2hsaWdodC50YWdzLmludmFsaWQpXG5cbkluIGFkZGl0aW9uLCB0aGVzZSBtYXBwaW5ncyBhcmUgcHJvdmlkZWQ6XG5cbiogW2ByZWdleHBgXSgjaGlnaGxpZ2h0LnRhZ3MucmVnZXhwKSxcbiAgW2Blc2NhcGVgXSgjaGlnaGxpZ2h0LnRhZ3MuZXNjYXBlKSwgYW5kXG4gIFtgc3BlY2lhbGBdKCNoaWdobGlnaHQudGFncy5zcGVjaWFsKVtgKHN0cmluZylgXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKVxuICBhcmUgbWFwcGVkIHRvIGBcInRvay1zdHJpbmcyXCJgXG4qIFtgc3BlY2lhbGBdKCNoaWdobGlnaHQudGFncy5zcGVjaWFsKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuICB0byBgXCJ0b2stdmFyaWFibGVOYW1lMlwiYFxuKiBbYGxvY2FsYF0oI2hpZ2hsaWdodC50YWdzLmxvY2FsKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuICB0byBgXCJ0b2stdmFyaWFibGVOYW1lIHRvay1sb2NhbFwiYFxuKiBbYGRlZmluaXRpb25gXSgjaGlnaGxpZ2h0LnRhZ3MuZGVmaW5pdGlvbilbYCh2YXJpYWJsZU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSlcbiAgdG8gYFwidG9rLXZhcmlhYmxlTmFtZSB0b2stZGVmaW5pdGlvblwiYFxuKiBbYGRlZmluaXRpb25gXSgjaGlnaGxpZ2h0LnRhZ3MuZGVmaW5pdGlvbilbYChwcm9wZXJ0eU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSlcbiAgdG8gYFwidG9rLXByb3BlcnR5TmFtZSB0b2stZGVmaW5pdGlvblwiYFxuKi9cbmNvbnN0IGNsYXNzSGlnaGxpZ2h0ZXIgPSB0YWdIaWdobGlnaHRlcihbXG4gICAgeyB0YWc6IHRhZ3MubGluaywgY2xhc3M6IFwidG9rLWxpbmtcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmhlYWRpbmcsIGNsYXNzOiBcInRvay1oZWFkaW5nXCIgfSxcbiAgICB7IHRhZzogdGFncy5lbXBoYXNpcywgY2xhc3M6IFwidG9rLWVtcGhhc2lzXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJvbmcsIGNsYXNzOiBcInRvay1zdHJvbmdcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmtleXdvcmQsIGNsYXNzOiBcInRvay1rZXl3b3JkXCIgfSxcbiAgICB7IHRhZzogdGFncy5hdG9tLCBjbGFzczogXCJ0b2stYXRvbVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuYm9vbCwgY2xhc3M6IFwidG9rLWJvb2xcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnVybCwgY2xhc3M6IFwidG9rLXVybFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubGFiZWxOYW1lLCBjbGFzczogXCJ0b2stbGFiZWxOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5pbnNlcnRlZCwgY2xhc3M6IFwidG9rLWluc2VydGVkXCIgfSxcbiAgICB7IHRhZzogdGFncy5kZWxldGVkLCBjbGFzczogXCJ0b2stZGVsZXRlZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubGl0ZXJhbCwgY2xhc3M6IFwidG9rLWxpdGVyYWxcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cmluZywgY2xhc3M6IFwidG9rLXN0cmluZ1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MubnVtYmVyLCBjbGFzczogXCJ0b2stbnVtYmVyXCIgfSxcbiAgICB7IHRhZzogW3RhZ3MucmVnZXhwLCB0YWdzLmVzY2FwZSwgdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKV0sIGNsYXNzOiBcInRvay1zdHJpbmcyXCIgfSxcbiAgICB7IHRhZzogdGFncy52YXJpYWJsZU5hbWUsIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxvY2FsKHRhZ3MudmFyaWFibGVOYW1lKSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZSB0b2stbG9jYWxcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlZmluaXRpb24odGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lIHRvay1kZWZpbml0aW9uXCIgfSxcbiAgICB7IHRhZzogdGFncy5zcGVjaWFsKHRhZ3MudmFyaWFibGVOYW1lKSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZTJcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlZmluaXRpb24odGFncy5wcm9wZXJ0eU5hbWUpLCBjbGFzczogXCJ0b2stcHJvcGVydHlOYW1lIHRvay1kZWZpbml0aW9uXCIgfSxcbiAgICB7IHRhZzogdGFncy50eXBlTmFtZSwgY2xhc3M6IFwidG9rLXR5cGVOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5uYW1lc3BhY2UsIGNsYXNzOiBcInRvay1uYW1lc3BhY2VcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmNsYXNzTmFtZSwgY2xhc3M6IFwidG9rLWNsYXNzTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubWFjcm9OYW1lLCBjbGFzczogXCJ0b2stbWFjcm9OYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5wcm9wZXJ0eU5hbWUsIGNsYXNzOiBcInRvay1wcm9wZXJ0eU5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm9wZXJhdG9yLCBjbGFzczogXCJ0b2stb3BlcmF0b3JcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmNvbW1lbnQsIGNsYXNzOiBcInRvay1jb21tZW50XCIgfSxcbiAgICB7IHRhZzogdGFncy5tZXRhLCBjbGFzczogXCJ0b2stbWV0YVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW52YWxpZCwgY2xhc3M6IFwidG9rLWludmFsaWRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnB1bmN0dWF0aW9uLCBjbGFzczogXCJ0b2stcHVuY3R1YXRpb25cIiB9XG5dKTtcblxuZXhwb3J0IHsgVGFnLCBjbGFzc0hpZ2hsaWdodGVyLCBnZXRTdHlsZVRhZ3MsIGhpZ2hsaWdodFRyZWUsIHN0eWxlVGFncywgdGFnSGlnaGxpZ2h0ZXIsIHRhZ3MgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/highlight/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/javascript/dist/index.es.js":
/*!*********************************************************!*\
  !*** ./node_modules/@lezer/javascript/dist/index.es.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parser: () => (/* binding */ parser)\n/* harmony export */ });\n/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/lr */ \"(ssr)/./node_modules/@lezer/lr/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/./node_modules/@lezer/highlight/dist/index.js\");\n\n\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst noSemi = 302,\n  incdec = 1,\n  incdecPrefix = 2,\n  insertSemi = 303,\n  spaces = 305,\n  newline = 306,\n  LineComment = 3,\n  BlockComment = 4;\n\n/* Hand-written tokenizers for JavaScript tokens that can't be\n   expressed by lezer's built-in tokenizer. */\n\nconst space = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200,\n               8201, 8202, 8232, 8233, 8239, 8287, 12288];\n\nconst braceR = 125, semicolon = 59, slash = 47, star = 42,\n      plus = 43, minus = 45;\n\nconst trackNewline = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ContextTracker({\n  start: false,\n  shift(context, term) {\n    return term == LineComment || term == BlockComment || term == spaces ? context : term == newline\n  },\n  strict: false\n});\n\nconst insertSemicolon = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  let {next} = input;\n  if ((next == braceR || next == -1 || stack.context) && stack.canShift(insertSemi))\n    input.acceptToken(insertSemi);\n}, {contextual: true, fallback: true});\n\nconst noSemicolon = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  let {next} = input, after;\n  if (space.indexOf(next) > -1) return\n  if (next == slash && ((after = input.peek(1)) == slash || after == star)) return\n  if (next != braceR && next != semicolon && next != -1 && !stack.context && stack.canShift(noSemi))\n    input.acceptToken(noSemi);\n}, {contextual: true});\n\nconst incdecToken = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  let {next} = input;\n  if (next == plus || next == minus) {\n    input.advance();\n    if (next == input.next) {\n      input.advance();\n      let mayPostfix = !stack.context && stack.canShift(incdec);\n      input.acceptToken(mayPostfix ? incdec : incdecPrefix);\n    }\n  }\n}, {contextual: true});\n\nconst jsHighlight = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({\n  \"get set async static\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n  \"for while do if else switch try catch finally return throw break continue default case\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.controlKeyword,\n  \"in of await yield void typeof delete instanceof\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.operatorKeyword,\n  \"let var const function class extends\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionKeyword,\n  \"import export from\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.moduleKeyword,\n  \"with debugger as new\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\n  TemplateString: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string),\n  super: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.atom,\n  BooleanLiteral: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bool,\n  this: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.self,\n  null: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.null,\n  Star: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n  VariableName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName,\n  \"CallExpression/VariableName TaggedTemplateExpression/VariableName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n  VariableDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n  Label: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName,\n  PropertyName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName,\n  PrivatePropertyName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n  \"CallExpression/MemberExpression/PropertyName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n  \"FunctionDeclaration/VariableDefinition\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName)),\n  \"ClassDeclaration/VariableDefinition\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className),\n  PropertyDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n  PrivatePropertyDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName)),\n  UpdateOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.updateOperator,\n  LineComment: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.lineComment,\n  BlockComment: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.blockComment,\n  Number: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.number,\n  String: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string,\n  Escape: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.escape,\n  ArithOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.arithmeticOperator,\n  LogicOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.logicOperator,\n  BitOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bitwiseOperator,\n  CompareOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.compareOperator,\n  RegExp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.regexp,\n  Equals: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionOperator,\n  Arrow: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.punctuation),\n  \": Spread\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.punctuation,\n  \"( )\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.paren,\n  \"[ ]\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.squareBracket,\n  \"{ }\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.brace,\n  \"InterpolationStart InterpolationEnd\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.brace),\n  \".\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.derefOperator,\n  \", ;\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.separator,\n  \"@\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.meta,\n\n  TypeName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName,\n  TypeDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName),\n  \"type enum interface implements namespace module declare\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionKeyword,\n  \"abstract global Privacy readonly override\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n  \"is keyof unique infer\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.operatorKeyword,\n\n  JSXAttributeValue: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeValue,\n  JSXText: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.content,\n  \"JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.angleBracket,\n  \"JSXIdentifier JSXNameSpacedName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName,\n  \"JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeName,\n  \"JSXBuiltin/JSXIdentifier\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.standard(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName)\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst spec_identifier = {__proto__:null,export:14, as:19, from:27, default:30, async:35, function:36, extends:46, this:50, true:58, false:58, null:70, void:74, typeof:78, super:96, new:130, delete:146, yield:155, await:159, class:164, public:221, private:221, protected:221, readonly:223, instanceof:242, satisfies:245, in:246, const:248, import:280, keyof:335, unique:339, infer:345, is:381, abstract:401, implements:403, type:405, let:408, var:410, interface:417, enum:421, namespace:427, module:429, declare:433, global:437, for:456, of:465, while:468, with:472, do:476, if:480, else:482, switch:486, case:492, try:498, catch:502, finally:506, return:510, throw:514, break:518, continue:522, debugger:526};\nconst spec_word = {__proto__:null,async:117, get:119, set:121, declare:181, public:183, private:183, protected:183, static:185, abstract:187, override:189, readonly:195, accessor:197, new:385};\nconst spec_LessThan = {__proto__:null,\"<\":137};\nconst parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({\n  version: 14,\n  states: \"$6[O`QUOOO%QQUOOO'TQWOOP(bOSOOO*pQ(CjO'#CfO*wOpO'#CgO+VO!bO'#CgO+eO07`O'#DZO-vQUO'#DaO.WQUO'#DlO%QQUO'#DvO0[QUO'#EOOOQ(CY'#EW'#EWO0uQSO'#ETOOQO'#Ei'#EiOOQO'#Ib'#IbO0}QSO'#GkO1YQSO'#EhO1_QSO'#EhO3aQ(CjO'#JcO6QQ(CjO'#JdO6nQSO'#FWO6sQ#tO'#FoOOQ(CY'#F`'#F`O7OO&jO'#F`O7^Q,UO'#FvO8tQSO'#FuOOQ(CY'#Jd'#JdOOQ(CW'#Jc'#JcOOQQ'#KO'#KOO8yQSO'#IOO9OQ(C[O'#IPOOQQ'#JP'#JPOOQQ'#IT'#ITQ`QUOOO%QQUO'#DnO9WQUO'#DzO%QQUO'#D|O9_QSO'#GkO9dQ,UO'#ClO9rQSO'#EgO9}QSO'#ErO:SQ,UO'#F_O:qQSO'#GkO:vQSO'#GoO;RQSO'#GoO;aQSO'#GrO;aQSO'#GsO;aQSO'#GuO9_QSO'#GxO<QQSO'#G{O=cQSO'#CbO=sQSO'#HXO={QSO'#H_O={QSO'#HaO`QUO'#HcO={QSO'#HeO={QSO'#HhO>QQSO'#HnO>VQ(C]O'#HtO%QQUO'#HvO>bQ(C]O'#HxO>mQ(C]O'#HzO9OQ(C[O'#H|O>xQ(CjO'#CfO?zQWO'#DfQOQSOOO@bQSO'#EPO9dQ,UO'#EgO@mQSO'#EgO@xQ`O'#F_OOQQ'#Cd'#CdOOQ(CW'#Dk'#DkOOQ(CW'#Jg'#JgO%QQUO'#JgOOQO'#Jk'#JkOOQO'#I_'#I_OAxQWO'#E`OOQ(CW'#E_'#E_OBtQ(C`O'#E`OCOQWO'#ESOOQO'#Jj'#JjOCdQWO'#JkODqQWO'#ESOCOQWO'#E`PEOO?MpO'#C`POOO)CDn)CDnOOOO'#IU'#IUOEZOpO,59ROOQ(CY,59R,59ROOOO'#IV'#IVOEiO!bO,59RO%QQUO'#D]OOOO'#IX'#IXOEwO07`O,59uOOQ(CY,59u,59uOFVQUO'#IYOFjQSO'#JeOHlQbO'#JeO+sQUO'#JeOHsQSO,59{OIZQSO'#EiOIhQSO'#JsOIsQSO'#JrOIsQSO'#JrOI{QSO,5;VOJQQSO'#JqOOQ(CY,5:W,5:WOJXQUO,5:WOLYQ(CjO,5:bOLyQSO,5:jOMdQ(C[O'#JpOMkQSO'#JoO:vQSO'#JoONPQSO'#JoONXQSO,5;UON^QSO'#JoO!!fQbO'#JdOOQ(CY'#Cf'#CfO%QQUO'#EOO!#UQ`O,5:oOOQO'#Jl'#JlOOQO-E<`-E<`O9_QSO,5=VO!#lQSO,5=VO!#qQUO,5;SO!%tQ,UO'#EdO!'XQSO,5;SO!(qQ,UO'#DpO!(xQUO'#DuO!)SQWO,5;]O!)[QWO,5;]O%QQUO,5;]OOQQ'#FO'#FOOOQQ'#FQ'#FQO%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^OOQQ'#FU'#FUO!)jQUO,5;oOOQ(CY,5;t,5;tOOQ(CY,5;u,5;uO!+mQSO,5;uOOQ(CY,5;v,5;vO%QQUO'#IfO!+uQ(C[O,5<cO!%tQ,UO,5;^O!,dQ,UO,5;^O%QQUO,5;rO!,kQ#tO'#FeO!-hQ#tO'#JwO!-SQ#tO'#JwO!-oQ#tO'#JwOOQO'#Jw'#JwO!.TQ#tO,5;}OOOO,5<Z,5<ZO!.fQUO'#FqOOOO'#Ie'#IeO7OO&jO,5;zO!.mQ#tO'#FsOOQ(CY,5;z,5;zO!/^Q7[O'#CrOOQ(CY'#Cv'#CvO!/qQSO'#CvO!/vO07`O'#CzO!0dQ,UO,5<`O!0kQSO,5<bO!2QQMhO'#GQO!2_QSO'#GRO!2dQSO'#GRO!2iQMhO'#GVO!3hQWO'#GZO!4ZQ7[O'#J^OOQ(CY'#J^'#J^O!4eQSO'#J]O!4sQSO'#J[O!4{QSO'#CqOOQ(CY'#Ct'#CtOOQ(CY'#DO'#DOOOQ(CY'#DQ'#DQO0xQSO'#DSO!'^Q,UO'#FxO!'^Q,UO'#FzO!5TQSO'#F|O!5YQSO'#F}O!2dQSO'#GTO!'^Q,UO'#GYO!5_QSO'#EjO!5|QSO,5<aO`QUO,5>jOOQQ'#JX'#JXOOQQ,5>k,5>kOOQQ-E<R-E<RO!7{Q(CjO,5:YO!:iQ(CjO,5:fO%QQUO,5:fO!=SQ(CjO,5:hOOQ(CW'#Co'#CoO!=sQ,UO,5=VO!>RQ(C[O'#JYO8tQSO'#JYO!>dQ(C[O,59WO!>oQWO,59WO!>wQ,UO,59WO9dQ,UO,59WO!?SQSO,5;SO!?[QSO'#HWO!?mQSO'#KSO%QQUO,5;wO!?uQWO,5;yO!?zQSO,5=qO!@PQSO,5=qO!@UQSO,5=qO9OQ(C[O,5=qO!@dQSO'#EkO!A^QWO'#ElOOQ(CW'#Jq'#JqO!AeQ(C[O'#KPO9OQ(C[O,5=ZO;aQSO,5=aOOQO'#Cr'#CrO!ApQWO,5=^O!AxQ,UO,5=_O!BTQSO,5=aO!BYQ`O,5=dO>QQSO'#G}O9_QSO'#HPO!BbQSO'#HPO9dQ,UO'#HRO!BgQSO'#HROOQQ,5=g,5=gO!BlQSO'#HSO!BtQSO'#ClO!ByQSO,58|O!CTQSO,58|O!E]QUO,58|OOQQ,58|,58|O!EjQ(C[O,58|O%QQUO,58|O!EuQUO'#HZOOQQ'#H['#H[OOQQ'#H]'#H]O`QUO,5=sO!FVQSO,5=sO`QUO,5=yO`QUO,5={O!F[QSO,5=}O`QUO,5>PO!FaQSO,5>SO!FfQUO,5>YOOQQ,5>`,5>`O%QQUO,5>`O9OQ(C[O,5>bOOQQ,5>d,5>dO!JmQSO,5>dOOQQ,5>f,5>fO!JmQSO,5>fOOQQ,5>h,5>hO!JrQWO'#DXO%QQUO'#JgO!KaQWO'#JgO!LOQWO'#DgO!LaQWO'#DgO!NrQUO'#DgO!NyQSO'#JfO# RQSO,5:QO# WQSO'#EmO# fQSO'#JtO# nQSO,5;WO# sQWO'#DgO#!QQWO'#EROOQ(CY,5:k,5:kO%QQUO,5:kO#!XQSO,5:kO>QQSO,5;RO!>oQWO,5;RO!>wQ,UO,5;RO9dQ,UO,5;RO#!aQSO,5@RO#!fQ!LQO,5:oOOQO-E<]-E<]O##lQ(C`O,5:zOCOQWO,5:nO##vQWO,5:nOCOQWO,5:zO!>dQ(C[O,5:nOOQ(CW'#Ec'#EcOOQO,5:z,5:zO%QQUO,5:zO#$TQ(C[O,5:zO#$`Q(C[O,5:zO!>oQWO,5:nOOQO,5;Q,5;QO#$nQ(C[O,5:zPOOO'#IS'#ISP#%SO?MpO,58zPOOO,58z,58zOOOO-E<S-E<SOOQ(CY1G.m1G.mOOOO-E<T-E<TO#%_Q`O,59wOOOO-E<V-E<VOOQ(CY1G/a1G/aO#%dQbO,5>tO+sQUO,5>tOOQO,5>z,5>zO#%nQUO'#IYOOQO-E<W-E<WO#%{QSO,5@PO#&TQbO,5@PO#&[QSO,5@^OOQ(CY1G/g1G/gO%QQUO,5@_O#&dQSO'#I`OOQO-E<^-E<^O#&[QSO,5@^OOQ(CW1G0q1G0qOOQ(CY1G/r1G/rOOQ(CY1G0U1G0UO%QQUO,5@[O#&xQ(C[O,5@[O#'ZQ(C[O,5@[O#'bQSO,5@ZO:vQSO,5@ZO#'jQSO,5@ZO#'xQSO'#IcO#'bQSO,5@ZOOQ(CW1G0p1G0pO!)SQWO,5:qO!)_QWO,5:qOOQO,5:s,5:sO#(jQSO,5:sO#(rQ,UO1G2qO9_QSO1G2qOOQ(CY1G0n1G0nO#)QQ(CjO1G0nO#*VQ(ChO,5;OOOQ(CY'#GP'#GPO#*sQ(CjO'#J^O!#qQUO1G0nO#,{Q,UO'#JhO#-VQSO,5:[O#-[QbO'#JiO%QQUO'#JiO#-fQSO,5:aOOQ(CY'#DX'#DXOOQ(CY1G0w1G0wO%QQUO1G0wOOQ(CY1G1a1G1aO#-kQSO1G0wO#0SQ(CjO1G0xO#0ZQ(CjO1G0xO#2tQ(CjO1G0xO#2{Q(CjO1G0xO#5VQ(CjO1G0xO#5mQ(CjO1G0xO#8gQ(CjO1G0xO#8nQ(CjO1G0xO#;XQ(CjO1G0xO#;`Q(CjO1G0xO#=WQ(CjO1G0xO#@WQ$IUO'#CfO#BUQ$IUO1G1ZO#B]Q$IUO'#JdO!+pQSO1G1aO#BmQ(CjO,5?QOOQ(CW-E<d-E<dO#CaQ(CjO1G0xOOQ(CY1G0x1G0xO#ElQ(CjO1G1^O#F`Q#tO,5<RO#FhQ#tO,5<SO#FpQ#tO'#FjO#GXQSO'#FiOOQO'#Jx'#JxOOQO'#Id'#IdO#G^Q#tO1G1iOOQ(CY1G1i1G1iOOOO1G1t1G1tO#GoQ$IUO'#JcO#GyQSO,5<]O!)jQUO,5<]OOOO-E<c-E<cOOQ(CY1G1f1G1fO#HOQWO'#JwOOQ(CY,5<_,5<_O#HWQWO,5<_OOQ(CY,59b,59bO!%tQ,UO'#C|OOOO'#IW'#IWO#H]O07`O,59fOOQ(CY,59f,59fO%QQUO1G1zO!5YQSO'#IhO#HhQSO,5<sOOQ(CY,5<p,5<pOOQO'#Gf'#GfO!'^Q,UO,5=POOQO'#Gh'#GhO!'^Q,UO,5=RO!%tQ,UO,5=TOOQO1G1|1G1|O#HvQ`O'#CoO#IZQ`O,5<lO#IbQSO'#J{O9_QSO'#J{O#IpQSO,5<nO!'^Q,UO,5<mO#IuQSO'#GSO#JQQSO,5<mO#JVQ`O'#GPO#JdQ`O'#J|O#JnQSO'#J|O!%tQ,UO'#J|O#JsQSO,5<qO#JxQWO'#G[O!3cQWO'#G[O#KZQSO'#G^O#K`QSO'#G`O!2dQSO'#GcO#KeQ(C[O'#IjO#KpQWO,5<uOOQ(CY,5<u,5<uO#KwQWO'#G[O#LVQWO'#G]O#L_QWO'#G]OOQ(CY,5=U,5=UO!'^Q,UO,5?wO!'^Q,UO,5?wO#LdQSO'#IkO#LoQSO,5?vO#LwQSO,59]O#MhQ,UO,59nOOQ(CY,59n,59nO#NZQ,UO,5<dO#N|Q,UO,5<fO?rQSO,5<hOOQ(CY,5<i,5<iO$ WQSO,5<oO$ ]Q,UO,5<tO$ mQSO'#JoO!#qQUO1G1{O$ rQSO1G1{OOQQ1G4U1G4UOOQ(CY1G/t1G/tO!+mQSO1G/tO$#qQ(CjO1G0QOOQQ1G2q1G2qO!%tQ,UO1G2qO%QQUO1G2qO$$bQSO1G2qO$$mQ,UO'#EdOOQ(CW,5?t,5?tO$$wQ(C[O,5?tOOQQ1G.r1G.rO!>dQ(C[O1G.rO!>oQWO1G.rO!>wQ,UO1G.rO$%YQSO1G0nO$%_QSO'#CfO$%jQSO'#KTO$%rQSO,5=rO$%wQSO'#KTO$%|QSO'#KTO$&XQSO'#IsO$&gQSO,5@nO$&oQbO1G1cOOQ(CY1G1e1G1eO9_QSO1G3]O?rQSO1G3]O$&vQSO1G3]O$&{QSO1G3]OOQQ1G3]1G3]O:vQSO'#JrO:vQSO'#EmO%QQUO'#EmO:vQSO'#ImO$'QQ(C[O,5@kOOQQ1G2u1G2uO!BTQSO1G2{O!%tQ,UO1G2xO$']QSO1G2xOOQQ1G2y1G2yO!%tQ,UO1G2yO$'bQSO1G2yO$'jQWO'#GwOOQQ1G2{1G2{O!3cQWO'#IoO!BYQ`O1G3OOOQQ1G3O1G3OOOQQ,5=i,5=iO$'rQ,UO,5=kO9_QSO,5=kO#K`QSO,5=mO8tQSO,5=mO!>oQWO,5=mO!>wQ,UO,5=mO9dQ,UO,5=mO$(QQSO'#KRO$(]QSO,5=nOOQQ1G.h1G.hO$(bQ(C[O1G.hO?rQSO1G.hO$(mQSO1G.hO9OQ(C[O1G.hO$*rQbO,5@pO$+SQSO,5@pO$+_QUO,5=uO$+fQSO,5=uO:vQSO,5@pOOQQ1G3_1G3_O`QUO1G3_OOQQ1G3e1G3eOOQQ1G3g1G3gO={QSO1G3iO$+kQUO1G3kO$/lQUO'#HjOOQQ1G3n1G3nO$/yQSO'#HpO>QQSO'#HrOOQQ1G3t1G3tO$0RQUO1G3tO9OQ(C[O1G3zOOQQ1G3|1G3|OOQ(CW'#GW'#GWO9OQ(C[O1G4OO9OQ(C[O1G4QO$4VQSO,5@RO!)jQUO,5;XO:vQSO,5;XO>QQSO,5:RO!)jQUO,5:RO!>oQWO,5:RO$4[Q$IUO,5:ROOQO,5;X,5;XO$4fQWO'#IZO$4|QSO,5@QOOQ(CY1G/l1G/lO$5UQWO'#IaO$5`QSO,5@`OOQ(CW1G0r1G0rO!LaQWO,5:ROOQO'#I^'#I^O$5hQWO,5:mOOQ(CY,5:m,5:mO#![QSO1G0VOOQ(CY1G0V1G0VO%QQUO1G0VOOQ(CY1G0m1G0mO>QQSO1G0mO!>oQWO1G0mO!>wQ,UO1G0mOOQ(CW1G5m1G5mO!>dQ(C[O1G0YOOQO1G0f1G0fO%QQUO1G0fO$5oQ(C[O1G0fO$5zQ(C[O1G0fO!>oQWO1G0YOCOQWO1G0YO$6YQ(C[O1G0fOOQO1G0Y1G0YO$6nQ(CjO1G0fPOOO-E<Q-E<QPOOO1G.f1G.fOOOO1G/c1G/cO$6xQ`O,5<cO$7QQbO1G4`OOQO1G4f1G4fO%QQUO,5>tO$7[QSO1G5kO$7dQSO1G5xO$7lQbO1G5yO:vQSO,5>zO$7vQ(CjO1G5vO%QQUO1G5vO$8WQ(C[O1G5vO$8iQSO1G5uO$8iQSO1G5uO:vQSO1G5uO$8qQSO,5>}O:vQSO,5>}OOQO,5>},5>}O$9VQSO,5>}O$ mQSO,5>}OOQO-E<a-E<aOOQO1G0]1G0]OOQO1G0_1G0_O!+pQSO1G0_OOQQ7+(]7+(]O!%tQ,UO7+(]O%QQUO7+(]O$9eQSO7+(]O$9pQ,UO7+(]O$:OQ(CjO,59nO$<WQ(CjO,5<dO$>cQ(CjO,5<fO$@nQ(CjO,5<tOOQ(CY7+&Y7+&YO$CPQ(CjO7+&YO$CsQ,UO'#I[O$C}QSO,5@SOOQ(CY1G/v1G/vO$DVQUO'#I]O$DdQSO,5@TO$DlQbO,5@TOOQ(CY1G/{1G/{O$DvQSO7+&cOOQ(CY7+&c7+&cO$D{Q$IUO,5:bO%QQUO7+&uO$EVQ$IUO,5:YO$EdQ$IUO,5:fO$EnQ$IUO,5:hOOQ(CY7+&{7+&{OOQO1G1m1G1mOOQO1G1n1G1nO$ExQ#tO,5<UO!)jQUO,5<TOOQO-E<b-E<bOOQ(CY7+'T7+'TOOOO7+'`7+'`OOOO1G1w1G1wO$FTQSO1G1wOOQ(CY1G1y1G1yO$FYQ`O,59hOOOO-E<U-E<UOOQ(CY1G/Q1G/QO$FaQ(CjO7+'fOOQ(CY,5?S,5?SO$GTQSO,5?SOOQ(CY1G2_1G2_P$GYQSO'#IhPOQ(CY-E<f-E<fO$G|Q,UO1G2kO$HoQ,UO1G2mO$HyQ`O1G2oOOQ(CY1G2W1G2WO$IQQSO'#IgO$I`QSO,5@gO$I`QSO,5@gO$IhQSO,5@gO$IsQSO,5@gOOQO1G2Y1G2YO$JRQ,UO1G2XO!'^Q,UO1G2XO$JcQMhO'#IiO$JsQSO,5@hO!%tQ,UO,5@hO$J{Q`O,5@hOOQ(CY1G2]1G2]OOQ(CW,5<v,5<vOOQ(CW,5<w,5<wO$ mQSO,5<wOBoQSO,5<wO!>oQWO,5<vOOQO'#G_'#G_O$KVQSO,5<xOOQ(CW,5<z,5<zO$ mQSO,5<}OOQO,5?U,5?UOOQO-E<h-E<hOOQ(CY1G2a1G2aO!3cQWO,5<vO$K_QSO,5<wO#KZQSO,5<xO!3cQWO,5<wO$KjQ,UO1G5cO$KtQ,UO1G5cOOQO,5?V,5?VOOQO-E<i-E<iOOQO1G.w1G.wO!?uQWO,59pO%QQUO,59pO$LRQSO1G2SO!'^Q,UO1G2ZO$LWQ(CjO7+'gOOQ(CY7+'g7+'gO!#qQUO7+'gOOQ(CY7+%`7+%`O$LzQ`O'#J}O#![QSO7+(]O$MUQbO7+(]O$9hQSO7+(]O$M]Q(ChO'#CfO$MpQ(ChO,5<{O$NbQSO,5<{OOQ(CW1G5`1G5`OOQQ7+$^7+$^O!>dQ(C[O7+$^O!>oQWO7+$^O!#qQUO7+&YO$NgQSO'#IrO$N{QSO,5@oOOQO1G3^1G3^O9_QSO,5@oO$N{QSO,5@oO% TQSO,5@oOOQO,5?_,5?_OOQO-E<q-E<qOOQ(CY7+&}7+&}O% YQSO7+(wO9OQ(C[O7+(wO9_QSO7+(wO?rQSO7+(wO% _QSO,5;XOOQ(CW,5?X,5?XOOQ(CW-E<k-E<kOOQQ7+(g7+(gO% dQ(ChO7+(dO!%tQ,UO7+(dO% nQ`O7+(eOOQQ7+(e7+(eO!%tQ,UO7+(eO% uQSO'#KQO%!QQSO,5=cOOQO,5?Z,5?ZOOQO-E<m-E<mOOQQ7+(j7+(jO%#aQWO'#HQOOQQ1G3V1G3VO!%tQ,UO1G3VO%QQUO1G3VO%#hQSO1G3VO%#sQ,UO1G3VO9OQ(C[O1G3XO#K`QSO1G3XO8tQSO1G3XO!>oQWO1G3XO!>wQ,UO1G3XO%$RQSO'#IqO%$^QSO,5@mO%$fQWO,5@mOOQ(CW1G3Y1G3YOOQQ7+$S7+$SO?rQSO7+$SO9OQ(C[O7+$SO%$qQSO7+$SO%QQUO1G6[O%QQUO1G6]O%$vQUO1G3aO%$}QSO1G3aO%%SQUO1G3aO%%ZQ(C[O1G6[OOQQ7+(y7+(yO9OQ(C[O7+)TO`QUO7+)VOOQQ'#KW'#KWOOQQ'#It'#ItO%%eQUO,5>UOOQQ,5>U,5>UO%QQUO'#HkO%%rQSO'#HmOOQQ,5>[,5>[O:vQSO,5>[OOQQ,5>^,5>^OOQQ7+)`7+)`OOQQ7+)f7+)fOOQQ7+)j7+)jOOQQ7+)l7+)lO%%wQWO1G5mO%&]Q$IUO1G0sO%&gQSO1G0sOOQO1G/m1G/mO%&rQ$IUO1G/mO>QQSO1G/mO!)jQUO'#DgOOQO,5>u,5>uOOQO-E<X-E<XOOQO,5>{,5>{OOQO-E<_-E<_O!>oQWO1G/mOOQO-E<[-E<[OOQ(CY1G0X1G0XOOQ(CY7+%q7+%qO#![QSO7+%qOOQ(CY7+&X7+&XO>QQSO7+&XO!>oQWO7+&XOOQO7+%t7+%tO$6nQ(CjO7+&QOOQO7+&Q7+&QO%QQUO7+&QO%&|Q(C[O7+&QO!>dQ(C[O7+%tO!>oQWO7+%tO%'XQ(C[O7+&QO%'gQ(CjO7++bO%QQUO7++bO%'wQSO7++aO%'wQSO7++aOOQO1G4i1G4iO:vQSO1G4iO%(PQSO1G4iOOQO7+%y7+%yO#![QSO<<KwO$MUQbO<<KwO%(_QSO<<KwOOQQ<<Kw<<KwO!%tQ,UO<<KwO%QQUO<<KwO%(gQSO<<KwO%(rQ(CjO1G2kO%*}Q(CjO1G2mO%-YQ(CjO1G2XO%/kQ,UO,5>vOOQO-E<Y-E<YO%/uQbO,5>wO%QQUO,5>wOOQO-E<Z-E<ZO%0PQSO1G5oOOQ(CY<<I}<<I}O%0XQ$IUO1G0nO%2cQ$IUO1G0xO%2jQ$IUO1G0xO%4nQ$IUO1G0xO%4uQ$IUO1G0xO%6jQ$IUO1G0xO%7QQ$IUO1G0xO%9eQ$IUO1G0xO%9lQ$IUO1G0xO%;pQ$IUO1G0xO%;wQ$IUO1G0xO%=oQ$IUO1G0xO%>SQ(CjO<<JaO%?XQ$IUO1G0xO%@}Q$IUO'#J^O%CQQ$IUO1G1^O%C_Q$IUO1G0QO!)jQUO'#FlOOQO'#Jy'#JyOOQO1G1p1G1pO%CiQSO1G1oO%CnQ$IUO,5?QOOOO7+'c7+'cOOOO1G/S1G/SOOQ(CY1G4n1G4nO!'^Q,UO7+(ZO%CxQSO,5?RO9_QSO,5?ROOQO-E<e-E<eO%DWQSO1G6RO%DWQSO1G6RO%D`QSO1G6RO%DkQ,UO7+'sO%D{Q`O,5?TO%EVQSO,5?TO!%tQ,UO,5?TOOQO-E<g-E<gO%E[Q`O1G6SO%EfQSO1G6SOOQ(CW1G2c1G2cO$ mQSO1G2cOOQ(CW1G2b1G2bO%EnQSO1G2dO!%tQ,UO1G2dOOQ(CW1G2i1G2iO!>oQWO1G2bOBoQSO1G2cO%EsQSO1G2dO%E{QSO1G2cO!'^Q,UO7+*}OOQ(CY1G/[1G/[O%FWQSO1G/[OOQ(CY7+'n7+'nO%F]Q,UO7+'uO%FmQ(CjO<<KROOQ(CY<<KR<<KRO!%tQ,UO'#IlO%GaQSO,5@iO!%tQ,UO1G2gOOQQ<<Gx<<GxO!>dQ(C[O<<GxO%GiQ(CjO<<ItOOQ(CY<<It<<ItOOQO,5?^,5?^O%H]QSO,5?^O$%|QSO,5?^OOQO-E<p-E<pO%HbQSO1G6ZO%HbQSO1G6ZO9_QSO1G6ZO?rQSO<<LcOOQQ<<Lc<<LcO%HjQSO<<LcO9OQ(C[O<<LcO%HoQSO1G0sOOQQ<<LO<<LOO% dQ(ChO<<LOOOQQ<<LP<<LPO% nQ`O<<LPO%HtQWO'#InO%IPQSO,5@lO!)jQUO,5@lOOQQ1G2}1G2}O%IXQUO'#JgOOQO'#Ip'#IpO9OQ(C[O'#IpO%IcQWO,5=lOOQQ,5=l,5=lO%IjQWO'#E`O%JOQSO7+(qO%JTQSO7+(qOOQQ7+(q7+(qO!%tQ,UO7+(qO%QQUO7+(qO%J]QSO7+(qOOQQ7+(s7+(sO9OQ(C[O7+(sO#K`QSO7+(sO8tQSO7+(sO!>oQWO7+(sO%JhQSO,5?]OOQO-E<o-E<oOOQO'#HT'#HTO%JsQSO1G6XO9OQ(C[O<<GnOOQQ<<Gn<<GnO?rQSO<<GnO%J{QSO7++vO%KQQSO7++wOOQQ7+({7+({O%KVQSO7+({O%K[QUO7+({O%KcQSO7+({O%QQUO7++vO%QQUO7++wOOQQ<<Lo<<LoOOQQ<<Lq<<LqOOQQ-E<r-E<rOOQQ1G3p1G3pO%KhQSO,5>VOOQQ,5>X,5>XO%KmQSO1G3vO:vQSO7+&_O!)jQUO7+&_OOQO7+%X7+%XO%KrQ$IUO1G5yO>QQSO7+%XOOQ(CY<<I]<<I]OOQ(CY<<Is<<IsO>QQSO<<IsOOQO<<Il<<IlO$6nQ(CjO<<IlO%QQUO<<IlOOQO<<I`<<I`O!>dQ(C[O<<I`O%K|Q(C[O<<IlO%LXQ(CjO<<N|O%LiQSO<<N{OOQO7+*T7+*TO:vQSO7+*TOOQQANAcANAcO%LqQSOANAcO!%tQ,UOANAcO#![QSOANAcO$MUQbOANAcO%QQUOANAcO%LyQ(CjO7+'sO& [Q(CjO7+'uO&#mQbO1G4cO&#wQ$IUO7+&YO&$UQ$IUO,59nO&&XQ$IUO,5<dO&([Q$IUO,5<fO&*_Q$IUO,5<tO&,TQ$IUO7+'fO&,bQ$IUO7+'gO&,oQSO,5<WOOQO7+'Z7+'ZO&,tQ,UO<<KuOOQO1G4m1G4mO&,{QSO1G4mO&-WQSO1G4mO&-fQSO7++mO&-fQSO7++mO!%tQ,UO1G4oO&-nQ`O1G4oO&-xQSO7++nOOQ(CW7+'}7+'}O$ mQSO7+(OO&.QQ`O7+(OOOQ(CW7+'|7+'|O$ mQSO7+'}O&.XQSO7+(OO!%tQ,UO7+(OOBoQSO7+'}O&.^Q,UO<<NiOOQ(CY7+$v7+$vO&.hQ`O,5?WOOQO-E<j-E<jO&.rQ(ChO7+(ROOQQAN=dAN=dO9_QSO1G4xOOQO1G4x1G4xO&/SQSO1G4xO&/XQSO7++uO&/XQSO7++uO9OQ(C[OANA}O?rQSOANA}OOQQANA}ANA}OOQQANAjANAjOOQQANAkANAkO&/aQSO,5?YOOQO-E<l-E<lO&/lQ$IUO1G6WO&1|QbO'#CfOOQO,5?[,5?[OOQO-E<n-E<nOOQQ1G3W1G3WO%IXQUO,5<xOOQQ<<L]<<L]O!%tQ,UO<<L]O%JOQSO<<L]O&2WQSO<<L]O%QQUO<<L]OOQQ<<L_<<L_O9OQ(C[O<<L_O#K`QSO<<L_O8tQSO<<L_O&2`QWO1G4wO&2kQSO7++sOOQQAN=YAN=YO9OQ(C[OAN=YOOQQ<= b<= bOOQQ<= c<= cOOQQ<<Lg<<LgO&2sQSO<<LgO&2xQUO<<LgO&3PQSO<= bO&3UQSO<= cOOQQ1G3q1G3qO>QQSO7+)bO&3ZQSO<<IyO&3fQ$IUO<<IyOOQO<<Hs<<HsOOQ(CYAN?_AN?_OOQOAN?WAN?WO$6nQ(CjOAN?WOOQOAN>zAN>zO%QQUOAN?WOOQO<<Mo<<MoOOQQG26}G26}O!%tQ,UOG26}O#![QSOG26}O&3pQSOG26}O$MUQbOG26}O&3xQ$IUO<<JaO&4VQ$IUO1G2XO&5{Q$IUO1G2kO&8OQ$IUO1G2mO&:RQ$IUO<<KRO&:`Q$IUO<<ItOOQO1G1r1G1rO!'^Q,UOANAaOOQO7+*X7+*XO&:mQSO7+*XO&:xQSO<= XO&;QQ`O7+*ZOOQ(CW<<Kj<<KjO$ mQSO<<KjOOQ(CW<<Ki<<KiO&;[Q`O<<KjO$ mQSO<<KiOOQO7+*d7+*dO9_QSO7+*dO&;cQSO<= aOOQQG27iG27iO9OQ(C[OG27iO!)jQUO1G4tO&;kQSO7++rO%JOQSOANAwOOQQANAwANAwO!%tQ,UOANAwO&;sQSOANAwOOQQANAyANAyO9OQ(C[OANAyO#K`QSOANAyOOQO'#HU'#HUOOQO7+*c7+*cOOQQG22tG22tOOQQANBRANBRO&;{QSOANBROOQQAND|AND|OOQQAND}AND}OOQQ<<L|<<L|O!)jQUOAN?eOOQOG24rG24rO$6nQ(CjOG24rO#![QSOLD,iOOQQLD,iLD,iO!%tQ,UOLD,iO&<QQSOLD,iO&<YQ$IUO7+'sO&>OQ$IUO7+'uO&?tQ,UOG26{OOQO<<Ms<<MsOOQ(CWANAUANAUO$ mQSOANAUOOQ(CWANATANATOOQO<<NO<<NOOOQQLD-TLD-TO&@UQ$IUO7+*`OOQQG27cG27cO%JOQSOG27cO!%tQ,UOG27cOOQQG27eG27eO9OQ(C[OG27eOOQQG27mG27mO&@`Q$IUOG25POOQOLD*^LD*^OOQQ!$(!T!$(!TO#![QSO!$(!TO!%tQ,UO!$(!TO&@jQ(CjOG26{OOQ(CWG26pG26pOOQQLD,}LD,}O%JOQSOLD,}OOQQLD-PLD-POOQQ!)9Eo!)9EoO#![QSO!)9EoOOQQ!$(!i!$(!iOOQQ!.K;Z!.K;ZO&B{Q$IUOG26{O!)jQUO'#DvO0uQSO'#ETO&DqQbO'#JcO!)jQUO'#DnO&DxQUO'#DzO!)jQUO'#D|O&EPQbO'#CfO&GgQbO'#CfO&GwQUO,5;SO!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO'#IfO&IzQSO,5<cO&JSQ,UO,5;^O&KgQ,UO,5;^O!)jQUO,5;rO0xQSO'#DSO0xQSO'#DSO!%tQ,UO'#FxO&JSQ,UO'#FxO!%tQ,UO'#FzO&JSQ,UO'#FzO!%tQ,UO'#GYO&JSQ,UO'#GYO!)jQUO,5:fO!)jQUO,5@_O&GwQUO1G0nO&KnQ$IUO'#CfO!)jQUO1G1zO!%tQ,UO,5=PO&JSQ,UO,5=PO!%tQ,UO,5=RO&JSQ,UO,5=RO!%tQ,UO,5<mO&JSQ,UO,5<mO&GwQUO1G1{O!)jQUO7+&uO!%tQ,UO1G2XO&JSQ,UO1G2XO!%tQ,UO1G2ZO&JSQ,UO1G2ZO&GwQUO7+'gO&GwQUO7+&YO!%tQ,UOANAaO&JSQ,UOANAaO&KxQSO'#EhO&K}QSO'#EhO&LVQSO'#FWO&L[QSO'#ErO&LaQSO'#JsO&LlQSO'#JqO&LwQSO,5;SO&L|Q,UO,5<`O&MTQSO'#GRO&MYQSO'#GRO&M_QSO,5<aO&MgQSO,5;SO&MoQ$IUO1G1ZO&MvQSO,5<mO&M{QSO,5<mO&NQQSO,5<oO&NVQSO,5<oO&N[QSO1G1{O&NaQSO1G0nO&NfQ,UO<<KuO&NmQ,UO<<KuO7^Q,UO'#FvO8tQSO'#FuO@mQSO'#EgO!)jQUO,5;oO!2dQSO'#GRO!2dQSO'#GRO!2dQSO'#GTO!2dQSO'#GTO!'^Q,UO7+(ZO!'^Q,UO7+(ZO$HyQ`O1G2oO$HyQ`O1G2oO!%tQ,UO,5=TO!%tQ,UO,5=T\",\n  stateData: \"' v~O'mOS'nOSROS'oRQ~OPYOQYOV!TO^pOaxObwOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!XXO!csO!hZO!kYO!lYO!mYO!otO!quO!tvO!x]O#p}O$QzO$UfO%`{O%b!OO%d|O%e|O%h!PO%j!QO%m!RO%n!RO%p!SO%|!UO&S!VO&U!WO&W!XO&Y!YO&]!ZO&c![O&i!]O&k!^O&m!_O&o!`O&q!aO'tSO'vTO'yUO(RVO(a[O(niO~OPYOQYOa!gOb!fOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!cO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$Q!hO$UfO't!bO'vTO'yUO(RVO(a[O(niO~O^!sOl!kO|!lO![!uO!]!rO!^!rO!x9mO!|!mO!}!mO#O!tO#P!mO#Q!mO#T!vO#U!vO'u!iO'vTO'yUO(U!jO(a!pO~O'o!wO~OPYXXYX^YXkYXyYXzYX|YX!VYX!eYX!fYX!hYX!lYX#XYX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX'kYX(RYX(bYX(iYX(jYX~O!a$zX~P(gO[!yO'v!{O'w!yO'x!{O~O[!|O'x!{O'y!{O'z!|O~Oq#OO!O#PO(S#PO(T#RO~OPYOQYOa!gOb!fOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!cO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$Q!hO$UfO't9rO'vTO'yUO(RVO(a[O(niO~O!U#VO!V#SO!S(XP!S(fP~P+sO!W#_O~P`OPYOQYOa!gOb!fOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!cO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$Q!hO$UfO'vTO'yUO(RVO(a[O(niO~Oi#iO!U#eO!x]O#b#hO#c#eO't9sO!g(cP~P._O!h#kO't#jO~O!t#oO!x]O%`#pO~O#d#qO~O!a#rO#d#qO~OP$YOX$aOk#}Oy#vOz#wO|#xO!V$^O!e$PO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O#k$OO#l$PO#m$PO#n$`O#o$PO#q$QO#s$SO#u$UO#v$VO(RVO(b$WO(i#yO(j#zO~O^(VX'k(VX'i(VX!g(VX!S(VX!X(VX%a(VX!a(VX~P1gO#X$bO#{$bOP(WXX(WXk(WXy(WXz(WX|(WX!V(WX!e(WX!h(WX!l(WX#g(WX#h(WX#i(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#q(WX#s(WX#u(WX#v(WX(R(WX(b(WX(i(WX(j(WX!X(WX%a(WX~O^(WX!f(WX'k(WX'i(WX!S(WX!g(WXo(WX!a(WX~P3}O#X$bO~O$W$dO$Y$cO$a$iO~O!X$jO$UfO$d$kO$f$mO~Oi%POk$qOl$pOm$pOs%QOu%ROw%SO|$xO!X$yO!c%XO!h$uO#c%YO$Q%VO$m%TO$o%UO$r%WO't$oO'vTO'yUO'}%OO(R$rOd(OP~O!h%ZO~O!a%]O~O^%^O'k%^O~O'u!iO~P%QO't%eO~O!h%ZO't%eO'u!iO'}%OO~Ob%lO!h%ZO't%eO~O#o$PO~Oy%qO!X%nO!h%pO%b%tO't%eO'u!iO'vTO'yUO](vP~O!t#oO~O|%vO!X%wO't%eO~O|%vO!X%wO%j%{O't%eO~O't%|O~O#p}O%b!OO%d|O%e|O%h!PO%j!QO%m!RO%n!RO~Oa&VOb&UO!t&SO%`&TO%r&RO~P;fOa&YObwO!X&XO!tvO!x]O#p}O%`{O%d|O%e|O%h!PO%j!QO%m!RO%n!RO%p!SO~O_&]O#X&`O%b&ZO'u!iO~P<eO!h&aO!q&eO~O!h#kO~O!XXO~O^%^O'j&mO'k%^O~O^%^O'j&pO'k%^O~O^%^O'j&rO'k%^O~O'iYX!SYXoYX!gYX&QYX!XYX%aYX!aYX~P(gO!['PO!]&xO!^&xO'u!iO'vTO'yUO~Ol&vO|&uO!U&yO(U&tO!W(YP!W(hP~P?fOg'SO!X'QO't%eO~Ob'XO!h%ZO't%eO~Oy%qO!h%pO~Ol!kO|!lO!x9mO!|!mO!}!mO#P!mO#Q!mO'u!iO'vTO'yUO(U!jO(a!pO~O!['_O!]'^O!^'^O#O!mO#T'`O#U'`O~PAQO^%^O!a#rO!h%ZO'k%^O'}%OO(b'bO~O!l'fO#X'dO~PB`Ol!kO|!lO'vTO'yUO(U!jO(a!pO~O!XXOl(_X|(_X![(_X!](_X!^(_X!x(_X!|(_X!}(_X#O(_X#P(_X#Q(_X#T(_X#U(_X'u(_X'v(_X'y(_X(U(_X(a(_X~O!]'^O!^'^O'u!iO~PCOO'p'jO'q'jO'r'lO~O[!yO'v'nO'w!yO'x'nO~O[!|O'x'nO'y'nO'z!|O~Oq#OO!O#PO(S#PO(T'rO~O!U'tO!S&|X!S'SX!V&|X!V'SX~P+sO!V'vO!S(XX~OP$YOX$aOk#}Oy#vOz#wO|#xO!V'vO!e$PO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O#k$OO#l$PO#m$PO#n$`O#o$PO#q$QO#s$SO#u$UO#v$VO(RVO(b$WO(i#yO(j#zO~O!S(XX~PFrO!S'{O~O!S(eX!V(eX!a(eX!g(eX(b(eX~O#X(eX#d#]X!W(eX~PHxO#X'|O!S(gX!V(gX~O!V'}O!S(fX~O!S(QO~O#X$bO~PHxO!W(RO~P`Oy#vOz#wO|#xO!f#tO!h#uO(RVOP!jaX!jak!ja!V!ja!e!ja!l!ja#g!ja#h!ja#i!ja#j!ja#k!ja#l!ja#m!ja#n!ja#o!ja#q!ja#s!ja#u!ja#v!ja(b!ja(i!ja(j!ja~O^!ja'k!ja'i!ja!S!ja!g!jao!ja!X!ja%a!ja!a!ja~PJ`O!g(SO~O!a#rO#X(TO(b'bO!V(dX^(dX'k(dX~O!g(dX~PMOO|%vO!X%wO!x]O#b(YO#c(XO't%eO~O!V(ZO!g(cX~O!g(]O~O|%vO!X%wO#c(XO't%eO~OP(WXX(WXk(WXy(WXz(WX|(WX!V(WX!e(WX!f(WX!h(WX!l(WX#g(WX#h(WX#i(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#q(WX#s(WX#u(WX#v(WX(R(WX(b(WX(i(WX(j(WX~O!a#rO!g(WX~PNlOy(^Oz(_O!f#tO!h#uO!x!wa|!wa~O!t!wa%`!wa!X!wa#b!wa#c!wa't!wa~P!!pO!t(cO~OPYOQYOa!gOb!fOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!XXO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$Q!hO$UfO't!bO'vTO'yUO(RVO(a[O(niO~Oi%POk$qOl$pOm$pOs%QOu%ROw:VO|$xO!X$yO!c;aO!h$uO#c:]O$Q%VO$m:XO$o:ZO$r%WO't(gO'vTO'yUO'}%OO(R$rO~O#d(iO~Oi%POk$qOl$pOm$pOs%QOu%ROw%SO|$xO!X$yO!c%XO!h$uO#c%YO$Q%VO$m%TO$o%UO$r%WO't(gO'vTO'yUO'}%OO(R$rO~Od([P~P!'^O!U(mO!g(]P~P%QO(U(oO(a[O~O|(qO!h#uO(U(oO(a[O~OP9lOQ9lOa;]Ob!fOikOk9lOlkOmkOskOu9lOw9lO|WO!QkO!RkO!X!cO!c9oO!hZO!k9lO!l9lO!m9lO!o9pO!q9qO!t!eO$Q!hO$UfO't)PO'vTO'yUO(RVO(a[O(n;ZO~Oz)SO!h#uO~O!V$^O^$ka'k$ka'i$ka!g$ka!S$ka!X$ka%a$ka!a$ka~O#p)WO~P!%tOy)ZO!a)YO!X$XX$T$XX$W$XX$Y$XX$a$XX~O!a)YO!X(kX$T(kX$W(kX$Y(kX$a(kX~Oy)ZO~P!-SOy)ZO!X(kX$T(kX$W(kX$Y(kX$a(kX~O!X)]O$T)aO$W)[O$Y)[O$a)bO~O!U)eO~P!)jO$W$dO$Y$cO$a)iO~Og$sXy$sX|$sX!f$sX(i$sX(j$sX~OdfXd$sXgfX!VfX#XfX~P!.xOl)kO~Oq)lO(S)mO(T)oO~Og)xOy)qO|)rO(i)tO(j)vO~Od)pO~P!0ROd)yO~Oi%POk$qOl$pOm$pOs%QOu%ROw:VO|$xO!X$yO!c;aO!h$uO#c:]O$Q%VO$m:XO$o:ZO$r%WO'vTO'yUO'}%OO(R$rO~O!U)}O't)zO!g(oP~P!0pO#d*PO~O!h*QO~O!U*VO't*SO!S(pP~P!0pOk*cO|*ZO![*aO!]*YO!^*YO!h*QO#T*bO%W*]O'u!iO(U!jO~O!W*`O~P!2vO!f#tOg(QXy(QX|(QX(i(QX(j(QX!V(QX#X(QX~Od(QX#y(QX~P!3oOg*fO#X*eOd(PX!V(PX~O!V*gOd(OX~O't%|Od(OP~O!h*nO~O't(gO~Oi*rO|%vO!U#eO!X%wO!x]O#b#hO#c#eO't%eO!g(cP~O!a#rO#d*sO~OP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O#k$OO#l$PO#m$PO#n$`O#o$PO#q$QO#s$SO#u$UO#v$VO(RVO(b$WO(i#yO(j#zO~O^!ba!V!ba'k!ba'i!ba!S!ba!g!bao!ba!X!ba%a!ba!a!ba~P!6UOy#vOz#wO|#xO!f#tO!h#uO(RVOP!naX!nak!na!V!na!e!na!l!na#g!na#h!na#i!na#j!na#k!na#l!na#m!na#n!na#o!na#q!na#s!na#u!na#v!na(b!na(i!na(j!na~O^!na'k!na'i!na!S!na!g!nao!na!X!na%a!na!a!na~P!8oOy#vOz#wO|#xO!f#tO!h#uO(RVOP!paX!pak!pa!V!pa!e!pa!l!pa#g!pa#h!pa#i!pa#j!pa#k!pa#l!pa#m!pa#n!pa#o!pa#q!pa#s!pa#u!pa#v!pa(b!pa(i!pa(j!pa~O^!pa'k!pa'i!pa!S!pa!g!pao!pa!X!pa%a!pa!a!pa~P!;YOg*{O!X'QO%a*zO'}%OO~O!a*}O^'|X!X'|X'k'|X!V'|X~O^%^O!XXO'k%^O~O!h%ZO'}%OO~O!h%ZO't%eO'}%OO~O!a#rO#d(iO~O%b+ZO't+VO'vTO'yUO!W(wP~O!V+[O](vX~O(U(oO~OX+`O~O]+aO~O!X%nO't%eO'u!iO](vP~O|%vO!U+eO!V'}O!X%wO't%eO!S(fP~Ol&|O|+gO!U+fO'vTO'yUO(U(oO~O!W(hP~P!@xO!V+hO^(sX'k(sX~O#X+lO'}%OO~Og+oO!X$yO'}%OO~O!X+qO~Oy+sO!XXO~O!t+xO~Ob+}O~O't#jO!W(uP~Ob%lO~O%b!OO't%|O~P<eOX,TO],SO~OPYOQYOaxObwOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!csO!hZO!kYO!lYO!mYO!otO!quO!tvO!x]O$UfO%`{O'vTO'yUO(RVO(a[O(niO~O!X!cO$Q!hO't!bO~P!C]O],SO^%^O'k%^O~O^,XO#p,ZO%d,ZO%e,ZO~P%QO!h&aO~O&S,`O~O!X,bO~O&e,dO&g,eOP&baQ&baV&ba^&baa&bab&bai&bak&bal&bam&bas&bau&baw&ba|&ba!Q&ba!R&ba!X&ba!c&ba!h&ba!k&ba!l&ba!m&ba!o&ba!q&ba!t&ba!x&ba#p&ba$Q&ba$U&ba%`&ba%b&ba%d&ba%e&ba%h&ba%j&ba%m&ba%n&ba%p&ba%|&ba&S&ba&U&ba&W&ba&Y&ba&]&ba&c&ba&i&ba&k&ba&m&ba&o&ba&q&ba'i&ba't&ba'v&ba'y&ba(R&ba(a&ba(n&ba!W&ba&Z&ba_&ba&`&ba~O't,jO~O!V{X!V!_X!W{X!W!_X!a{X!a!_X!h!_X#X{X'}!_X~O!a,oO#X,nO!V#aX!V(ZX!W#aX!W(ZX!a(ZX!h(ZX'}(ZX~O!a,qO!h%ZO'}%OO!V!ZX!W!ZX~Ol!kO|!lO'vTO'yUO(U!jO~OP9lOQ9lOa;]Ob!fOikOk9lOlkOmkOskOu9lOw9lO|WO!QkO!RkO!X!cO!c9oO!hZO!k9lO!l9lO!m9lO!o9pO!q9qO!t!eO$Q!hO$UfO'vTO'yUO(RVO(a[O(n;ZO~O't:bO~P!LrO!V,uO!W(YX~O!W,wO~O!a,oO#X,nO!V#aX!W#aX~O!V,xO!W(hX~O!W,zO~O!],{O!^,{O'u!iO~P!LaO!W-OO~P'TOg-RO!X'QO~O!S-WO~Ol!wa![!wa!]!wa!^!wa!|!wa!}!wa#O!wa#P!wa#Q!wa#T!wa#U!wa'u!wa'v!wa'y!wa(U!wa(a!wa~P!!pO!l-]O#X-ZO~PB`O!]-_O!^-_O'u!iO~PCOO^%^O#X-ZO'k%^O~O^%^O!a#rO#X-ZO'k%^O~O^%^O!a#rO!l-]O#X-ZO'k%^O(b'bO~O'p'jO'q'jO'r-dO~Oo-eO~O!S&|a!V&|a~P!6UO!U-iO!S&|X!V&|X~P%QO!V'vO!S(Xa~O!S(Xa~PFrO!V'}O!S(fa~O|%vO!U-mO!X%wO't%eO!S'SX!V'SX~O#X-oO!V(da!g(da^(da'k(da~O!a#rO~P#&xO!V(ZO!g(ca~O|%vO!X%wO#c-sO't%eO~Oi-xO|%vO!U-uO!X%wO!x]O#b-wO#c-uO't%eO!V'VX!g'VX~Oz-|O!h#uO~Og.PO!X'QO%a.OO'}%OO~O^#[i!V#[i'k#[i'i#[i!S#[i!g#[io#[i!X#[i%a#[i!a#[i~P!6UOg;gOy)qO|)rO(i)tO(j)vO~O#d#Wa^#Wa#X#Wa'k#Wa!V#Wa!g#Wa!X#Wa!S#Wa~P#)tO#d(QXP(QXX(QX^(QXk(QXz(QX!e(QX!h(QX!l(QX#g(QX#h(QX#i(QX#j(QX#k(QX#l(QX#m(QX#n(QX#o(QX#q(QX#s(QX#u(QX#v(QX'k(QX(R(QX(b(QX!g(QX!S(QX'i(QXo(QX!X(QX%a(QX!a(QX~P!3oO!V.YOd([X~P!0ROd.[O~O!V.]O!g(]X~P!6UO!g.`O~O!S.bO~OP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO(RVOX#fi^#fik#fi!V#fi!e#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi'k#fi(b#fi(i#fi(j#fi'i#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~O#g#fi~P#-pO#g#{O~P#-pOP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O(RVOX#fi^#fi!V#fi!e#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi'k#fi(b#fi(i#fi(j#fi'i#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~Ok#fi~P#0bOk#}O~P#0bOP$YOk#}Oy#vOz#wO|#xO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O#k$OO(RVO^#fi!V#fi#q#fi#s#fi#u#fi#v#fi'k#fi(b#fi(i#fi(j#fi'i#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~OX#fi!e#fi#l#fi#m#fi#n#fi#o#fi~P#3SOX$aO!e$PO#l$PO#m$PO#n$`O#o$PO~P#3SOP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O#k$OO#l$PO#m$PO#n$`O#o$PO#q$QO(RVO^#fi!V#fi#s#fi#u#fi#v#fi'k#fi(b#fi(j#fi'i#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~O(i#fi~P#6TO(i#yO~P#6TOP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O#k$OO#l$PO#m$PO#n$`O#o$PO#q$QO#s$SO(RVO(i#yO^#fi!V#fi#u#fi#v#fi'k#fi(b#fi'i#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~O(j#fi~P#8uO(j#zO~P#8uOP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O#k$OO#l$PO#m$PO#n$`O#o$PO#q$QO#s$SO#u$UO(RVO(i#yO(j#zO~O^#fi!V#fi#v#fi'k#fi(b#fi'i#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~P#;gOPYXXYXkYXyYXzYX|YX!eYX!fYX!hYX!lYX#XYX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX(RYX(bYX(iYX(jYX!VYX!WYX~O#yYX~P#>QOP$YOX:TOk9wOy#vOz#wO|#xO!e9yO!f#tO!h#uO!l$YO#g9uO#h9vO#i9vO#j9vO#k9xO#l9yO#m9yO#n:SO#o9yO#q9zO#s9|O#u:OO#v:PO(RVO(b$WO(i#yO(j#zO~O#y.dO~P#@_O#X:UO#{:UO#y(WX!W(WX~PNlO^'Ya!V'Ya'k'Ya'i'Ya!g'Ya!S'Yao'Ya!X'Ya%a'Ya!a'Ya~P!6UOP#fiX#fi^#fik#fiz#fi!V#fi!e#fi!f#fi!h#fi!l#fi#g#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi'k#fi(R#fi(b#fi'i#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~P#)tO^#zi!V#zi'k#zi'i#zi!S#zi!g#zio#zi!X#zi%a#zi!a#zi~P!6UO$W.iO$Y.iO~O$W.jO$Y.jO~O!a)YO#X.kO!X$^X$T$^X$W$^X$Y$^X$a$^X~O!U.lO~O!X)]O$T.nO$W)[O$Y)[O$a.oO~O!V:QO!W(VX~P#@_O!W.pO~O!a)YO$a(kX~O$a.rO~Oq)lO(S)mO(T.uO~Ol.xO!S.yO'vTO'yUO~O!VcX!acX!gcX!g$sX(bcX~P!.xO!g/PO~P#)tO!V/QO!a#rO(b'bO!g(oX~O!g/VO~O!U)}O't%eO!g(oP~O#d/XO~O!S$sX!V$sX!a$zX~P!.xO!V/YO!S(pX~P#)tO!a/[O~O!S/^O~Ok/bO!a#rO!h%ZO'}%OO(b'bO~O't/dO~O!a*}O~O^%^O!V/hO'k%^O~O!W/jO~P!2vO!]/kO!^/kO'u!iO(U!jO~O|/mO(U!jO~O#T/nO~O't%|Od'_X!V'_X~O!V*gOd(Oa~Od/sO~Oy/tOz/tO|/uOgva(iva(jva!Vva#Xva~Odva#yva~P#L|Oy)qO|)rOg$la(i$la(j$la!V$la#X$la~Od$la#y$la~P#MrOy)qO|)rOg$na(i$na(j$na!V$na#X$na~Od$na#y$na~P#NeO#d/wO~Od$|a!V$|a#X$|a#y$|a~P!0RO!a#rO~O#d/zO~Oy#vOz#wO|#xO!f#tO!h#uO(RVOP!niX!nik!ni!V!ni!e!ni!l!ni#g!ni#h!ni#i!ni#j!ni#k!ni#l!ni#m!ni#n!ni#o!ni#q!ni#s!ni#u!ni#v!ni(b!ni(i!ni(j!ni~O^!ni'k!ni'i!ni!S!ni!g!nio!ni!X!ni%a!ni!a!ni~P$ wOg.PO!X'QO%a.OO~Oi0RO't0QO~P!0sO!a*}O^'|a!X'|a'k'|a!V'|a~O#d0XO~OXYX!VcX!WcX~O!V0YO!W(wX~O!W0[O~OX0]O~O't+VO'vTO'yUO~O!X%nO't%eO]'gX!V'gX~O!V+[O](va~O!g0bO~P!6UOX0eO~O]0fO~O!V+hO^(sa'k(sa~O#X0lO~Og0oO!X$yO~O(U(oO!W(tP~Og0xO!X0uO%a0wO'}%OO~OX1SO!V1QO!W(uX~O!W1TO~O]1VO^%^O'k%^O~O't#jO'vTO'yUO~O#X$bO#{$bOP(WXX(WXk(WXy(WXz(WX|(WX!V(WX!e(WX!h(WX!l(WX#g(WX#h(WX#i(WX#j(WX#k(WX#l(WX#m(WX#n(WX#q(WX#s(WX#u(WX#v(WX(R(WX(b(WX(i(WX(j(WX~O#o1YO&Q1ZO^(WX!f(WX~P$(xO#X$bO#o1YO&Q1ZO~O^1[O~P%QO^1^O~O&Z1bOP&XiQ&XiV&Xi^&Xia&Xib&Xii&Xik&Xil&Xim&Xis&Xiu&Xiw&Xi|&Xi!Q&Xi!R&Xi!X&Xi!c&Xi!h&Xi!k&Xi!l&Xi!m&Xi!o&Xi!q&Xi!t&Xi!x&Xi#p&Xi$Q&Xi$U&Xi%`&Xi%b&Xi%d&Xi%e&Xi%h&Xi%j&Xi%m&Xi%n&Xi%p&Xi%|&Xi&S&Xi&U&Xi&W&Xi&Y&Xi&]&Xi&c&Xi&i&Xi&k&Xi&m&Xi&o&Xi&q&Xi'i&Xi't&Xi'v&Xi'y&Xi(R&Xi(a&Xi(n&Xi!W&Xi_&Xi&`&Xi~O_1hO!W1fO&`1gO~P`O!XXO!h1jO~O&g,eOP&biQ&biV&bi^&bia&bib&bii&bik&bil&bim&bis&biu&biw&bi|&bi!Q&bi!R&bi!X&bi!c&bi!h&bi!k&bi!l&bi!m&bi!o&bi!q&bi!t&bi!x&bi#p&bi$Q&bi$U&bi%`&bi%b&bi%d&bi%e&bi%h&bi%j&bi%m&bi%n&bi%p&bi%|&bi&S&bi&U&bi&W&bi&Y&bi&]&bi&c&bi&i&bi&k&bi&m&bi&o&bi&q&bi'i&bi't&bi'v&bi'y&bi(R&bi(a&bi(n&bi!W&bi&Z&bi_&bi&`&bi~O!S1pO~O!V!Za!W!Za~P#@_Ol!kO|!lO!U1vO(U!jO!V&}X!W&}X~P?fO!V,uO!W(Ya~O!V'TX!W'TX~P!@xO!V,xO!W(ha~O!W1}O~P'TO^%^O#X2WO'k%^O~O^%^O!a#rO#X2WO'k%^O~O^%^O!a#rO!l2[O#X2WO'k%^O(b'bO~O^%^O'k%^O~P!6UO!V$^Oo$ka~O!S&|i!V&|i~P!6UO!V'vO!S(Xi~O!V'}O!S(fi~O!S(gi!V(gi~P!6UO!V(di!g(di^(di'k(di~P!6UO#X2^O!V(di!g(di^(di'k(di~O!V(ZO!g(ci~O|%vO!X%wO!x]O#b2cO#c2bO't%eO~O|%vO!X%wO#c2bO't%eO~Og2jO!X'QO%a2iO~Og2jO!X'QO%a2iO'}%OO~O#dvaPvaXva^vakva!eva!fva!hva!lva#gva#hva#iva#jva#kva#lva#mva#nva#ova#qva#sva#uva#vva'kva(Rva(bva!gva!Sva'ivaova!Xva%ava!ava~P#L|O#d$laP$laX$la^$lak$laz$la!e$la!f$la!h$la!l$la#g$la#h$la#i$la#j$la#k$la#l$la#m$la#n$la#o$la#q$la#s$la#u$la#v$la'k$la(R$la(b$la!g$la!S$la'i$lao$la!X$la%a$la!a$la~P#MrO#d$naP$naX$na^$nak$naz$na!e$na!f$na!h$na!l$na#g$na#h$na#i$na#j$na#k$na#l$na#m$na#n$na#o$na#q$na#s$na#u$na#v$na'k$na(R$na(b$na!g$na!S$na'i$nao$na!X$na%a$na!a$na~P#NeO#d$|aP$|aX$|a^$|ak$|az$|a!V$|a!e$|a!f$|a!h$|a!l$|a#g$|a#h$|a#i$|a#j$|a#k$|a#l$|a#m$|a#n$|a#o$|a#q$|a#s$|a#u$|a#v$|a'k$|a(R$|a(b$|a!g$|a!S$|a'i$|a#X$|ao$|a!X$|a%a$|a!a$|a~P#)tO^#[q!V#[q'k#[q'i#[q!S#[q!g#[qo#[q!X#[q%a#[q!a#[q~P!6UOd'OX!V'OX~P!'^O!V.YOd([a~O!U2rO!V'PX!g'PX~P%QO!V.]O!g(]a~O!V.]O!g(]a~P!6UO!S2uO~O#y!ja!W!ja~PJ`O#y!ba!V!ba!W!ba~P#@_O#y!na!W!na~P!8oO#y!pa!W!pa~P!;YO!X3XO$UfO$_3YO~O!W3^O~Oo3_O~P#)tO^$hq!V$hq'k$hq'i$hq!S$hq!g$hqo$hq!X$hq%a$hq!a$hq~P!6UO!S3`O~Ol.xO'vTO'yUO~Oy)qO|)rO(j)vOg%Xi(i%Xi!V%Xi#X%Xi~Od%Xi#y%Xi~P$GeOy)qO|)rOg%Zi(i%Zi(j%Zi!V%Zi#X%Zi~Od%Zi#y%Zi~P$HWO(b$WO~P#)tO!U3cO't%eO!V'ZX!g'ZX~O!V/QO!g(oa~O!V/QO!a#rO!g(oa~O!V/QO!a#rO(b'bO!g(oa~Od$ui!V$ui#X$ui#y$ui~P!0RO!U3kO't*SO!S']X!V']X~P!0pO!V/YO!S(pa~O!V/YO!S(pa~P#)tO!a#rO#o3sO~Ok3vO!a#rO(b'bO~Od(Pi!V(Pi~P!0RO#X3yOd(Pi!V(Pi~P!0RO!g3|O~O^$iq!V$iq'k$iq'i$iq!S$iq!g$iqo$iq!X$iq%a$iq!a$iq~P!6UO!V4QO!X(qX~P#)tO!f#tO~P3}O^$sX!X$sX%UYX'k$sX!V$sX~P!.xO%U4SO^hXghXyhX|hX!XhX'khX(ihX(jhX!VhX~O%U4SO~O%b4ZO't+VO'vTO'yUO!V'fX!W'fX~O!V0YO!W(wa~OX4_O~O]4`O~O!S4dO~O^%^O'k%^O~P#)tO!X$yO~P#)tO!V4iO#X4kO!W(tX~O!W4lO~Ol!kO|4mO![!uO!]!rO!^!rO!x9mO!|!mO!}!mO#O!mO#P!mO#Q!mO#T4rO#U!vO'u!iO'vTO'yUO(U!jO(a!pO~O!W4qO~P%!VOg4wO!X0uO%a4vO~Og4wO!X0uO%a4vO'}%OO~O't#jO!V'eX!W'eX~O!V1QO!W(ua~O'vTO'yUO(U5QO~O]5UO~O!g5XO~P%QO^5ZO~O^5ZO~P%QO#o5]O&Q5^O~PMOO_1hO!W5bO&`1gO~P`O!a5dO~O!a5fO!V(Zi!W(Zi!a(Zi!h(Zi'}(Zi~O!V#ai!W#ai~P#@_O#X5gO!V#ai!W#ai~O!V!Zi!W!Zi~P#@_O^%^O#X5pO'k%^O~O^%^O!a#rO#X5pO'k%^O~O!V(dq!g(dq^(dq'k(dq~P!6UO!V(ZO!g(cq~O|%vO!X%wO#c5wO't%eO~O!X'QO%a5zO~Og5}O!X'QO%a5zO~O#d%XiP%XiX%Xi^%Xik%Xiz%Xi!e%Xi!f%Xi!h%Xi!l%Xi#g%Xi#h%Xi#i%Xi#j%Xi#k%Xi#l%Xi#m%Xi#n%Xi#o%Xi#q%Xi#s%Xi#u%Xi#v%Xi'k%Xi(R%Xi(b%Xi!g%Xi!S%Xi'i%Xio%Xi!X%Xi%a%Xi!a%Xi~P$GeO#d%ZiP%ZiX%Zi^%Zik%Ziz%Zi!e%Zi!f%Zi!h%Zi!l%Zi#g%Zi#h%Zi#i%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#q%Zi#s%Zi#u%Zi#v%Zi'k%Zi(R%Zi(b%Zi!g%Zi!S%Zi'i%Zio%Zi!X%Zi%a%Zi!a%Zi~P$HWO#d$uiP$uiX$ui^$uik$uiz$ui!V$ui!e$ui!f$ui!h$ui!l$ui#g$ui#h$ui#i$ui#j$ui#k$ui#l$ui#m$ui#n$ui#o$ui#q$ui#s$ui#u$ui#v$ui'k$ui(R$ui(b$ui!g$ui!S$ui'i$ui#X$uio$ui!X$ui%a$ui!a$ui~P#)tOd'Oa!V'Oa~P!0RO!V'Pa!g'Pa~P!6UO!V.]O!g(]i~O#y#[i!V#[i!W#[i~P#@_OP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO(RVOX#fik#fi!e#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi#y#fi(b#fi(i#fi(j#fi!V#fi!W#fi~O#g#fi~P%0fO#g9uO~P%0fOP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO#g9uO#h9vO#i9vO#j9vO(RVOX#fi!e#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi#y#fi(b#fi(i#fi(j#fi!V#fi!W#fi~Ok#fi~P%2qOk9wO~P%2qOP$YOk9wOy#vOz#wO|#xO!f#tO!h#uO!l$YO#g9uO#h9vO#i9vO#j9vO#k9xO(RVO#q#fi#s#fi#u#fi#v#fi#y#fi(b#fi(i#fi(j#fi!V#fi!W#fi~OX#fi!e#fi#l#fi#m#fi#n#fi#o#fi~P%4|OX:TO!e9yO#l9yO#m9yO#n:SO#o9yO~P%4|OP$YOX:TOk9wOy#vOz#wO|#xO!e9yO!f#tO!h#uO!l$YO#g9uO#h9vO#i9vO#j9vO#k9xO#l9yO#m9yO#n:SO#o9yO#q9zO(RVO#s#fi#u#fi#v#fi#y#fi(b#fi(j#fi!V#fi!W#fi~O(i#fi~P%7hO(i#yO~P%7hOP$YOX:TOk9wOy#vOz#wO|#xO!e9yO!f#tO!h#uO!l$YO#g9uO#h9vO#i9vO#j9vO#k9xO#l9yO#m9yO#n:SO#o9yO#q9zO#s9|O(RVO(i#yO#u#fi#v#fi#y#fi(b#fi!V#fi!W#fi~O(j#fi~P%9sO(j#zO~P%9sOP$YOX:TOk9wOy#vOz#wO|#xO!e9yO!f#tO!h#uO!l$YO#g9uO#h9vO#i9vO#j9vO#k9xO#l9yO#m9yO#n:SO#o9yO#q9zO#s9|O#u:OO(RVO(i#yO(j#zO~O#v#fi#y#fi(b#fi!V#fi!W#fi~P%<OO^#wy!V#wy'k#wy'i#wy!S#wy!g#wyo#wy!X#wy%a#wy!a#wy~P!6UOg;hOy)qO|)rO(i)tO(j)vO~OP#fiX#fik#fiz#fi!e#fi!f#fi!h#fi!l#fi#g#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi#y#fi(R#fi(b#fi!V#fi!W#fi~P%>vO!f#tOP(QXX(QXg(QXk(QXy(QXz(QX|(QX!e(QX!h(QX!l(QX#g(QX#h(QX#i(QX#j(QX#k(QX#l(QX#m(QX#n(QX#o(QX#q(QX#s(QX#u(QX#v(QX#y(QX(R(QX(b(QX(i(QX(j(QX!V(QX!W(QX~O#y#zi!V#zi!W#zi~P#@_O#y!ni!W!ni~P$ wO!W6ZO~O!V'Ya!W'Ya~P#@_O!a#rO(b'bO!V'Za!g'Za~O!V/QO!g(oi~O!V/QO!a#rO!g(oi~Od$uq!V$uq#X$uq#y$uq~P!0RO!S']a!V']a~P#)tO!a6bO~O!V/YO!S(pi~P#)tO!V/YO!S(pi~O!S6fO~O!a#rO#o6kO~Ok6lO!a#rO(b'bO~O!S6nO~Od$wq!V$wq#X$wq#y$wq~P!0RO^$iy!V$iy'k$iy'i$iy!S$iy!g$iyo$iy!X$iy%a$iy!a$iy~P!6UO!V4QO!X(qa~O^#[y!V#[y'k#[y'i#[y!S#[y!g#[yo#[y!X#[y%a#[y!a#[y~P!6UOX6sO~O!V0YO!W(wi~O]6yO~O!a5fO~O(U(oO!V'bX!W'bX~O!V4iO!W(ta~OikO't7QO~P._O!W7TO~P%!VOl!kO|7UO'vTO'yUO(U!jO(a!pO~O!X0uO~O!X0uO%a7WO~Og7ZO!X0uO%a7WO~OX7`O!V'ea!W'ea~O!V1QO!W(ui~O!g7dO~O!g7eO~O!g7fO~O!g7fO~P%QO^7hO~O!a7kO~O!g7lO~O!V(gi!W(gi~P#@_O^%^O#X7tO'k%^O~O!V(dy!g(dy^(dy'k(dy~P!6UO!V(ZO!g(cy~O!X'QO%a7wO~O#d$uqP$uqX$uq^$uqk$uqz$uq!V$uq!e$uq!f$uq!h$uq!l$uq#g$uq#h$uq#i$uq#j$uq#k$uq#l$uq#m$uq#n$uq#o$uq#q$uq#s$uq#u$uq#v$uq'k$uq(R$uq(b$uq!g$uq!S$uq'i$uq#X$uqo$uq!X$uq%a$uq!a$uq~P#)tO#d$wqP$wqX$wq^$wqk$wqz$wq!V$wq!e$wq!f$wq!h$wq!l$wq#g$wq#h$wq#i$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#q$wq#s$wq#u$wq#v$wq'k$wq(R$wq(b$wq!g$wq!S$wq'i$wq#X$wqo$wq!X$wq%a$wq!a$wq~P#)tO!V'Pi!g'Pi~P!6UO#y#[q!V#[q!W#[q~P#@_Oy/tOz/tO|/uOPvaXvagvakva!eva!fva!hva!lva#gva#hva#iva#jva#kva#lva#mva#nva#ova#qva#sva#uva#vva#yva(Rva(bva(iva(jva!Vva!Wva~Oy)qO|)rOP$laX$lag$lak$laz$la!e$la!f$la!h$la!l$la#g$la#h$la#i$la#j$la#k$la#l$la#m$la#n$la#o$la#q$la#s$la#u$la#v$la#y$la(R$la(b$la(i$la(j$la!V$la!W$la~Oy)qO|)rOP$naX$nag$nak$naz$na!e$na!f$na!h$na!l$na#g$na#h$na#i$na#j$na#k$na#l$na#m$na#n$na#o$na#q$na#s$na#u$na#v$na#y$na(R$na(b$na(i$na(j$na!V$na!W$na~OP$|aX$|ak$|az$|a!e$|a!f$|a!h$|a!l$|a#g$|a#h$|a#i$|a#j$|a#k$|a#l$|a#m$|a#n$|a#o$|a#q$|a#s$|a#u$|a#v$|a#y$|a(R$|a(b$|a!V$|a!W$|a~P%>vO#y$hq!V$hq!W$hq~P#@_O#y$iq!V$iq!W$iq~P#@_O!W8RO~O#y8SO~P!0RO!a#rO!V'Zi!g'Zi~O!a#rO(b'bO!V'Zi!g'Zi~O!V/QO!g(oq~O!S']i!V']i~P#)tO!V/YO!S(pq~O!S8YO~P#)tO!S8YO~Od(Py!V(Py~P!0RO!V'`a!X'`a~P#)tO^%Tq!X%Tq'k%Tq!V%Tq~P#)tOX8_O~O!V0YO!W(wq~O#X8cO!V'ba!W'ba~O!V4iO!W(ti~P#@_OPYXXYXkYXyYXzYX|YX!SYX!VYX!eYX!fYX!hYX!lYX#XYX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX(RYX(bYX(iYX(jYX~O!a%RX#o%RX~P&/vO!X0uO%a8gO~O'vTO'yUO(U8lO~O!V1QO!W(uq~O!g8oO~O!g8oO~P%QO!g8qO~O!g8rO~O#X8tO!V#ay!W#ay~O!V#ay!W#ay~P#@_O!X'QO%a8yO~O#y#wy!V#wy!W#wy~P#@_OP$uiX$uik$uiz$ui!e$ui!f$ui!h$ui!l$ui#g$ui#h$ui#i$ui#j$ui#k$ui#l$ui#m$ui#n$ui#o$ui#q$ui#s$ui#u$ui#v$ui#y$ui(R$ui(b$ui!V$ui!W$ui~P%>vOy)qO|)rO(j)vOP%XiX%Xig%Xik%Xiz%Xi!e%Xi!f%Xi!h%Xi!l%Xi#g%Xi#h%Xi#i%Xi#j%Xi#k%Xi#l%Xi#m%Xi#n%Xi#o%Xi#q%Xi#s%Xi#u%Xi#v%Xi#y%Xi(R%Xi(b%Xi(i%Xi!V%Xi!W%Xi~Oy)qO|)rOP%ZiX%Zig%Zik%Ziz%Zi!e%Zi!f%Zi!h%Zi!l%Zi#g%Zi#h%Zi#i%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#q%Zi#s%Zi#u%Zi#v%Zi#y%Zi(R%Zi(b%Zi(i%Zi(j%Zi!V%Zi!W%Zi~O#y$iy!V$iy!W$iy~P#@_O#y#[y!V#[y!W#[y~P#@_O!a#rO!V'Zq!g'Zq~O!V/QO!g(oy~O!S']q!V']q~P#)tO!S9QO~P#)tO!V0YO!W(wy~O!V4iO!W(tq~O!X0uO%a9XO~O!g9[O~O!X'QO%a9aO~OP$uqX$uqk$uqz$uq!e$uq!f$uq!h$uq!l$uq#g$uq#h$uq#i$uq#j$uq#k$uq#l$uq#m$uq#n$uq#o$uq#q$uq#s$uq#u$uq#v$uq#y$uq(R$uq(b$uq!V$uq!W$uq~P%>vOP$wqX$wqk$wqz$wq!e$wq!f$wq!h$wq!l$wq#g$wq#h$wq#i$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#q$wq#s$wq#u$wq#v$wq#y$wq(R$wq(b$wq!V$wq!W$wq~P%>vOd%]!Z!V%]!Z#X%]!Z#y%]!Z~P!0RO!V'bq!W'bq~P#@_O!V#a!Z!W#a!Z~P#@_O#d%]!ZP%]!ZX%]!Z^%]!Zk%]!Zz%]!Z!V%]!Z!e%]!Z!f%]!Z!h%]!Z!l%]!Z#g%]!Z#h%]!Z#i%]!Z#j%]!Z#k%]!Z#l%]!Z#m%]!Z#n%]!Z#o%]!Z#q%]!Z#s%]!Z#u%]!Z#v%]!Z'k%]!Z(R%]!Z(b%]!Z!g%]!Z!S%]!Z'i%]!Z#X%]!Zo%]!Z!X%]!Z%a%]!Z!a%]!Z~P#)tOP%]!ZX%]!Zk%]!Zz%]!Z!e%]!Z!f%]!Z!h%]!Z!l%]!Z#g%]!Z#h%]!Z#i%]!Z#j%]!Z#k%]!Z#l%]!Z#m%]!Z#n%]!Z#o%]!Z#q%]!Z#s%]!Z#u%]!Z#v%]!Z#y%]!Z(R%]!Z(b%]!Z!V%]!Z!W%]!Z~P%>vOo(VX~P1gO'u!iO~P!)jO!ScX!VcX#XcX~P&/vOPYXXYXkYXyYXzYX|YX!VYX!VcX!eYX!fYX!hYX!lYX#XYX#XcX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX(RYX(bYX(iYX(jYX~O!acX!gYX!gcX(bcX~P&E^OP9lOQ9lOa;]Ob!fOikOk9lOlkOmkOskOu9lOw9lO|WO!QkO!RkO!XXO!c9oO!hZO!k9lO!l9lO!m9lO!o9pO!q9qO!t!eO$Q!hO$UfO't)PO'vTO'yUO(RVO(a[O(n;ZO~O!V:QO!W$ka~Oi%POk$qOl$pOm$pOs%QOu%ROw:WO|$xO!X$yO!c;bO!h$uO#c:^O$Q%VO$m:YO$o:[O$r%WO't(gO'vTO'yUO'}%OO(R$rO~O#p)WO~P&JSO!WYX!WcX~P&E^O#d9tO~O!a#rO#d9tO~O#X:UO~O#o9yO~O#X:`O!V(gX!W(gX~O#X:UO!V(eX!W(eX~O#d:aO~Od:cO~P!0RO#d:hO~O#d:iO~O!a#rO#d:jO~O!a#rO#d:aO~O#y:kO~P#@_O#d:lO~O#d:mO~O#d:nO~O#d:oO~O#d:pO~O#d:qO~O#y:rO~P!0RO#y:sO~P!0RO$U~!f!|!}#P#Q#T#b#c#n(n$m$o$r%U%`%a%b%h%j%m%n%p%r~'oR$U(n#h!R'm'u#il#g#jky'n(U'n't$W$Y$W~\",\n  goto: \"$%Z({PPPP(|P)PP)aP*p.rPPPP5SPP5iP;d>iP>|P>|PPP>|P@lP>|P>|P>|P@pPP@uPA`PFUPPPFYPPPPFYIXPPPI_JYPFYPLgPPPPNuFYPPPFYPFYP!#TFYP!&g!'i!'rP!(e!(i!(ePPPPP!+r!'iPP!,`!-YP!/|FYFY!0R!3Z!7n!7n!;cPPP!;jFYPPPPPPPPPPP!>uP!@WPPFY!AePFYPFYFYFYFYPFY!BwPP!E}P!IPP!IT!I_!Ic!IcP!EzP!Ig!IgP!LiP!LmFYFY!Ls# t>|P>|P>|>|P##O>|>|#$x>|#'V>|#(y>|>|#)g#+c#+c#+g#+o#+c#+wP#+cP>|#,a>|#-i>|>|5SPPP#.tPP#/^#/^P#/^P#/s#/^PP#/yP#/pP#/p#0]#/p#0w#0}5P)P#1Q)PP#1X#1X#1XP)PP)PP)PP)PPP)PP#1_#1bP#1b)PP#1fP#1iP)PP)PP)PP)PP)PP)P)PPP#1o#1u#2P#2V#2]#2c#2i#2w#2}#3T#3_#3e#3o#4O#4U#4u#5X#5_#5e#5s#6Y#7j#7x#8O#8U#8[#8b#8l#8r#8x#9S#9f#9lPPPPPPPPPP#9rPPPPPPP#:f#=mP#>|#?T#?]PPPP#Cg#F]#Lr#Lu#Lx#Mq#Mt#Mw#NO#NWPP#N^#Nb$ Z$!Z$!_$!sPP$!w$!}$#RP$#U$#Y$#]$$R$$i$$n$$q$$t$$z$$}$%R$%VR!xRmpOXr!X#`%]&d&f&g&i,],b1b1eY!rQ'Q,}0u4pQ%ctQ%kwQ%rzQ&[!TS&x!c,uQ'W!fS'^!o!uS*Y$y*_Q+T%lQ+b%tQ+|&UQ,{'PQ-V'XQ-_'_Q/k*aQ1P+}R:_9p$zdOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&d&f&g&i&m&u'S'd't'v'|(T(i(m(q)p*s+g,X,],b-R-Z-i-o.].d/u/z0X0x1Y1Z1[1^1b1e1g2W2^2r4m4w5Z5]5^5p7U7Z7h7tS#m]9m!r)R$X$j&y)e,n,q.l1v3X4k5g8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^Q*j%SQ+Y%nQ,O&XQ,V&aQ.S:VQ0O*{Q0S*}Q0_+ZQ1X,TQ2f.PQ4Y0YQ5O1QQ5|2jQ6S:WQ6u4ZR7z5}&xkOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'd't'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^t!kQ!o!r!u!v&x'P'Q'^'_'`,u,{,}-_0u4p4r$Y$pi#r#t$`$a$u$x%T%U%Y)l)u)w)x*P*V*e*f*z*}+l+o.O.Y/X/Y/[/w0l0o0w2i3a3k3s3y4Q4S4v5z6b6k7W7w8S8g8y9X9a:S:T:X:Y:Z:[:]:^:d:e:f:g:h:i:l:m:n:o:r:s;Z;c;d;g;hQ%uzQ&v!cS&|%w,xQ+Y%nS.x)r.zQ/v*nQ0_+ZQ0d+aQ1W,SQ1X,TQ4Y0YQ4c0fQ5R1SQ5S1VQ6u4ZQ6x4`Q7c5UQ8b6yR8m7`pmOXr!T!X#`%]&Z&d&f&g&i,],b1b1eR,Q&]&r^OPXYrstux!X!^!g!l#O#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u'S'd'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;];^[#XWZ#S#V&y'tQ%fvQ%jwS%oz%t!U%x|}#d#e#h%Z%v'}(X(Y(Z+e+f+h,Z,o-m-s-t-u-w1j2b2c5f5wQ&Q!RQ'T!eQ'V!fQ(b#oS)|$u*QS+S%k%lQ+W%nQ+w&SQ+{&US-U'W'XQ.R(cQ/U)}Q0W+TQ0^+ZQ0`+[Q0c+`Q0z+xS1O+|+}Q2S-VQ3b/QQ4X0YQ4]0]Q4b0eQ4}1PQ6_3cQ6t4ZQ6w4_Q8^6sR9S8_v$wi#t%T%U%Y)u)w*P*e*f.Y/X/w3a3y8S;Z;c;d!S%hw!f!q%j%k%l&w'V'W'X']'g*X+S+T,r-U-V-^/c0W1{2S2Z3uQ*|%fQ+m%}Q+p&OQ+z&UQ.Q(bQ0y+wU0}+{+|+}Q2k.RQ4x0zS4|1O1PQ7_4}!z;_#r$`$a$u$x)l)x*V*z*}+l+o.O/Y/[0l0o0w2i3k3s4Q4S4v5z6b6k7W7w8g8y9X9a:X:Z:]:d:f:h:l:n:r;g;hg;`:S:T:Y:[:^:e:g:i:m:o:sW$|i%O*g;ZS%}!O&ZQ&O!PQ&P!QR+k%{$Z${i#r#t$`$a$u$x%T%U%Y)l)u)w)x*P*V*e*f*z*}+l+o.O.Y/X/Y/[/w0l0o0w2i3a3k3s3y4Q4S4v5z6b6k7W7w8S8g8y9X9a:S:T:X:Y:Z:[:]:^:d:e:f:g:h:i:l:m:n:o:r:s;Z;c;d;g;hT)m$r)nV*k%S:V:WU&|!c%w,xS(p#v#wQ+_%qS-z(^(_Q0p+qQ3z/tR6}4i&xkOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'd't'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^$i$]c#U#a%a%b%d's'y(e(l(t(u(v(w(x(y(z({(|(})O)Q)T)X)c*x+^,s-b-g-l-n.X._.c.e.f.g.v/x1q1t2U2]2q2v2w2x2y2z2{2|2}3O3P3Q3R3S3V3W3]4O4V5i5o5t6Q6R6W6X7P7n7r7{8P8Q8v9U9]9n;QT#PV#Q&ykOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'd't'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^Q&z!cR1w,uv!kQ!c!o!r!u!v&x'P'Q'^'_'`,u,{,}-_0u4p4rS*X$y*_S/c*Y*aQ/l*bQ0r+sQ3u/kR3x/nlpOXr!X#`%]&d&f&g&i,],b1b1eQ&k![Q'h!tS(d#q9tQ+Q%iQ+u&QQ+v&RQ-S'UQ-a'aS.W(i:aS/y*s:jQ0U+RQ0t+tQ1i,dQ1k,eQ1s,pQ2Q-TQ2T-XS4P/z:pQ4T0VS4W0X:qQ5h1uQ5l2RQ5q2YQ6r4UQ7o5jQ7p5mQ7s5rR8s7l$d$[c#U#a%b%d's'y(e(l(t(u(v(w(x(y(z({(|(})O)Q)T)X)c*x+^,s-b-g-l-n.X._.c.f.g.v/x1q1t2U2]2q2v2w2x2y2z2{2|2}3O3P3Q3R3S3V3W3]4O4V5i5o5t6Q6R6W6X7P7n7r7{8P8Q8v9U9]9n;QS(a#l'ZU*d$z(h3US*w%a.eQ2g0OQ5y2fQ7y5|R8z7z$d$Zc#U#a%b%d's'y(e(l(t(u(v(w(x(y(z({(|(})O)Q)T)X)c*x+^,s-b-g-l-n.X._.c.f.g.v/x1q1t2U2]2q2v2w2x2y2z2{2|2}3O3P3Q3R3S3V3W3]4O4V5i5o5t6Q6R6W6X7P7n7r7{8P8Q8v9U9]9n;QS(`#l'ZS(r#w$[S*v%a.eS-{(_(aQ.h)SQ/{*wR2d-|&xkOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'd't'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^S#m]9mQ&f!VQ&g!WQ&i!YQ&j!ZR1a,`Q'R!eQ*y%fQ-Q'TS-}(b*|Q2O-PW2h.Q.R/}0PQ5k2PU5x2e2g2kS7v5y5{S8x7x7yS9_8w8zQ9g9`R9j9hU!sQ'Q,}T4n0u4p!O_OXZ`r!T!X#`#d%Z%]&Z&]&d&f&g&i(Z,],b-t1b1e]!mQ!o'Q,}0u4pT#m]9m%UyOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'd't'v'|(T(i(m(q)p*s*{+g,X,],b-R-Z-i-o.P.].d/u/z0X0x1Y1Z1[1^1b1e1g2W2^2j2r4m4w5Z5]5^5p5}7U7Z7h7tS(p#v#wS-z(^(_!s:w$X$j&y)e,n,q.l1v3X4k5g8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^Y!qQ'Q,}0u4pQ']!oS'g!r!uS'i!v4rS-^'^'_Q-`'`R2Z-_Q'f!qS(V#c1_S-]']'iQ/T)|Q/a*XQ2[-`Q3g/US3p/b/lQ6^3bS6i3v3xQ8U6_R8]6lQ#sbQ'e!qS(U#c1_S(W#i*rQ*t%[Q+O%gQ+U%mU-[']'f'iQ-p(VQ/S)|Q/`*XQ/f*[Q0T+PQ0{+yS2X-]-`Q2a-xS3f/T/US3o/a/lQ3r/eQ3t/gQ4z0|Q5s2[Q6]3bQ6a3gS6e3p3xQ6j3wQ7]4{S8T6^6_Q8X6fQ8Z6iQ8j7^Q9O8UQ9P8YQ9R8]Q9Z8kQ9c9QQ:z:uQ;V;OR;W;PV!sQ'Q,}%UaOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'd't'v'|(T(i(m(q)p*s*{+g,X,],b-R-Z-i-o.P.].d/u/z0X0x1Y1Z1[1^1b1e1g2W2^2j2r4m4w5Z5]5^5p5}7U7Z7h7tS#sx!g!r:t$X$j&y)e,n,q.l1v3X4k5g8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^R:z;]%UbOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'd't'v'|(T(i(m(q)p*s*{+g,X,],b-R-Z-i-o.P.].d/u/z0X0x1Y1Z1[1^1b1e1g2W2^2j2r4m4w5Z5]5^5p5}7U7Z7h7tQ%[j!S%gw!f!q%j%k%l&w'V'W'X']'g*X+S+T,r-U-V-^/c0W1{2S2Z3uS%mx!gQ+P%hQ+y&UW0|+z+{+|+}U4{0}1O1PS7^4|4}Q8k7_!r:u$X$j&y)e,n,q.l1v3X4k5g8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^Q;O;[R;P;]$xeOPXYrstu!X!^!l#O#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&d&f&g&i&m&u'S'd'v'|(T(i(m(q)p*s*{+g,X,],b-R-Z-i-o.P.].d/u/z0X0x1Y1Z1[1^1b1e1g2W2^2j2r4m4w5Z5]5^5p5}7U7Z7h7tY#^WZ#S#V't!U%x|}#d#e#h%Z%v'}(X(Y(Z+e+f+h,Z,o-m-s-t-u-w1j2b2c5f5wQ,W&a!p:v$X$j)e,n,q.l1v3X4k5g8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^R:y&yS&}!c%wR1y,x$zdOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&d&f&g&i&m&u'S'd't'v'|(T(i(m(q)p*s+g,X,],b-R-Z-i-o.].d/u/z0X0x1Y1Z1[1^1b1e1g2W2^2r4m4w5Z5]5^5p7U7Z7h7t!r)R$X$j&y)e,n,q.l1v3X4k5g8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^Q,V&aQ0O*{Q2f.PQ5|2jR7z5}!f$Rc#U%a's'y(e(l({(|(})O)T)X+^-b-g-l-n.X._.v/x2U2]2q3S4O4V5o5t6Q7r8v9n!T9{)Q)c,s.e1q1t2v3O3P3Q3R3V3]5i6R6W6X7P7n7{8P8Q9U9];Q!b$Tc#U%a's'y(e(l(})O)T)X+^-b-g-l-n.X._.v/x2U2]2q3S4O4V5o5t6Q7r8v9n!P9})Q)c,s.e1q1t2v3Q3R3V3]5i6R6W6X7P7n7{8P8Q9U9];Q!^$Xc#U%a's'y(e(l)T)X+^-b-g-l-n.X._.v/x2U2]2q3S4O4V5o5t6Q7r8v9nQ3a/Oz;^)Q)c,s.e1q1t2v3V3]5i6R6W6X7P7n7{8P8Q9U9];QQ;c;eR;d;f&xkOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'd't'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^S$kh$lR3Y.k'PgOPWXYZhrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j$l%]%c%p&]&`&a&d&f&g&i&m&u&y'S'd't'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.k.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^T$gf$mQ$efS)[$h)`R)h$mT$ff$mT)^$h)`'PhOPWXYZhrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j$l%]%c%p&]&`&a&d&f&g&i&m&u&y'S'd't'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.k.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^T$kh$lQ$nhR)g$l%UjOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'd't'v'|(T(i(m(q)p*s*{+g,X,],b-R-Z-i-o.P.].d/u/z0X0x1Y1Z1[1^1b1e1g2W2^2j2r4m4w5Z5]5^5p5}7U7Z7h7t!s;[$X$j&y)e,n,q.l1v3X4k5g8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^#alOPXZr!X!^!l#O#`#k#x$j%]&]&`&a&d&f&g&i&m&u'S(q)e*{+g,X,],b-R.P.l/u0x1Y1Z1[1^1b1e1g2j3X4m4w5Z5]5^5}7U7Z7hv$zi#t%T%U%Y)u)w*P*e*f.Y/X/w3a3y8S;Z;c;d!z(h#r$`$a$u$x)l)x*V*z*}+l+o.O/Y/[0l0o0w2i3k3s4Q4S4v5z6b6k7W7w8g8y9X9a:X:Z:]:d:f:h:l:n:r;g;hQ*o%WQ.w)qg3U:S:T:Y:[:^:e:g:i:m:o:sv$vi#t%T%U%Y)u)w*P*e*f.Y/X/w3a3y8S;Z;c;dQ*R$wS*[$y*_Q*p%XQ/g*]!z:|#r$`$a$u$x)l)x*V*z*}+l+o.O/Y/[0l0o0w2i3k3s4Q4S4v5z6b6k7W7w8g8y9X9a:X:Z:]:d:f:h:l:n:r;g;hf:}:S:T:Y:[:^:e:g:i:m:o:sQ;R;_Q;S;`Q;T;aR;U;bv$zi#t%T%U%Y)u)w*P*e*f.Y/X/w3a3y8S;Z;c;d!z(h#r$`$a$u$x)l)x*V*z*}+l+o.O/Y/[0l0o0w2i3k3s4Q4S4v5z6b6k7W7w8g8y9X9a:X:Z:]:d:f:h:l:n:r;g;hg3U:S:T:Y:[:^:e:g:i:m:o:slnOXr!X#`%]&d&f&g&i,],b1b1eQ*U$xQ,k&pQ,l&rR3j/Y$Y${i#r#t$`$a$u$x%T%U%Y)l)u)w)x*P*V*e*f*z*}+l+o.O.Y/X/Y/[/w0l0o0w2i3a3k3s3y4Q4S4v5z6b6k7W7w8S8g8y9X9a:S:T:X:Y:Z:[:]:^:d:e:f:g:h:i:l:m:n:o:r:s;Z;c;d;g;hQ+n&OQ0n+pQ4g0mR6|4hT*^$y*_S*^$y*_T4o0u4pS/e*Z4mT3w/m7UQ+O%gQ/f*[Q0T+PQ0{+yQ4z0|Q7]4{Q8j7^R9Z8kn)u$s(j*q/W/o/p2o3h3}6[6m8}:{;X;Y!W:d(f)V){*T.V.s/O/]/|0k0m2n3i3m4f4h6O6P6c6g6o6q8W8[9b;e;f]:e3T6V7|8{8|9kp)w$s(j*q.|/W/o/p2o3h3}6[6m8}:{;X;Y!Y:f(f)V){*T.V.s/O/]/|0k0m2l2n3i3m4f4h6O6P6c6g6o6q8W8[9b;e;f_:g3T6V7|7}8{8|9kpmOXr!T!X#`%]&Z&d&f&g&i,],b1b1eQ&W!SR,X&apmOXr!T!X#`%]&Z&d&f&g&i,],b1b1eR&W!SQ+r&PR0j+kqmOXr!T!X#`%]&Z&d&f&g&i,],b1b1eQ0v+wS4u0y0zU7V4s4t4xS8f7X7YS9V8e8hQ9d9WR9i9eQ&_!TR,R&ZR5R1SS%oz%tR0`+[Q&d!UR,]&eR,c&jT1c,b1eR,g&kQ,f&kR1l,gQ'k!wR-c'kQrOQ#`XT%`r#`Q!zTR'm!zQ!}UR'o!}Q)n$rR.t)nQ#QVR'q#QQ#TWU'w#T'x-jQ'x#UR-j'yQ,v&zR1x,vQ.Z(jR2p.ZQ.^(lS2s.^2tR2t._Q,}'QR1|,}Y!oQ'Q,}0u4pR'[!oS#ZW%vU(O#Z(P-kQ(P#[R-k'zQ,y&}R1z,yr`OXr!T!X#`%]&Z&]&d&f&g&i,],b1b1eS#dZ%ZU#n`#d-tR-t(ZQ([#fQ-q(WW-y([-q2_5uQ2_-rR5u2`Q)`$hR.m)`Q$lhR)f$lQ$_cU)U$_-f:RQ-f9nR:R)cQ/R)|W3d/R3e6`8VU3e/S/T/US6`3f3gR8V6a#m)s$s(f(j)V){*T*l*m*q.T.U.V.s.|.}/O/W/]/o/p/|0k0m2l2m2n2o3T3h3i3m3}4f4h6O6P6T6U6V6[6c6g6m6o6q7|7}8O8W8[8{8|8}9b9k:{;X;Y;e;fQ/Z*TU3l/Z3n6dQ3n/]R6d3mQ*_$yR/i*_Q*h$}R/r*hQ4R/|R6p4RQ+i%yR0i+iQ4j0pS7O4j8dR8d7PQ+t&QR0s+tQ4p0uR7S4pQ1R,OS5P1R7aR7a5RQ0Z+WW4[0Z4^6v8`Q4^0^Q6v4]R8`6wQ+]%oR0a+]Q1e,bR5a1eWqOXr#`Q&h!XQ*u%]Q,[&dQ,^&fQ,_&gQ,a&iQ1`,]S1c,b1eR5`1bQ%_oQ&l!]Q&o!_Q&q!`Q&s!aQ'c!qQ+Q%iQ+d%uQ+j%zQ,Q&_Q,i&nW-Y']'e'f'iQ-a'aQ/h*^Q0U+RS1U,R,UQ1m,hQ1n,kQ1o,lQ2T-XW2V-[-]-`-bQ4T0VQ4a0dQ4e0kQ4y0{Q5T1WQ5_1aU5n2U2X2[Q5q2YQ6r4UQ6z4cQ6{4fQ7R4oQ7[4zQ7b5SS7q5o5sQ7s5rQ8a6xQ8i7]Q8n7cQ8u7rQ9T8bQ9Y8jQ9^8vR9f9ZQ%iwQ'U!fQ'a!qU+R%j%k%lQ,p&wU-T'V'W'XS-X']'gQ/_*XS0V+S+TQ1u,rS2R-U-VQ2Y-^Q3q/cQ4U0WQ5j1{Q5m2SQ5r2ZR6h3uS$ti;ZR*i%OU$}i%O;ZR/q*gQ$siS(f#r*}Q(j#tS)V$`$aQ){$uQ*T$xQ*l%TQ*m%UQ*q%YQ.T:XQ.U:ZQ.V:]Q.s)lQ.|)uQ.})wQ/O)xQ/W*PQ/]*VQ/o*eQ/p*fh/|*z.O0w2i4v5z7W7w8g8y9X9aQ0k+lQ0m+oQ2l:dQ2m:fQ2n:hQ2o.YS3T:S:TQ3h/XQ3i/YQ3m/[Q3}/wQ4f0lQ4h0oQ6O:lQ6P:nQ6T:YQ6U:[Q6V:^Q6[3aQ6c3kQ6g3sQ6m3yQ6o4QQ6q4SQ7|:iQ7}:eQ8O:gQ8W6bQ8[6kQ8{:mQ8|:oQ8}8SQ9b:rQ9k:sQ:{;ZQ;X;cQ;Y;dQ;e;gR;f;hloOXr!X#`%]&d&f&g&i,],b1b1eQ!dPS#bZ#kQ&n!^U'Y!l4m7UQ'p#OQ(s#xQ)d$jS,U&]&`Q,Y&aQ,h&mQ,m&uQ-P'SQ.a(qQ.q)eQ0P*{Q0g+gQ1],XQ2P-RQ2g.PQ3[.lQ3{/uQ4t0xQ5V1YQ5W1ZQ5Y1[Q5[1^Q5c1gQ5y2jQ6Y3XQ7Y4wQ7g5ZQ7i5]Q7j5^Q7y5}Q8h7ZR8p7h#UcOPXZr!X!^!l#`#k#x%]&]&`&a&d&f&g&i&m&u'S(q*{+g,X,],b-R.P/u0x1Y1Z1[1^1b1e1g2j4m4w5Z5]5^5}7U7Z7hQ#UWQ#aYQ%asQ%btQ%duS's#S'vQ'y#VQ(e#qQ(l#uQ(t#{Q(u#|Q(v#}Q(w$OQ(x$PQ(y$QQ(z$RQ({$SQ(|$TQ(}$UQ)O$VQ)Q$XQ)T$^Q)X$bW)c$j)e.l3XQ*x%cQ+^%pS,s&y1vQ-b'dS-g't-iQ-l'|Q-n(TQ.X(iQ._(mQ.c9lQ.e9oQ.f9pQ.g9qQ.v)pQ/x*sQ1q,nQ1t,qQ2U-ZQ2]-oQ2q.]Q2v9tQ2w9uQ2x9vQ2y9wQ2z9xQ2{9yQ2|9zQ2}9{Q3O9|Q3P9}Q3Q:OQ3R:PQ3S.dQ3V:UQ3W:_Q3]:QQ4O/zQ4V0XQ5i:`Q5o2WQ5t2^Q6Q2rQ6R:aQ6W:cQ6X:jQ7P4kQ7n5gQ7r5pQ7{:kQ8P:pQ8Q:qQ8v7tQ9U8cQ9]8tQ9n#OR;Q;^R#WWR&{!cY!qQ'Q,}0u4pS&w!c,uQ']!oS'g!r!uS'i!v4rS,r&x'PS-^'^'_Q-`'`Q1{,{R2Z-_R(k#tR(n#uQ!dQT,|'Q,}]!nQ!o'Q,}0u4pQ#l]R'Z9mT#gZ%ZS#fZ%ZU%y|},ZU(W#d#e#hS-r(X(YQ-v(ZQ0h+hQ2`-sU2a-t-u-wS5v2b2cR7u5w`#YW#S#V%v't'}+e-mt#cZ|}#d#e#h%Z(X(Y(Z+h-s-t-u-w2b2c5wQ1_,ZQ1r,oQ5e1jQ7m5fT:x&y+fT#]W%vS#[W%vS'u#S'}S'z#V+eS,t&y+fT-h't-mT'O!c%wQ$hfR)j$mT)_$h)`R3Z.kT*O$u*QR*W$xQ/}*zQ2e.OQ4s0wQ5{2iQ7X4vQ7x5zQ8e7WQ8w7wQ9W8gQ9`8yQ9e9XR9h9alpOXr!X#`%]&d&f&g&i,],b1b1eQ&^!TR,Q&ZV%z|},ZR0q+qR,P&XQ%szR+c%tR+X%nT&b!U&eT&c!U&eT1d,b1e\",\n  nodeNames: \"âš  ArithOp ArithOp LineComment BlockComment Script ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXStartTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem\",\n  maxTerm: 364,\n  context: trackNewline,\n  nodeProps: [\n    [\"group\", -26,6,14,16,62,199,203,206,207,209,212,215,225,227,233,235,237,239,242,248,254,256,258,260,262,264,265,\"Statement\",-32,10,11,25,28,29,35,45,48,49,51,56,64,72,76,78,80,81,103,104,113,114,131,134,136,137,138,139,141,142,162,163,165,\"Expression\",-23,24,26,30,34,36,38,166,168,170,171,173,174,175,177,178,179,181,182,183,193,195,197,198,\"Type\",-3,84,96,102,\"ClassItem\"],\n    [\"openedBy\", 31,\"InterpolationStart\",50,\"[\",54,\"{\",69,\"(\",143,\"JSXStartTag\",155,\"JSXStartTag JSXStartCloseTag\"],\n    [\"closedBy\", 33,\"InterpolationEnd\",44,\"]\",55,\"}\",70,\")\",144,\"JSXSelfCloseEndTag JSXEndTag\",160,\"JSXEndTag\"]\n  ],\n  propSources: [jsHighlight],\n  skippedNodes: [0,3,4,268],\n  repeatNodeCount: 33,\n  tokenData: \"$>y(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tu>PuvBavwDxwxGgxyMvyz! Qz{!![{|!%O|}!&]}!O!%O!O!P!'g!P!Q!1w!Q!R#0t!R![#3T![!]#@T!]!^#Aa!^!_#Bk!_!`#GS!`!a#In!a!b#N{!b!c$$z!c!}>P!}#O$&U#O#P$'`#P#Q$,w#Q#R$.R#R#S>P#S#T$/`#T#o$0j#o#p$4z#p#q$5p#q#r$7Q#r#s$8^#s$f%Z$f$g+g$g#BY>P#BY#BZ$9h#BZ$IS>P$IS$I_$9h$I_$I|>P$I|$I}$<s$I}$JO$<s$JO$JT>P$JT$JU$9h$JU$KV>P$KV$KW$9h$KW&FU>P&FU&FV$9h&FV;'S>P;'S;=`BZ<%l?HT>P?HT?HU$9h?HUO>P(n%d_$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$d&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$d&j'z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU'z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$d&j'wpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU'wpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX'wp'z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$d&j'wp'z!b'm(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST'x#S$d&j'n(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$d&j'wp'z!b'n(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$d&j!l$Ip'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#q$Id$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#q$Id$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2b3l_'v$(n$d&j'z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k*r4r_$d&j'z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k)`5vX$d&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q)`6jT$_#t$d&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#t6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y#t7bO$_#t#t7eP;=`<%l6y)`7kP;=`<%l5q*r7w]$_#t$d&j'z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}%W8uZ'z!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p%W9oU$_#t'z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}%W:UP;=`<%l8p*r:[P;=`<%l4k#%|:hg$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}st%Ztu<Puw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}<P!}#O%Z#O#P&c#P#R%Z#R#S<P#S#T%Z#T#o<P#o#p*g#p$g%Z$g;'S<P;'S;=`=y<%lO<P#%|<[i$d&j(a!L^'wp'z!bOY%ZYZ&cZr%Zrs&}st%Ztu<Puw%Zwx(rx!Q%Z!Q![<P![!^%Z!^!_*g!_!c%Z!c!}<P!}#O%Z#O#P&c#P#R%Z#R#S<P#S#T%Z#T#o<P#o#p*g#p$g%Z$g;'S<P;'S;=`=y<%lO<P#%|=|P;=`<%l<P(CS>`k$d&j'wp'z!b(U!LY't&;d$W#tOY%ZYZ&cZr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$g%Z$g;'S>P;'S;=`BZ<%lO>P+d@`k$d&j'wp'z!b$W#tOY%ZYZ&cZr%Zrs&}st%Ztu@Tuw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![@T![!^%Z!^!_*g!_!c%Z!c!}@T!}#O%Z#O#P&c#P#R%Z#R#S@T#S#T%Z#T#o@T#o#p*g#p$g%Z$g;'S@T;'S;=`BT<%lO@T+dBWP;=`<%l@T(CSB^P;=`<%l>P%#SBl`$d&j'wp'z!b#i$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SCy_$d&j#{$Id'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%DfETa(j%<v$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sv%ZvwFYwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SFe`$d&j#u$Id'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2bGp_'y$)`$d&j'wpOYHoYZIuZrHorsIuswHowxKVx!^Ho!^!_LX!_#OHo#O#PIu#P#oHo#o#pLX#p;'SHo;'S;=`Mp<%lOHo*QHv_$d&j'wpOYHoYZIuZrHorsIuswHowxKVx!^Ho!^!_LX!_#OHo#O#PIu#P#oHo#o#pLX#p;'SHo;'S;=`Mp<%lOHo)`IzX$d&jOwIuwx6cx!^Iu!^!_Jg!_#oIu#o#pJg#p;'SIu;'S;=`KP<%lOIu#tJjTOwJgwx7]x;'SJg;'S;=`Jy<%lOJg#tJ|P;=`<%lJg)`KSP;=`<%lIu*QK`]$_#t$d&j'wpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r$fL^Z'wpOYLXYZJgZrLXrsJgswLXwxMPx#OLX#O#PJg#P;'SLX;'S;=`Mj<%lOLX$fMWU$_#t'wpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r$fMmP;=`<%lLX*QMsP;=`<%lHo(*QNR_!h(!b$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l! ]_!gM|$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!!ib$d&j'wp'z!b'u#)d#j$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!#q{!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!#|`$d&j'wp'z!b#g$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!%Z`$d&j'wp'z!bk&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!&h_!V&;l$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!'rc$d&j'wp'z!by'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!(}!P!Q%Z!Q![!+g![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!)Wa$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!*]!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!*h_!UMt$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!+rg$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!+g![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S!+g#S#X%Z#X#Y!-Z#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!-dg$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!.{|}%Z}!O!.{!O!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!/Uc$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!0lc$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!2Sf$d&j'wp'z!b#h$IdOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}xz!3hz{#$s{!P!3h!P!Q#&Y!Q!^!3h!^!_!Mh!_!`#-x!`!a#/_!a!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(r!3sb$d&j'wp'z!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(Q!5U`$d&j'z!b!RSOY!4{YZ&cZw!4{wx!6Wx!P!4{!P!Q!=o!Q!^!4{!^!_!?g!_!}!4{!}#O!Bn#O#P!<w#P#o!4{#o#p!?g#p;'S!4{;'S;=`!Cw<%lO!4{&n!6_^$d&j!RSOY!6WYZ&cZ!P!6W!P!Q!7Z!Q!^!6W!^!_!8g!_!}!6W!}#O!;U#O#P!<w#P#o!6W#o#p!8g#p;'S!6W;'S;=`!=i<%lO!6W&n!7ba$d&j!RSO!^&c!_#Z&c#Z#[!7Z#[#]&c#]#^!7Z#^#a&c#a#b!7Z#b#g&c#g#h!7Z#h#i&c#i#j!7Z#j#m&c#m#n!7Z#n#o&c#p;'S&c;'S;=`&w<%lO&cS!8lX!RSOY!8gZ!P!8g!P!Q!9X!Q!}!8g!}#O!9p#O#P!:o#P;'S!8g;'S;=`!;O<%lO!8gS!9^U!RS#Z#[!9X#]#^!9X#a#b!9X#g#h!9X#i#j!9X#m#n!9XS!9sVOY!9pZ#O!9p#O#P!:Y#P#Q!8g#Q;'S!9p;'S;=`!:i<%lO!9pS!:]SOY!9pZ;'S!9p;'S;=`!:i<%lO!9pS!:lP;=`<%l!9pS!:rSOY!8gZ;'S!8g;'S;=`!;O<%lO!8gS!;RP;=`<%l!8g&n!;Z[$d&jOY!;UYZ&cZ!^!;U!^!_!9p!_#O!;U#O#P!<P#P#Q!6W#Q#o!;U#o#p!9p#p;'S!;U;'S;=`!<q<%lO!;U&n!<UX$d&jOY!;UYZ&cZ!^!;U!^!_!9p!_#o!;U#o#p!9p#p;'S!;U;'S;=`!<q<%lO!;U&n!<tP;=`<%l!;U&n!<|X$d&jOY!6WYZ&cZ!^!6W!^!_!8g!_#o!6W#o#p!8g#p;'S!6W;'S;=`!=i<%lO!6W&n!=lP;=`<%l!6W(Q!=xi$d&j'z!b!RSOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!=o#[#]&}#]#^!=o#^#a&}#a#b!=o#b#g&}#g#h!=o#h#i&}#i#j!=o#j#m&}#m#n!=o#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!?nZ'z!b!RSOY!?gZw!?gwx!8gx!P!?g!P!Q!@a!Q!}!?g!}#O!Ap#O#P!:o#P;'S!?g;'S;=`!Bh<%lO!?g!f!@hb'z!b!RSOY'}Zw'}x#O'}#P#Z'}#Z#[!@a#[#]'}#]#^!@a#^#a'}#a#b!@a#b#g'}#g#h!@a#h#i'}#i#j!@a#j#m'}#m#n!@a#n;'S'};'S;=`(f<%lO'}!f!AuX'z!bOY!ApZw!Apwx!9px#O!Ap#O#P!:Y#P#Q!?g#Q;'S!Ap;'S;=`!Bb<%lO!Ap!f!BeP;=`<%l!Ap!f!BkP;=`<%l!?g(Q!Bu^$d&j'z!bOY!BnYZ&cZw!Bnwx!;Ux!^!Bn!^!_!Ap!_#O!Bn#O#P!<P#P#Q!4{#Q#o!Bn#o#p!Ap#p;'S!Bn;'S;=`!Cq<%lO!Bn(Q!CtP;=`<%l!Bn(Q!CzP;=`<%l!4{'`!DW`$d&j'wp!RSOY!C}YZ&cZr!C}rs!6Ws!P!C}!P!Q!EY!Q!^!C}!^!_!GQ!_!}!C}!}#O!JX#O#P!<w#P#o!C}#o#p!GQ#p;'S!C};'S;=`!Kb<%lO!C}'`!Eci$d&j'wp!RSOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!EY#[#](r#]#^!EY#^#a(r#a#b!EY#b#g(r#g#h!EY#h#i(r#i#j!EY#j#m(r#m#n!EY#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!GXZ'wp!RSOY!GQZr!GQrs!8gs!P!GQ!P!Q!Gz!Q!}!GQ!}#O!IZ#O#P!:o#P;'S!GQ;'S;=`!JR<%lO!GQt!HRb'wp!RSOY)rZr)rs#O)r#P#Z)r#Z#[!Gz#[#])r#]#^!Gz#^#a)r#a#b!Gz#b#g)r#g#h!Gz#h#i)r#i#j!Gz#j#m)r#m#n!Gz#n;'S)r;'S;=`*Z<%lO)rt!I`X'wpOY!IZZr!IZrs!9ps#O!IZ#O#P!:Y#P#Q!GQ#Q;'S!IZ;'S;=`!I{<%lO!IZt!JOP;=`<%l!IZt!JUP;=`<%l!GQ'`!J`^$d&j'wpOY!JXYZ&cZr!JXrs!;Us!^!JX!^!_!IZ!_#O!JX#O#P!<P#P#Q!C}#Q#o!JX#o#p!IZ#p;'S!JX;'S;=`!K[<%lO!JX'`!K_P;=`<%l!JX'`!KeP;=`<%l!C}(r!Ksk$d&j'wp'z!b!RSOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[!Kh#[#]%Z#]#^!Kh#^#a%Z#a#b!Kh#b#g%Z#g#h!Kh#h#i%Z#i#j!Kh#j#m%Z#m#n!Kh#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W!Mq]'wp'z!b!RSOY!MhZr!Mhrs!?gsw!Mhwx!GQx!P!Mh!P!Q!Nj!Q!}!Mh!}#O#!U#O#P!:o#P;'S!Mh;'S;=`##U<%lO!Mh#W!Nse'wp'z!b!RSOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[!Nj#[#]*g#]#^!Nj#^#a*g#a#b!Nj#b#g*g#g#h!Nj#h#i*g#i#j!Nj#j#m*g#m#n!Nj#n;'S*g;'S;=`+Z<%lO*g#W#!]Z'wp'z!bOY#!UZr#!Urs!Apsw#!Uwx!IZx#O#!U#O#P!:Y#P#Q!Mh#Q;'S#!U;'S;=`##O<%lO#!U#W##RP;=`<%l#!U#W##XP;=`<%l!Mh(r##e`$d&j'wp'z!bOY##[YZ&cZr##[rs!Bnsw##[wx!JXx!^##[!^!_#!U!_#O##[#O#P!<P#P#Q!3h#Q#o##[#o#p#!U#p;'S##[;'S;=`#$g<%lO##[(r#$jP;=`<%l##[(r#$pP;=`<%l!3h(CS#%Qb$d&j'wp'z!b'o(;d!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(CS#&e_$d&j'wp'z!bR(;dOY#&YYZ&cZr#&Yrs#'dsw#&Ywx#*tx!^#&Y!^!_#,s!_#O#&Y#O#P#(f#P#o#&Y#o#p#,s#p;'S#&Y;'S;=`#-r<%lO#&Y(Bb#'m]$d&j'z!bR(;dOY#'dYZ&cZw#'dwx#(fx!^#'d!^!_#)w!_#O#'d#O#P#(f#P#o#'d#o#p#)w#p;'S#'d;'S;=`#*n<%lO#'d(AO#(mX$d&jR(;dOY#(fYZ&cZ!^#(f!^!_#)Y!_#o#(f#o#p#)Y#p;'S#(f;'S;=`#)q<%lO#(f(;d#)_SR(;dOY#)YZ;'S#)Y;'S;=`#)k<%lO#)Y(;d#)nP;=`<%l#)Y(AO#)tP;=`<%l#(f(<v#*OW'z!bR(;dOY#)wZw#)wwx#)Yx#O#)w#O#P#)Y#P;'S#)w;'S;=`#*h<%lO#)w(<v#*kP;=`<%l#)w(Bb#*qP;=`<%l#'d(Ap#*}]$d&j'wpR(;dOY#*tYZ&cZr#*trs#(fs!^#*t!^!_#+v!_#O#*t#O#P#(f#P#o#*t#o#p#+v#p;'S#*t;'S;=`#,m<%lO#*t(<U#+}W'wpR(;dOY#+vZr#+vrs#)Ys#O#+v#O#P#)Y#P;'S#+v;'S;=`#,g<%lO#+v(<U#,jP;=`<%l#+v(Ap#,pP;=`<%l#*t(=h#,|Y'wp'z!bR(;dOY#,sZr#,srs#)wsw#,swx#+vx#O#,s#O#P#)Y#P;'S#,s;'S;=`#-l<%lO#,s(=h#-oP;=`<%l#,s(CS#-uP;=`<%l#&Y%#W#.Vb$d&j#{$Id'wp'z!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h+h#/lb$T#t$d&j'wp'z!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h$/l#1Pp$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!+g!P!Q%Z!Q![#3T![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S#3T#S#U%Z#U#V#6_#V#X%Z#X#Y!-Z#Y#b%Z#b#c#5T#c#d#9g#d#l%Z#l#m#<i#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#3`k$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!+g!P!Q%Z!Q![#3T![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S#3T#S#X%Z#X#Y!-Z#Y#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#5`_$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#6hd$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#7v!R!S#7v!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#7v#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#8Rf$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#7v!R!S#7v!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#7v#S#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#9pc$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#:{!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#:{#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;We$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#:{!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#:{#S#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#<rg$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#>Z![!^%Z!^!_*g!_!c%Z!c!i#>Z!i#O%Z#O#P&c#P#R%Z#R#S#>Z#S#T%Z#T#Z#>Z#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>fi$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#>Z![!^%Z!^!_*g!_!c%Z!c!i#>Z!i#O%Z#O#P&c#P#R%Z#R#S#>Z#S#T%Z#T#Z#>Z#Z#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#@b_!a$b$d&j#y%<f'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Al_^l$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS#Bz^'}!*v!e'.r'wp'z!b$U)d(nSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Cv!Q!^*g!^!_#Dl!_!`#F^!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#DPX$f&j'wp'z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#DuZ#k$Id'wp'z!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Eh!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#EqX#{$Id'wp'z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#FgX#l$Id'wp'z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh#G_a#X%?x$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a#Hd!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W#Ho_#d$Ih$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#I}adBf#l$Id$a#|$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`#KS!`!a#L^!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#K__#l$Id$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#Lia#k$Id$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`!a#Mn!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#My`#k$Id$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$ Wc(b$Ip$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$!c!P!^%Z!^!_*g!_!a%Z!a!b$#m!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$!n_z'#p$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$#x`$d&j#v$Id'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$%V_!x!Ln$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$&a_|(8n$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$'eZ$d&jO!^$(W!^!_$(n!_#i$(W#i#j$(s#j#l$(W#l#m$*f#m#o$(W#o#p$(n#p;'S$(W;'S;=`$,q<%lO$(W(n$(_T[#S$d&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$(sO[#S(n$(x[$d&jO!Q&c!Q![$)n![!^&c!_!c&c!c!i$)n!i#T&c#T#Z$)n#Z#o&c#o#p$,U#p;'S&c;'S;=`&w<%lO&c(n$)sZ$d&jO!Q&c!Q![$*f![!^&c!_!c&c!c!i$*f!i#T&c#T#Z$*f#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$*kZ$d&jO!Q&c!Q![$+^![!^&c!_!c&c!c!i$+^!i#T&c#T#Z$+^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$+cZ$d&jO!Q&c!Q![$(W![!^&c!_!c&c!c!i$(W!i#T&c#T#Z$(W#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$,XR!Q![$,b!c!i$,b#T#Z$,b#S$,eS!Q![$,b!c!i$,b#T#Z$,b#q#r$(n(n$,tP;=`<%l$(W!'l$-S_!SM|$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$.^`#s$Id$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$/k_$d&j'wp'z!b(R&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$0yk$d&j'wp'z!b(U!LY't&;d$Y#tOY%ZYZ&cZr%Zrs&}st%Ztu$0juw%Zwx(rx}%Z}!O$2n!O!Q%Z!Q![$0j![!^%Z!^!_*g!_!c%Z!c!}$0j!}#O%Z#O#P&c#P#R%Z#R#S$0j#S#T%Z#T#o$0j#o#p*g#p$g%Z$g;'S$0j;'S;=`$4t<%lO$0j+d$2yk$d&j'wp'z!b$Y#tOY%ZYZ&cZr%Zrs&}st%Ztu$2nuw%Zwx(rx}%Z}!O$2n!O!Q%Z!Q![$2n![!^%Z!^!_*g!_!c%Z!c!}$2n!}#O%Z#O#P&c#P#R%Z#R#S$2n#S#T%Z#T#o$2n#o#p*g#p$g%Z$g;'S$2n;'S;=`$4n<%lO$2n+d$4qP;=`<%l$2n(CS$4wP;=`<%l$0j!5p$5TX!X!3l'wp'z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Df$5{a(i%<v$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$#m#q;'S%Z;'S;=`+a<%lO%Z%#`$7__!W$I`o`$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$8i_!mS$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$9y|$d&j'wp'z!b'm(;d(U!LY't&;d$W#tOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$f%Z$f$g+g$g#BY>P#BY#BZ$9h#BZ$IS>P$IS$I_$9h$I_$JT>P$JT$JU$9h$JU$KV>P$KV$KW$9h$KW&FU>P&FU&FV$9h&FV;'S>P;'S;=`BZ<%l?HT>P?HT?HU$9h?HUO>P(CS$=Uk$d&j'wp'z!b'n(;d(U!LY't&;d$W#tOY%ZYZ&cZr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$g%Z$g;'S>P;'S;=`BZ<%lO>P\",\n  tokenizers: [noSemicolon, incdecToken, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, insertSemicolon, new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LocalTokenGroup(\"$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOq~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!O~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(T~~\", 141, 326), new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LocalTokenGroup(\"j~RQYZXz{^~^O'q~~aP!P!Qd~iO'r~~\", 25, 308)],\n  topRules: {\"Script\":[0,5],\"SingleExpression\":[1,266],\"SingleClassItem\":[2,267]},\n  dialects: {jsx: 12686, ts: 12688},\n  dynamicPrecedences: {\"76\":1,\"78\":1,\"163\":1,\"191\":1},\n  specialized: [{term: 312, get: value => spec_identifier[value] || -1},{term: 328, get: value => spec_word[value] || -1},{term: 67, get: value => spec_LessThan[value] || -1}],\n  tokenPrec: 12712\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2phdmFzY3JpcHQvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBeUY7QUFDdEM7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUIscURBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRCw0QkFBNEIsd0RBQWlCO0FBQzdDLE9BQU8sTUFBTTtBQUNiO0FBQ0E7QUFDQSxDQUFDLEdBQUcsaUNBQWlDOztBQUVyQyx3QkFBd0Isd0RBQWlCO0FBQ3pDLE9BQU8sTUFBTTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHLGlCQUFpQjs7QUFFckIsd0JBQXdCLHdEQUFpQjtBQUN6QyxPQUFPLE1BQU07QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHLGlCQUFpQjs7QUFFckIsb0JBQW9CLDJEQUFTO0FBQzdCLDBCQUEwQixrREFBSTtBQUM5Qiw0RkFBNEYsa0RBQUk7QUFDaEcscURBQXFELGtEQUFJO0FBQ3pELDBDQUEwQyxrREFBSTtBQUM5Qyx3QkFBd0Isa0RBQUk7QUFDNUIsMEJBQTBCLGtEQUFJO0FBQzlCLGtCQUFrQixrREFBSSxTQUFTLGtEQUFJO0FBQ25DLFNBQVMsa0RBQUk7QUFDYixrQkFBa0Isa0RBQUk7QUFDdEIsUUFBUSxrREFBSTtBQUNaLFFBQVEsa0RBQUk7QUFDWixRQUFRLGtEQUFJO0FBQ1osZ0JBQWdCLGtEQUFJO0FBQ3BCLHVFQUF1RSxrREFBSSxVQUFVLGtEQUFJO0FBQ3pGLHNCQUFzQixrREFBSSxZQUFZLGtEQUFJO0FBQzFDLFNBQVMsa0RBQUk7QUFDYixnQkFBZ0Isa0RBQUk7QUFDcEIsdUJBQXVCLGtEQUFJLFNBQVMsa0RBQUk7QUFDeEMsa0RBQWtELGtE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LHNHQUFzRyxzREFBZSwrREFBK0QsS0FBSyxHQUFHLDZFQUE2RSxNQUFNLE1BQU0sNkVBQTZFLGlDQUFpQyxzREFBZSxXQUFXO0FBQzdaLGFBQWEsb0VBQW9FO0FBQ2pGLGFBQWEsc0JBQXNCO0FBQ25DLHVCQUF1Qiw4QkFBOEI7QUFDckQsaUJBQWlCLHNEQUFzRCxFQUFFLGdEQUFnRCxFQUFFLG1EQUFtRDtBQUM5SztBQUNBLENBQUM7O0FBRWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGxpdmVibG9ja3MtZXhhbXBsZXMvbmV4dGpzLXlqcy1jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL0BsZXplci9qYXZhc2NyaXB0L2Rpc3QvaW5kZXguZXMuanM/YTViNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb250ZXh0VHJhY2tlciwgRXh0ZXJuYWxUb2tlbml6ZXIsIExSUGFyc2VyLCBMb2NhbFRva2VuR3JvdXAgfSBmcm9tICdAbGV6ZXIvbHInO1xuaW1wb3J0IHsgc3R5bGVUYWdzLCB0YWdzIH0gZnJvbSAnQGxlemVyL2hpZ2hsaWdodCc7XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3Qgbm9TZW1pID0gMzAyLFxuICBpbmNkZWMgPSAxLFxuICBpbmNkZWNQcmVmaXggPSAyLFxuICBpbnNlcnRTZW1pID0gMzAzLFxuICBzcGFjZXMgPSAzMDUsXG4gIG5ld2xpbmUgPSAzMDYsXG4gIExpbmVDb21tZW50ID0gMyxcbiAgQmxvY2tDb21tZW50ID0gNDtcblxuLyogSGFuZC13cml0dGVuIHRva2VuaXplcnMgZm9yIEphdmFTY3JpcHQgdG9rZW5zIHRoYXQgY2FuJ3QgYmVcbiAgIGV4cHJlc3NlZCBieSBsZXplcidzIGJ1aWx0LWluIHRva2VuaXplci4gKi9cblxuY29uc3Qgc3BhY2UgPSBbOSwgMTAsIDExLCAxMiwgMTMsIDMyLCAxMzMsIDE2MCwgNTc2MCwgODE5MiwgODE5MywgODE5NCwgODE5NSwgODE5NiwgODE5NywgODE5OCwgODE5OSwgODIwMCxcbiAgICAgICAgICAgICAgIDgyMDEsIDgyMDIsIDgyMzIsIDgyMzMsIDgyMzksIDgyODcsIDEyMjg4XTtcblxuY29uc3QgYnJhY2VSID0gMTI1LCBzZW1pY29sb24gPSA1OSwgc2xhc2ggPSA0Nywgc3RhciA9IDQyLFxuICAgICAgcGx1cyA9IDQzLCBtaW51cyA9IDQ1O1xuXG5jb25zdCB0cmFja05ld2xpbmUgPSBuZXcgQ29udGV4dFRyYWNrZXIoe1xuICBzdGFydDogZmFsc2UsXG4gIHNoaWZ0KGNvbnRleHQsIHRlcm0pIHtcbiAgICByZXR1cm4gdGVybSA9PSBMaW5lQ29tbWVudCB8fCB0ZXJtID09IEJsb2NrQ29tbWVudCB8fCB0ZXJtID09IHNwYWNlcyA/IGNvbnRleHQgOiB0ZXJtID09IG5ld2xpbmVcbiAgfSxcbiAgc3RyaWN0OiBmYWxzZVxufSk7XG5cbmNvbnN0IGluc2VydFNlbWljb2xvbiA9IG5ldyBFeHRlcm5hbFRva2VuaXplcigoaW5wdXQsIHN0YWNrKSA9PiB7XG4gIGxldCB7bmV4dH0gPSBpbnB1dDtcbiAgaWYgKChuZXh0ID09IGJyYWNlUiB8fCBuZXh0ID09IC0xIHx8IHN0YWNrLmNvbnRleHQpICYmIHN0YWNrLmNhblNoaWZ0KGluc2VydFNlbWkpKVxuICAgIGlucHV0LmFjY2VwdFRva2VuKGluc2VydFNlbWkpO1xufSwge2NvbnRleHR1YWw6IHRydWUsIGZhbGxiYWNrOiB0cnVlfSk7XG5cbmNvbnN0IG5vU2VtaWNvbG9uID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgc3RhY2spID0+IHtcbiAgbGV0IHtuZXh0fSA9IGlucHV0LCBhZnRlcjtcbiAgaWYgKHNwYWNlLmluZGV4T2YobmV4dCkgPiAtMSkgcmV0dXJuXG4gIGlmIChuZXh0ID09IHNsYXNoICYmICgoYWZ0ZXIgPSBpbnB1dC5wZWVrKDEpKSA9PSBzbGFzaCB8fCBhZnRlciA9PSBzdGFyKSkgcmV0dXJuXG4gIGlmIChuZXh0ICE9IGJyYWNlUiAmJiBuZXh0ICE9IHNlbWljb2xvbiAmJiBuZXh0ICE9IC0xICYmICFzdGFjay5jb250ZXh0ICYmIHN0YWNrLmNhblNoaWZ0KG5vU2VtaSkpXG4gICAgaW5wdXQuYWNjZXB0VG9rZW4obm9TZW1pKTtcbn0sIHtjb250ZXh0dWFsOiB0cnVlfSk7XG5cbmNvbnN0IGluY2RlY1Rva2VuID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgc3RhY2spID0+IHtcbiAgbGV0IHtuZXh0fSA9IGlucHV0O1xuICBpZiAobmV4dCA9PSBwbHVzIHx8IG5leHQgPT0gbWludXMpIHtcbiAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgaWYgKG5leHQgPT0gaW5wdXQubmV4dCkge1xuICAgICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgICAgbGV0IG1heVBvc3RmaXggPSAhc3RhY2suY29udGV4dCAmJiBzdGFjay5jYW5TaGlmdChpbmNkZWMpO1xuICAgICAgaW5wdXQuYWNjZXB0VG9rZW4obWF5UG9zdGZpeCA/IGluY2RlYyA6IGluY2RlY1ByZWZpeCk7XG4gICAgfVxuICB9XG59LCB7Y29udGV4dHVhbDogdHJ1ZX0pO1xuXG5jb25zdCBqc0hpZ2hsaWdodCA9IHN0eWxlVGFncyh7XG4gIFwiZ2V0IHNldCBhc3luYyBzdGF0aWNcIjogdGFncy5tb2RpZmllcixcbiAgXCJmb3Igd2hpbGUgZG8gaWYgZWxzZSBzd2l0Y2ggdHJ5IGNhdGNoIGZpbmFsbHkgcmV0dXJuIHRocm93IGJyZWFrIGNvbnRpbnVlIGRlZmF1bHQgY2FzZVwiOiB0YWdzLmNvbnRyb2xLZXl3b3JkLFxuICBcImluIG9mIGF3YWl0IHlpZWxkIHZvaWQgdHlwZW9mIGRlbGV0ZSBpbnN0YW5jZW9mXCI6IHRhZ3Mub3BlcmF0b3JLZXl3b3JkLFxuICBcImxldCB2YXIgY29uc3QgZnVuY3Rpb24gY2xhc3MgZXh0ZW5kc1wiOiB0YWdzLmRlZmluaXRpb25LZXl3b3JkLFxuICBcImltcG9ydCBleHBvcnQgZnJvbVwiOiB0YWdzLm1vZHVsZUtleXdvcmQsXG4gIFwid2l0aCBkZWJ1Z2dlciBhcyBuZXdcIjogdGFncy5rZXl3b3JkLFxuICBUZW1wbGF0ZVN0cmluZzogdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKSxcbiAgc3VwZXI6IHRhZ3MuYXRvbSxcbiAgQm9vbGVhbkxpdGVyYWw6IHRhZ3MuYm9vbCxcbiAgdGhpczogdGFncy5zZWxmLFxuICBudWxsOiB0YWdzLm51bGwsXG4gIFN0YXI6IHRhZ3MubW9kaWZpZXIsXG4gIFZhcmlhYmxlTmFtZTogdGFncy52YXJpYWJsZU5hbWUsXG4gIFwiQ2FsbEV4cHJlc3Npb24vVmFyaWFibGVOYW1lIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbi9WYXJpYWJsZU5hbWVcIjogdGFncy5mdW5jdGlvbih0YWdzLnZhcmlhYmxlTmFtZSksXG4gIFZhcmlhYmxlRGVmaW5pdGlvbjogdGFncy5kZWZpbml0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSxcbiAgTGFiZWw6IHRhZ3MubGFiZWxOYW1lLFxuICBQcm9wZXJ0eU5hbWU6IHRhZ3MucHJvcGVydHlOYW1lLFxuICBQcml2YXRlUHJvcGVydHlOYW1lOiB0YWdzLnNwZWNpYWwodGFncy5wcm9wZXJ0eU5hbWUpLFxuICBcIkNhbGxFeHByZXNzaW9uL01lbWJlckV4cHJlc3Npb24vUHJvcGVydHlOYW1lXCI6IHRhZ3MuZnVuY3Rpb24odGFncy5wcm9wZXJ0eU5hbWUpLFxuICBcIkZ1bmN0aW9uRGVjbGFyYXRpb24vVmFyaWFibGVEZWZpbml0aW9uXCI6IHRhZ3MuZnVuY3Rpb24odGFncy5kZWZpbml0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSksXG4gIFwiQ2xhc3NEZWNsYXJhdGlvbi9WYXJpYWJsZURlZmluaXRpb25cIjogdGFncy5kZWZpbml0aW9uKHRhZ3MuY2xhc3NOYW1lKSxcbiAgUHJvcGVydHlEZWZpbml0aW9uOiB0YWdzLmRlZmluaXRpb24odGFncy5wcm9wZXJ0eU5hbWUpLFxuICBQcml2YXRlUHJvcGVydHlEZWZpbml0aW9uOiB0YWdzLmRlZmluaXRpb24odGFncy5zcGVjaWFsKHRhZ3MucHJvcGVydHlOYW1lKSksXG4gIFVwZGF0ZU9wOiB0YWdzLnVwZGF0ZU9wZXJhdG9yLFxuICBMaW5lQ29tbWVudDogdGFncy5saW5lQ29tbWVudCxcbiAgQmxvY2tDb21tZW50OiB0YWdzLmJsb2NrQ29tbWVudCxcbiAgTnVtYmVyOiB0YWdzLm51bWJlcixcbiAgU3RyaW5nOiB0YWdzLnN0cmluZyxcbiAgRXNjYXBlOiB0YWdzLmVzY2FwZSxcbiAgQXJpdGhPcDogdGFncy5hcml0aG1ldGljT3BlcmF0b3IsXG4gIExvZ2ljT3A6IHRhZ3MubG9naWNPcGVyYXRvcixcbiAgQml0T3A6IHRhZ3MuYml0d2lzZU9wZXJhdG9yLFxuICBDb21wYXJlT3A6IHRhZ3MuY29tcGFyZU9wZXJhdG9yLFxuICBSZWdFeHA6IHRhZ3MucmVnZXhwLFxuICBFcXVhbHM6IHRhZ3MuZGVmaW5pdGlvbk9wZXJhdG9yLFxuICBBcnJvdzogdGFncy5mdW5jdGlvbih0YWdzLnB1bmN0dWF0aW9uKSxcbiAgXCI6IFNwcmVhZFwiOiB0YWdzLnB1bmN0dWF0aW9uLFxuICBcIiggKVwiOiB0YWdzLnBhcmVuLFxuICBcIlsgXVwiOiB0YWdzLnNxdWFyZUJyYWNrZXQsXG4gIFwieyB9XCI6IHRhZ3MuYnJhY2UsXG4gIFwiSW50ZXJwb2xhdGlvblN0YXJ0IEludGVycG9sYXRpb25FbmRcIjogdGFncy5zcGVjaWFsKHRhZ3MuYnJhY2UpLFxuICBcIi5cIjogdGFncy5kZXJlZk9wZXJhdG9yLFxuICBcIiwgO1wiOiB0YWdzLnNlcGFyYXRvcixcbiAgXCJAXCI6IHRhZ3MubWV0YSxcblxuICBUeXBlTmFtZTogdGFncy50eXBlTmFtZSxcbiAgVHlwZURlZmluaXRpb246IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnR5cGVOYW1lKSxcbiAgXCJ0eXBlIGVudW0gaW50ZXJmYWNlIGltcGxlbWVudHMgbmFtZXNwYWNlIG1vZHVsZSBkZWNsYXJlXCI6IHRhZ3MuZGVmaW5pdGlvbktleXdvcmQsXG4gIFwiYWJzdHJhY3QgZ2xvYmFsIFByaXZhY3kgcmVhZG9ubHkgb3ZlcnJpZGVcIjogdGFncy5tb2RpZmllcixcbiAgXCJpcyBrZXlvZiB1bmlxdWUgaW5mZXJcIjogdGFncy5vcGVyYXRvcktleXdvcmQsXG5cbiAgSlNYQXR0cmlidXRlVmFsdWU6IHRhZ3MuYXR0cmlidXRlVmFsdWUsXG4gIEpTWFRleHQ6IHRhZ3MuY29udGVudCxcbiAgXCJKU1hTdGFydFRhZyBKU1hTdGFydENsb3NlVGFnIEpTWFNlbGZDbG9zZUVuZFRhZyBKU1hFbmRUYWdcIjogdGFncy5hbmdsZUJyYWNrZXQsXG4gIFwiSlNYSWRlbnRpZmllciBKU1hOYW1lU3BhY2VkTmFtZVwiOiB0YWdzLnRhZ05hbWUsXG4gIFwiSlNYQXR0cmlidXRlL0pTWElkZW50aWZpZXIgSlNYQXR0cmlidXRlL0pTWE5hbWVTcGFjZWROYW1lXCI6IHRhZ3MuYXR0cmlidXRlTmFtZSxcbiAgXCJKU1hCdWlsdGluL0pTWElkZW50aWZpZXJcIjogdGFncy5zdGFuZGFyZCh0YWdzLnRhZ05hbWUpXG59KTtcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBzcGVjX2lkZW50aWZpZXIgPSB7X19wcm90b19fOm51bGwsZXhwb3J0OjE0LCBhczoxOSwgZnJvbToyNywgZGVmYXVsdDozMCwgYXN5bmM6MzUsIGZ1bmN0aW9uOjM2LCBleHRlbmRzOjQ2LCB0aGlzOjUwLCB0cnVlOjU4LCBmYWxzZTo1OCwgbnVsbDo3MCwgdm9pZDo3NCwgdHlwZW9mOjc4LCBzdXBlcjo5NiwgbmV3OjEzMCwgZGVsZXRlOjE0NiwgeWllbGQ6MTU1LCBhd2FpdDoxNTksIGNsYXNzOjE2NCwgcHVibGljOjIyMSwgcHJpdmF0ZToyMjEsIHByb3RlY3RlZDoyMjEsIHJlYWRvbmx5OjIyMywgaW5zdGFuY2VvZjoyNDIsIHNhdGlzZmllczoyNDUsIGluOjI0NiwgY29uc3Q6MjQ4LCBpbXBvcnQ6MjgwLCBrZXlvZjozMzUsIHVuaXF1ZTozMzksIGluZmVyOjM0NSwgaXM6MzgxLCBhYnN0cmFjdDo0MDEsIGltcGxlbWVudHM6NDAzLCB0eXBlOjQwNSwgbGV0OjQwOCwgdmFyOjQxMCwgaW50ZXJmYWNlOjQxNywgZW51bTo0MjEsIG5hbWVzcGFjZTo0MjcsIG1vZHVsZTo0MjksIGRlY2xhcmU6NDMzLCBnbG9iYWw6NDM3LCBmb3I6NDU2LCBvZjo0NjUsIHdoaWxlOjQ2OCwgd2l0aDo0NzIsIGRvOjQ3NiwgaWY6NDgwLCBlbHNlOjQ4Miwgc3dpdGNoOjQ4NiwgY2FzZTo0OTIsIHRyeTo0OTgsIGNhdGNoOjUwMiwgZmluYWxseTo1MDYsIHJldHVybjo1MTAsIHRocm93OjUxNCwgYnJlYWs6NTE4LCBjb250aW51ZTo1MjIsIGRlYnVnZ2VyOjUyNn07XG5jb25zdCBzcGVjX3dvcmQgPSB7X19wcm90b19fOm51bGwsYXN5bmM6MTE3LCBnZXQ6MTE5LCBzZXQ6MTIxLCBkZWNsYXJlOjE4MSwgcHVibGljOjE4MywgcHJpdmF0ZToxODMsIHByb3RlY3RlZDoxODMsIHN0YXRpYzoxODUsIGFic3RyYWN0OjE4Nywgb3ZlcnJpZGU6MTg5LCByZWFkb25seToxOTUsIGFjY2Vzc29yOjE5NywgbmV3OjM4NX07XG5jb25zdCBzcGVjX0xlc3NUaGFuID0ge19fcHJvdG9fXzpudWxsLFwiPFwiOjEzN307XG5jb25zdCBwYXJzZXIgPSBMUlBhcnNlci5kZXNlcmlhbGl6ZSh7XG4gIHZlcnNpb246IDE0LFxuICBzdGF0ZXM6IFwiJDZbT2BRVU9PTyVRUVVPT08nVFFXT09QKGJPU09PTypwUShDak8nI0NmTyp3T3BPJyNDZ08rVk8hYk8nI0NnTytlTzA3YE8nI0RaTy12UVVPJyNEYU8uV1FVTycjRGxPJVFRVU8nI0R2TzBbUVVPJyNFT09PUShDWScjRVcnI0VXTzB1UVNPJyNFVE9PUU8nI0VpJyNFaU9PUU8nI0liJyNJYk8wfVFTTycjR2tPMVlRU08nI0VoTzFfUVNPJyNFaE8zYVEoQ2pPJyNKY082UVEoQ2pPJyNKZE82blFTTycjRldPNnNRI3RPJyNGb09PUShDWScjRmAnI0ZgTzdPTyZqTycjRmBPN15RLFVPJyNGdk84dFFTTycjRnVPT1EoQ1knI0pkJyNKZE9PUShDVycjSmMnI0pjT09RUScjS08nI0tPTzh5UVNPJyNJT085T1EoQ1tPJyNJUE9PUVEnI0pQJyNKUE9PUVEnI0lUJyNJVFFgUVVPT08lUVFVTycjRG5POVdRVU8nI0R6TyVRUVVPJyNEfE85X1FTTycjR2tPOWRRLFVPJyNDbE85clFTTycjRWdPOX1RU08nI0VyTzpTUSxVTycjRl9POnFRU08nI0drTzp2UVNPJyNHb087UlFTTycjR29PO2FRU08nI0dyTzthUVNPJyNHc087YVFTTycjR3VPOV9RU08nI0d4TzxRUVNPJyNHe089Y1FTTycjQ2JPPXNRU08nI0hYTz17UVNPJyNIX089e1FTTycjSGFPYFFVTycjSGNPPXtRU08nI0hlTz17UVNPJyNIaE8+UVFTTycjSG5PPlZRKENdTycjSHRPJVFRVU8nI0h2Tz5iUShDXU8nI0h4Tz5tUShDXU8nI0h6TzlPUShDW08nI0h8Tz54UShDak8nI0NmTz96UVdPJyNEZlFPUVNPT09AYlFTTycjRVBPOWRRLFVPJyNFZ09AbVFTTycjRWdPQHhRYE8nI0ZfT09RUScjQ2QnI0NkT09RKENXJyNEaycjRGtPT1EoQ1cnI0pnJyNKZ08lUVFVTycjSmdPT1FPJyNKaycjSmtPT1FPJyNJXycjSV9PQXhRV08nI0VgT09RKENXJyNFXycjRV9PQnRRKENgTycjRWBPQ09RV08nI0VTT09RTycjSmonI0pqT0NkUVdPJyNKa09EcVFXTycjRVNPQ09RV08nI0VgUEVPTz9NcE8nI0NgUE9PTylDRG4pQ0RuT09PTycjSVUnI0lVT0VaT3BPLDU5Uk9PUShDWSw1OVIsNTlST09PTycjSVYnI0lWT0VpTyFiTyw1OVJPJVFRVU8nI0RdT09PTycjSVgnI0lYT0V3TzA3YE8sNTl1T09RKENZLDU5dSw1OXVPRlZRVU8nI0lZT0ZqUVNPJyNKZU9IbFFiTycjSmVPK3NRVU8nI0plT0hzUVNPLDU5e09JWlFTTycjRWlPSWhRU08nI0pzT0lzUVNPJyNKck9Jc1FTTycjSnJPSXtRU08sNTtWT0pRUVNPJyNKcU9PUShDWSw1OlcsNTpXT0pYUVVPLDU6V09MWVEoQ2pPLDU6Yk9MeVFTTyw1OmpPTWRRKENbTycjSnBPTWtRU08nI0pvTzp2UVNPJyNKb09OUFFTTycjSm9PTlhRU08sNTtVT05eUVNPJyNKb08hIWZRYk8nI0pkT09RKENZJyNDZicjQ2ZPJVFRVU8nI0VPTyEjVVFgTyw1Om9PT1FPJyNKbCcjSmxPT1FPLUU8YC1FPGBPOV9RU08sNT1WTyEjbFFTTyw1PVZPISNxUVVPLDU7U08hJXRRLFVPJyNFZE8hJ1hRU08sNTtTTyEocVEsVU8nI0RwTyEoeFFVTycjRHVPISlTUVdPLDU7XU8hKVtRV08sNTtdTyVRUVVPLDU7XU9PUVEnI0ZPJyNGT09PUVEnI0ZRJyNGUU8lUVFVTyw1O15PJVFRVU8sNTteTyVRUVVPLDU7Xk8lUVFVTyw1O15PJVFRVU8sNTteTyVRUVVPLDU7Xk8lUVFVTyw1O15PJVFRVU8sNTteTyVRUVVPLDU7Xk8lUVFVTyw1O15PJVFRVU8sNTteT09RUScjRlUnI0ZVTyEpalFVTyw1O29PT1EoQ1ksNTt0LDU7dE9PUShDWSw1O3UsNTt1TyErbVFTTyw1O3VPT1EoQ1ksNTt2LDU7dk8lUVFVTycjSWZPISt1UShDW08sNTxjTyEldFEsVU8sNTteTyEsZFEsVU8sNTteTyVRUVVPLDU7ck8hLGtRI3RPJyNGZU8hLWhRI3RPJyNKd08hLVNRI3RPJyNKd08hLW9RI3RPJyNKd09PUU8nI0p3JyNKd08hLlRRI3RPLDU7fU9PT08sNTxaLDU8Wk8hLmZRVU8nI0ZxT09PTycjSWUnI0llTzdPTyZqTyw1O3pPIS5tUSN0TycjRnNPT1EoQ1ksNTt6LDU7ek8hL15RN1tPJyNDck9PUShDWScjQ3YnI0N2TyEvcVFTTycjQ3ZPIS92TzA3YE8nI0N6TyEwZFEsVU8sNTxgTyEwa1FTTyw1PGJPITJRUU1oTycjR1FPITJfUVNPJyNHUk8hMmRRU08nI0dSTyEyaVFNaE8nI0dWTyEzaFFXTycjR1pPITRaUTdbTycjSl5PT1EoQ1knI0peJyNKXk8hNGVRU08nI0pdTyE0c1FTTycjSltPITR7UVNPJyNDcU9PUShDWScjQ3QnI0N0T09RKENZJyNETycjRE9PT1EoQ1knI0RRJyNEUU8weFFTTycjRFNPISdeUSxVTycjRnhPISdeUSxVTycjRnpPITVUUVNPJyNGfE8hNVlRU08nI0Z9TyEyZFFTTycjR1RPISdeUSxVTycjR1lPITVfUVNPJyNFak8hNXxRU08sNTxhT2BRVU8sNT5qT09RUScjSlgnI0pYT09RUSw1PmssNT5rT09RUS1FPFItRTxSTyE3e1EoQ2pPLDU6WU8hOmlRKENqTyw1OmZPJVFRVU8sNTpmTyE9U1EoQ2pPLDU6aE9PUShDVycjQ28nI0NvTyE9c1EsVU8sNT1WTyE+UlEoQ1tPJyNKWU84dFFTTycjSllPIT5kUShDW08sNTlXTyE+b1FXTyw1OVdPIT53USxVTyw1OVdPOWRRLFVPLDU5V08hP1NRU08sNTtTTyE/W1FTTycjSFdPIT9tUVNPJyNLU08lUVFVTyw1O3dPIT91UVdPLDU7eU8hP3pRU08sNT1xTyFAUFFTTyw1PXFPIUBVUVNPLDU9cU85T1EoQ1tPLDU9cU8hQGRRU08nI0VrTyFBXlFXTycjRWxPT1EoQ1cnI0pxJyNKcU8hQWVRKENbTycjS1BPOU9RKENbTyw1PVpPO2FRU08sNT1hT09RTycjQ3InI0NyTyFBcFFXTyw1PV5PIUF4USxVTyw1PV9PIUJUUVNPLDU9YU8hQllRYE8sNT1kTz5RUVNPJyNHfU85X1FTTycjSFBPIUJiUVNPJyNIUE85ZFEsVU8nI0hSTyFCZ1FTTycjSFJPT1FRLDU9Zyw1PWdPIUJsUVNPJyNIU08hQnRRU08nI0NsTyFCeVFTTyw1OHxPIUNUUVNPLDU4fE8hRV1RVU8sNTh8T09RUSw1OHwsNTh8TyFFalEoQ1tPLDU4fE8lUVFVTyw1OHxPIUV1UVVPJyNIWk9PUVEnI0hbJyNIW09PUVEnI0hdJyNIXU9gUVVPLDU9c08hRlZRU08sNT1zT2BRVU8sNT15T2BRVU8sNT17TyFGW1FTTyw1PX1PYFFVTyw1PlBPIUZhUVNPLDU+U08hRmZRVU8sNT5ZT09RUSw1PmAsNT5gTyVRUVVPLDU+YE85T1EoQ1tPLDU+Yk9PUVEsNT5kLDU+ZE8hSm1RU08sNT5kT09RUSw1PmYsNT5mTyFKbVFTTyw1PmZPT1FRLDU+aCw1PmhPIUpyUVdPJyNEWE8lUVFVTycjSmdPIUthUVdPJyNKZ08hTE9RV08nI0RnTyFMYVFXTycjRGdPIU5yUVVPJyNEZ08hTnlRU08nI0pmTyMgUlFTTyw1OlFPIyBXUVNPJyNFbU8jIGZRU08nI0p0TyMgblFTTyw1O1dPIyBzUVdPJyNEZ08jIVFRV08nI0VST09RKENZLDU6ayw1OmtPJVFRVU8sNTprTyMhWFFTTyw1OmtPPlFRU08sNTtSTyE+b1FXTyw1O1JPIT53USxVTyw1O1JPOWRRLFVPLDU7Uk8jIWFRU08sNUBSTyMhZlEhTFFPLDU6b09PUU8tRTxdLUU8XU8jI2xRKENgTyw1OnpPQ09RV08sNTpuTyMjdlFXTyw1Om5PQ09RV08sNTp6TyE+ZFEoQ1tPLDU6bk9PUShDVycjRWMnI0VjT09RTyw1OnosNTp6TyVRUVVPLDU6ek8jJFRRKENbTyw1OnpPIyRgUShDW08sNTp6TyE+b1FXTyw1Om5PT1FPLDU7USw1O1FPIyRuUShDW08sNTp6UE9PTycjSVMnI0lTUCMlU08/TXBPLDU4elBPT08sNTh6LDU4ek9PT08tRTxTLUU8U09PUShDWTFHLm0xRy5tT09PTy1FPFQtRTxUTyMlX1FgTyw1OXdPT09PLUU8Vi1FPFZPT1EoQ1kxRy9hMUcvYU8jJWRRYk8sNT50TytzUVVPLDU+dE9PUU8sNT56LDU+ek8jJW5RVU8nI0lZT09RTy1FPFctRTxXTyMle1FTTyw1QFBPIyZUUWJPLDVAUE8jJltRU08sNUBeT09RKENZMUcvZzFHL2dPJVFRVU8sNUBfTyMmZFFTTycjSWBPT1FPLUU8Xi1FPF5PIyZbUVNPLDVAXk9PUShDVzFHMHExRzBxT09RKENZMUcvcjFHL3JPT1EoQ1kxRzBVMUcwVU8lUVFVTyw1QFtPIyZ4UShDW08sNUBbTyMnWlEoQ1tPLDVAW08jJ2JRU08sNUBaTzp2UVNPLDVAWk8jJ2pRU08sNUBaTyMneFFTTycjSWNPIydiUVNPLDVAWk9PUShDVzFHMHAxRzBwTyEpU1FXTyw1OnFPISlfUVdPLDU6cU9PUU8sNTpzLDU6c08jKGpRU08sNTpzTyMoclEsVU8xRzJxTzlfUVNPMUcycU9PUShDWTFHMG4xRzBuTyMpUVEoQ2pPMUcwbk8jKlZRKENoTyw1O09PT1EoQ1knI0dQJyNHUE8jKnNRKENqTycjSl5PISNxUVVPMUcwbk8jLHtRLFVPJyNKaE8jLVZRU08sNTpbTyMtW1FiTycjSmlPJVFRVU8nI0ppTyMtZlFTTyw1OmFPT1EoQ1knI0RYJyNEWE9PUShDWTFHMHcxRzB3TyVRUVVPMUcwd09PUShDWTFHMWExRzFhTyMta1FTTzFHMHdPIzBTUShDak8xRzB4TyMwWlEoQ2pPMUcweE8jMnRRKENqTzFHMHhPIzJ7UShDak8xRzB4TyM1VlEoQ2pPMUcweE8jNW1RKENqTzFHMHhPIzhnUShDak8xRzB4TyM4blEoQ2pPMUcweE8jO1hRKENqTzFHMHhPIztgUShDak8xRzB4TyM9V1EoQ2pPMUcweE8jQFdRJElVTycjQ2ZPI0JVUSRJVU8xRzFaTyNCXVEkSVVPJyNKZE8hK3BRU08xRzFhTyNCbVEoQ2pPLDU/UU9PUShDVy1FPGQtRTxkTyNDYVEoQ2pPMUcweE9PUShDWTFHMHgxRzB4TyNFbFEoQ2pPMUcxXk8jRmBRI3RPLDU8Uk8jRmhRI3RPLDU8U08jRnBRI3RPJyNGak8jR1hRU08nI0ZpT09RTycjSngnI0p4T09RTycjSWQnI0lkTyNHXlEjdE8xRzFpT09RKENZMUcxaTFHMWlPT09PMUcxdDFHMXRPI0dvUSRJVU8nI0pjTyNHeVFTTyw1PF1PISlqUVVPLDU8XU9PT08tRTxjLUU8Y09PUShDWTFHMWYxRzFmTyNIT1FXTycjSndPT1EoQ1ksNTxfLDU8X08jSFdRV08sNTxfT09RKENZLDU5Yiw1OWJPISV0USxVTycjQ3xPT09PJyNJVycjSVdPI0hdTzA3YE8sNTlmT09RKENZLDU5Ziw1OWZPJVFRVU8xRzF6TyE1WVFTTycjSWhPI0hoUVNPLDU8c09PUShDWSw1PHAsNTxwT09RTycjR2YnI0dmTyEnXlEsVU8sNT1QT09RTycjR2gnI0doTyEnXlEsVU8sNT1STyEldFEsVU8sNT1UT09RTzFHMXwxRzF8TyNIdlFgTycjQ29PI0laUWBPLDU8bE8jSWJRU08nI0p7TzlfUVNPJyNKe08jSXBRU08sNTxuTyEnXlEsVU8sNTxtTyNJdVFTTycjR1NPI0pRUVNPLDU8bU8jSlZRYE8nI0dQTyNKZFFgTycjSnxPI0puUVNPJyNKfE8hJXRRLFVPJyNKfE8jSnNRU08sNTxxTyNKeFFXTycjR1tPITNjUVdPJyNHW08jS1pRU08nI0deTyNLYFFTTycjR2BPITJkUVNPJyNHY08jS2VRKENbTycjSWpPI0twUVdPLDU8dU9PUShDWSw1PHUsNTx1TyNLd1FXTycjR1tPI0xWUVdPJyNHXU8jTF9RV08nI0ddT09RKENZLDU9VSw1PVVPISdeUSxVTyw1P3dPISdeUSxVTyw1P3dPI0xkUVNPJyNJa08jTG9RU08sNT92TyNMd1FTTyw1OV1PI01oUSxVTyw1OW5PT1EoQ1ksNTluLDU5bk8jTlpRLFVPLDU8ZE8jTnxRLFVPLDU8Zk8/clFTTyw1PGhPT1EoQ1ksNTxpLDU8aU8kIFdRU08sNTxvTyQgXVEsVU8sNTx0TyQgbVFTTycjSm9PISNxUVVPMUcxe08kIHJRU08xRzF7T09RUTFHNFUxRzRVT09RKENZMUcvdDFHL3RPISttUVNPMUcvdE8kI3FRKENqTzFHMFFPT1FRMUcycTFHMnFPISV0USxVTzFHMnFPJVFRVU8xRzJxTyQkYlFTTzFHMnFPJCRtUSxVTycjRWRPT1EoQ1csNT90LDU/dE8kJHdRKENbTyw1P3RPT1FRMUcucjFHLnJPIT5kUShDW08xRy5yTyE+b1FXTzFHLnJPIT53USxVTzFHLnJPJCVZUVNPMUcwbk8kJV9RU08nI0NmTyQlalFTTycjS1RPJCVyUVNPLDU9ck8kJXdRU08nI0tUTyQlfFFTTycjS1RPJCZYUVNPJyNJc08kJmdRU08sNUBuTyQmb1FiTzFHMWNPT1EoQ1kxRzFlMUcxZU85X1FTTzFHM11PP3JRU08xRzNdTyQmdlFTTzFHM11PJCZ7UVNPMUczXU9PUVExRzNdMUczXU86dlFTTycjSnJPOnZRU08nI0VtTyVRUVVPJyNFbU86dlFTTycjSW1PJCdRUShDW08sNUBrT09RUTFHMnUxRzJ1TyFCVFFTTzFHMntPISV0USxVTzFHMnhPJCddUVNPMUcyeE9PUVExRzJ5MUcyeU8hJXRRLFVPMUcyeU8kJ2JRU08xRzJ5TyQnalFXTycjR3dPT1FRMUcyezFHMntPITNjUVdPJyNJb08hQllRYE8xRzNPT09RUTFHM08xRzNPT09RUSw1PWksNT1pTyQnclEsVU8sNT1rTzlfUVNPLDU9a08jS2BRU08sNT1tTzh0UVNPLDU9bU8hPm9RV08sNT1tTyE+d1EsVU8sNT1tTzlkUSxVTyw1PW1PJChRUVNPJyNLUk8kKF1RU08sNT1uT09RUTFHLmgxRy5oTyQoYlEoQ1tPMUcuaE8/clFTTzFHLmhPJChtUVNPMUcuaE85T1EoQ1tPMUcuaE8kKnJRYk8sNUBwTyQrU1FTTyw1QHBPJCtfUVVPLDU9dU8kK2ZRU08sNT11Tzp2UVNPLDVAcE9PUVExRzNfMUczX09gUVVPMUczX09PUVExRzNlMUczZU9PUVExRzNnMUczZ089e1FTTzFHM2lPJCtrUVVPMUcza08kL2xRVU8nI0hqT09RUTFHM24xRzNuTyQveVFTTycjSHBPPlFRU08nI0hyT09RUTFHM3QxRzN0TyQwUlFVTzFHM3RPOU9RKENbTzFHM3pPT1FRMUczfDFHM3xPT1EoQ1cnI0dXJyNHV085T1EoQ1tPMUc0T085T1EoQ1tPMUc0UU8kNFZRU08sNUBSTyEpalFVTyw1O1hPOnZRU08sNTtYTz5RUVNPLDU6Uk8hKWpRVU8sNTpSTyE+b1FXTyw1OlJPJDRbUSRJVU8sNTpST09RTyw1O1gsNTtYTyQ0ZlFXTycjSVpPJDR8UVNPLDVAUU9PUShDWTFHL2wxRy9sTyQ1VVFXTycjSWFPJDVgUVNPLDVAYE9PUShDVzFHMHIxRzByTyFMYVFXTyw1OlJPT1FPJyNJXicjSV5PJDVoUVdPLDU6bU9PUShDWSw1Om0sNTptTyMhW1FTTzFHMFZPT1EoQ1kxRzBWMUcwVk8lUVFVTzFHMFZPT1EoQ1kxRzBtMUcwbU8+UVFTTzFHMG1PIT5vUVdPMUcwbU8hPndRLFVPMUcwbU9PUShDVzFHNW0xRzVtTyE+ZFEoQ1tPMUcwWU9PUU8xRzBmMUcwZk8lUVFVTzFHMGZPJDVvUShDW08xRzBmTyQ1elEoQ1tPMUcwZk8hPm9RV08xRzBZT0NPUVdPMUcwWU8kNllRKENbTzFHMGZPT1FPMUcwWTFHMFlPJDZuUShDak8xRzBmUE9PTy1FPFEtRTxRUE9PTzFHLmYxRy5mT09PTzFHL2MxRy9jTyQ2eFFgTyw1PGNPJDdRUWJPMUc0YE9PUU8xRzRmMUc0Zk8lUVFVTyw1PnRPJDdbUVNPMUc1a08kN2RRU08xRzV4TyQ3bFFiTzFHNXlPOnZRU08sNT56TyQ3dlEoQ2pPMUc1dk8lUVFVTzFHNXZPJDhXUShDW08xRzV2TyQ4aVFTTzFHNXVPJDhpUVNPMUc1dU86dlFTTzFHNXVPJDhxUVNPLDU+fU86dlFTTyw1Pn1PT1FPLDU+fSw1Pn1PJDlWUVNPLDU+fU8kIG1RU08sNT59T09RTy1FPGEtRTxhT09RTzFHMF0xRzBdT09RTzFHMF8xRzBfTyErcFFTTzFHMF9PT1FRNysoXTcrKF1PISV0USxVTzcrKF1PJVFRVU83KyhdTyQ5ZVFTTzcrKF1PJDlwUSxVTzcrKF1PJDpPUShDak8sNTluTyQ8V1EoQ2pPLDU8ZE8kPmNRKENqTyw1PGZPJEBuUShDak8sNTx0T09RKENZNysmWTcrJllPJENQUShDak83KyZZTyRDc1EsVU8nI0lbTyRDfVFTTyw1QFNPT1EoQ1kxRy92MUcvdk8kRFZRVU8nI0ldTyREZFFTTyw1QFRPJERsUWJPLDVAVE9PUShDWTFHL3sxRy97TyREdlFTTzcrJmNPT1EoQ1k3KyZjNysmY08kRHtRJElVTyw1OmJPJVFRVU83KyZ1TyRFVlEkSVVPLDU6WU8kRWRRJElVTyw1OmZPJEVuUSRJVU8sNTpoT09RKENZNysmezcrJntPT1FPMUcxbTFHMW1PT1FPMUcxbjFHMW5PJEV4USN0Tyw1PFVPISlqUVVPLDU8VE9PUU8tRTxiLUU8Yk9PUShDWTcrJ1Q3KydUT09PTzcrJ2A3KydgT09PTzFHMXcxRzF3TyRGVFFTTzFHMXdPT1EoQ1kxRzF5MUcxeU8kRllRYE8sNTloT09PTy1FPFUtRTxVT09RKENZMUcvUTFHL1FPJEZhUShDak83KydmT09RKENZLDU/Uyw1P1NPJEdUUVNPLDU/U09PUShDWTFHMl8xRzJfUCRHWVFTTycjSWhQT1EoQ1ktRTxmLUU8Zk8kR3xRLFVPMUcya08kSG9RLFVPMUcybU8kSHlRYE8xRzJvT09RKENZMUcyVzFHMldPJElRUVNPJyNJZ08kSWBRU08sNUBnTyRJYFFTTyw1QGdPJEloUVNPLDVAZ08kSXNRU08sNUBnT09RTzFHMlkxRzJZTyRKUlEsVU8xRzJYTyEnXlEsVU8xRzJYTyRKY1FNaE8nI0lpTyRKc1FTTyw1QGhPISV0USxVTyw1QGhPJEp7UWBPLDVAaE9PUShDWTFHMl0xRzJdT09RKENXLDU8diw1PHZPT1EoQ1csNTx3LDU8d08kIG1RU08sNTx3T0JvUVNPLDU8d08hPm9RV08sNTx2T09RTycjR18nI0dfTyRLVlFTTyw1PHhPT1EoQ1csNTx6LDU8ek8kIG1RU08sNTx9T09RTyw1P1UsNT9VT09RTy1FPGgtRTxoT09RKENZMUcyYTFHMmFPITNjUVdPLDU8dk8kS19RU08sNTx3TyNLWlFTTyw1PHhPITNjUVdPLDU8d08kS2pRLFVPMUc1Y08kS3RRLFVPMUc1Y09PUU8sNT9WLDU/Vk9PUU8tRTxpLUU8aU9PUU8xRy53MUcud08hP3VRV08sNTlwTyVRUVVPLDU5cE8kTFJRU08xRzJTTyEnXlEsVU8xRzJaTyRMV1EoQ2pPNysnZ09PUShDWTcrJ2c3KydnTyEjcVFVTzcrJ2dPT1EoQ1k3KyVgNyslYE8kTHpRYE8nI0p9TyMhW1FTTzcrKF1PJE1VUWJPNysoXU8kOWhRU083KyhdTyRNXVEoQ2hPJyNDZk8kTXBRKENoTyw1PHtPJE5iUVNPLDU8e09PUShDVzFHNWAxRzVgT09RUTcrJF43KyReTyE+ZFEoQ1tPNyskXk8hPm9RV083KyReTyEjcVFVTzcrJllPJE5nUVNPJyNJck8kTntRU08sNUBvT09RTzFHM14xRzNeTzlfUVNPLDVAb08kTntRU08sNUBvTyUgVFFTTyw1QG9PT1FPLDU/Xyw1P19PT1FPLUU8cS1FPHFPT1EoQ1k3KyZ9NysmfU8lIFlRU083Kyh3TzlPUShDW083Kyh3TzlfUVNPNysod08/clFTTzcrKHdPJSBfUVNPLDU7WE9PUShDVyw1P1gsNT9YT09RKENXLUU8ay1FPGtPT1FRNysoZzcrKGdPJSBkUShDaE83KyhkTyEldFEsVU83KyhkTyUgblFgTzcrKGVPT1FRNysoZTcrKGVPISV0USxVTzcrKGVPJSB1UVNPJyNLUU8lIVFRU08sNT1jT09RTyw1P1osNT9aT09RTy1FPG0tRTxtT09RUTcrKGo3KyhqTyUjYVFXTycjSFFPT1FRMUczVjFHM1ZPISV0USxVTzFHM1ZPJVFRVU8xRzNWTyUjaFFTTzFHM1ZPJSNzUSxVTzFHM1ZPOU9RKENbTzFHM1hPI0tgUVNPMUczWE84dFFTTzFHM1hPIT5vUVdPMUczWE8hPndRLFVPMUczWE8lJFJRU08nI0lxTyUkXlFTTyw1QG1PJSRmUVdPLDVAbU9PUShDVzFHM1kxRzNZT09RUTcrJFM3KyRTTz9yUVNPNyskU085T1EoQ1tPNyskU08lJHFRU083KyRTTyVRUVVPMUc2W08lUVFVTzFHNl1PJSR2UVVPMUczYU8lJH1RU08xRzNhTyUlU1FVTzFHM2FPJSVaUShDW08xRzZbT09RUTcrKHk3Kyh5TzlPUShDW083KylUT2BRVU83KylWT09RUScjS1cnI0tXT09RUScjSXQnI0l0TyUlZVFVTyw1PlVPT1FRLDU+VSw1PlVPJVFRVU8nI0hrTyUlclFTTycjSG1PT1FRLDU+Wyw1PltPOnZRU08sNT5bT09RUSw1Pl4sNT5eT09RUTcrKWA3KylgT09RUTcrKWY3KylmT09RUTcrKWo3KylqT09RUTcrKWw3KylsTyUld1FXTzFHNW1PJSZdUSRJVU8xRzBzTyUmZ1FTTzFHMHNPT1FPMUcvbTFHL21PJSZyUSRJVU8xRy9tTz5RUVNPMUcvbU8hKWpRVU8nI0RnT09RTyw1PnUsNT51T09RTy1FPFgtRTxYT09RTyw1PnssNT57T09RTy1FPF8tRTxfTyE+b1FXTzFHL21PT1FPLUU8Wy1FPFtPT1EoQ1kxRzBYMUcwWE9PUShDWTcrJXE3KyVxTyMhW1FTTzcrJXFPT1EoQ1k3KyZYNysmWE8+UVFTTzcrJlhPIT5vUVdPNysmWE9PUU83KyV0NysldE8kNm5RKENqTzcrJlFPT1FPNysmUTcrJlFPJVFRVU83KyZRTyUmfFEoQ1tPNysmUU8hPmRRKENbTzcrJXRPIT5vUVdPNysldE8lJ1hRKENbTzcrJlFPJSdnUShDak83KytiTyVRUVVPNysrYk8lJ3dRU083KythTyUnd1FTTzcrK2FPT1FPMUc0aTFHNGlPOnZRU08xRzRpTyUoUFFTTzFHNGlPT1FPNysleTcrJXlPIyFbUVNPPDxLd08kTVVRYk88PEt3TyUoX1FTTzw8S3dPT1FRPDxLdzw8S3dPISV0USxVTzw8S3dPJVFRVU88PEt3TyUoZ1FTTzw8S3dPJShyUShDak8xRzJrTyUqfVEoQ2pPMUcybU8lLVlRKENqTzFHMlhPJS9rUSxVTyw1PnZPT1FPLUU8WS1FPFlPJS91UWJPLDU+d08lUVFVTyw1PndPT1FPLUU8Wi1FPFpPJTBQUVNPMUc1b09PUShDWTw8SX08PEl9TyUwWFEkSVVPMUcwbk8lMmNRJElVTzFHMHhPJTJqUSRJVU8xRzB4TyU0blEkSVVPMUcweE8lNHVRJElVTzFHMHhPJTZqUSRJVU8xRzB4TyU3UVEkSVVPMUcweE8lOWVRJElVTzFHMHhPJTlsUSRJVU8xRzB4TyU7cFEkSVVPMUcweE8lO3dRJElVTzFHMHhPJT1vUSRJVU8xRzB4TyU+U1EoQ2pPPDxKYU8lP1hRJElVTzFHMHhPJUB9USRJVU8nI0peTyVDUVEkSVVPMUcxXk8lQ19RJElVTzFHMFFPISlqUVVPJyNGbE9PUU8nI0p5JyNKeU9PUU8xRzFwMUcxcE8lQ2lRU08xRzFvTyVDblEkSVVPLDU/UU9PT083KydjNysnY09PT08xRy9TMUcvU09PUShDWTFHNG4xRzRuTyEnXlEsVU83KyhaTyVDeFFTTyw1P1JPOV9RU08sNT9ST09RTy1FPGUtRTxlTyVEV1FTTzFHNlJPJURXUVNPMUc2Uk8lRGBRU08xRzZSTyVEa1EsVU83KydzTyVEe1FgTyw1P1RPJUVWUVNPLDU/VE8hJXRRLFVPLDU/VE9PUU8tRTxnLUU8Z08lRVtRYE8xRzZTTyVFZlFTTzFHNlNPT1EoQ1cxRzJjMUcyY08kIG1RU08xRzJjT09RKENXMUcyYjFHMmJPJUVuUVNPMUcyZE8hJXRRLFVPMUcyZE9PUShDVzFHMmkxRzJpTyE+b1FXTzFHMmJPQm9RU08xRzJjTyVFc1FTTzFHMmRPJUV7UVNPMUcyY08hJ15RLFVPNysqfU9PUShDWTFHL1sxRy9bTyVGV1FTTzFHL1tPT1EoQ1k3KyduNysnbk8lRl1RLFVPNysndU8lRm1RKENqTzw8S1JPT1EoQ1k8PEtSPDxLUk8hJXRRLFVPJyNJbE8lR2FRU08sNUBpTyEldFEsVU8xRzJnT09RUTw8R3g8PEd4TyE+ZFEoQ1tPPDxHeE8lR2lRKENqTzw8SXRPT1EoQ1k8PEl0PDxJdE9PUU8sNT9eLDU/Xk8lSF1RU08sNT9eTyQlfFFTTyw1P15PT1FPLUU8cC1FPHBPJUhiUVNPMUc2Wk8lSGJRU08xRzZaTzlfUVNPMUc2Wk8/clFTTzw8TGNPT1FRPDxMYzw8TGNPJUhqUVNPPDxMY085T1EoQ1tPPDxMY08lSG9RU08xRzBzT09RUTw8TE88PExPTyUgZFEoQ2hPPDxMT09PUVE8PExQPDxMUE8lIG5RYE88PExQTyVIdFFXTycjSW5PJUlQUVNPLDVAbE8hKWpRVU8sNUBsT09RUTFHMn0xRzJ9TyVJWFFVTycjSmdPT1FPJyNJcCcjSXBPOU9RKENbTycjSXBPJUljUVdPLDU9bE9PUVEsNT1sLDU9bE8lSWpRV08nI0VgTyVKT1FTTzcrKHFPJUpUUVNPNysocU9PUVE3KyhxNysocU8hJXRRLFVPNysocU8lUVFVTzcrKHFPJUpdUVNPNysocU9PUVE3KyhzNysoc085T1EoQ1tPNysoc08jS2BRU083KyhzTzh0UVNPNysoc08hPm9RV083KyhzTyVKaFFTTyw1P11PT1FPLUU8by1FPG9PT1FPJyNIVCcjSFRPJUpzUVNPMUc2WE85T1EoQ1tPPDxHbk9PUVE8PEduPDxHbk8/clFTTzw8R25PJUp7UVNPNysrdk8lS1FRU083Kyt3T09RUTcrKHs3Kyh7TyVLVlFTTzcrKHtPJUtbUVVPNysoe08lS2NRU083Kyh7TyVRUVVPNysrdk8lUVFVTzcrK3dPT1FRPDxMbzw8TG9PT1FRPDxMcTw8THFPT1FRLUU8ci1FPHJPT1FRMUczcDFHM3BPJUtoUVNPLDU+Vk9PUVEsNT5YLDU+WE8lS21RU08xRzN2Tzp2UVNPNysmX08hKWpRVU83KyZfT09RTzcrJVg3KyVYTyVLclEkSVVPMUc1eU8+UVFTTzcrJVhPT1EoQ1k8PEldPDxJXU9PUShDWTw8SXM8PElzTz5RUVNPPDxJc09PUU88PElsPDxJbE8kNm5RKENqTzw8SWxPJVFRVU88PElsT09RTzw8SWA8PElgTyE+ZFEoQ1tPPDxJYE8lS3xRKENbTzw8SWxPJUxYUShDak88PE58TyVMaVFTTzw8TntPT1FPNysqVDcrKlRPOnZRU083KypUT09RUUFOQWNBTkFjTyVMcVFTT0FOQWNPISV0USxVT0FOQWNPIyFbUVNPQU5BY08kTVVRYk9BTkFjTyVRUVVPQU5BY08lTHlRKENqTzcrJ3NPJiBbUShDak83Kyd1TyYjbVFiTzFHNGNPJiN3USRJVU83KyZZTyYkVVEkSVVPLDU5bk8mJlhRJElVTyw1PGRPJihbUSRJVU8sNTxmTyYqX1EkSVVPLDU8dE8mLFRRJElVTzcrJ2ZPJixiUSRJVU83KydnTyYsb1FTTyw1PFdPT1FPNysnWjcrJ1pPJix0USxVTzw8S3VPT1FPMUc0bTFHNG1PJix7UVNPMUc0bU8mLVdRU08xRzRtTyYtZlFTTzcrK21PJi1mUVNPNysrbU8hJXRRLFVPMUc0b08mLW5RYE8xRzRvTyYteFFTTzcrK25PT1EoQ1c3Kyd9NysnfU8kIG1RU083KyhPTyYuUVFgTzcrKE9PT1EoQ1c3Kyd8NysnfE8kIG1RU083Kyd9TyYuWFFTTzcrKE9PISV0USxVTzcrKE9PQm9RU083Kyd9TyYuXlEsVU88PE5pT09RKENZNyskdjcrJHZPJi5oUWBPLDU/V09PUU8tRTxqLUU8ak8mLnJRKENoTzcrKFJPT1FRQU49ZEFOPWRPOV9RU08xRzR4T09RTzFHNHgxRzR4TyYvU1FTTzFHNHhPJi9YUVNPNysrdU8mL1hRU083Kyt1TzlPUShDW09BTkF9Tz9yUVNPQU5BfU9PUVFBTkF9QU5BfU9PUVFBTkFqQU5Bak9PUVFBTkFrQU5Ba08mL2FRU08sNT9ZT09RTy1FPGwtRTxsTyYvbFEkSVVPMUc2V08mMXxRYk8nI0NmT09RTyw1P1ssNT9bT09RTy1FPG4tRTxuT09RUTFHM1cxRzNXTyVJWFFVTyw1PHhPT1FRPDxMXTw8TF1PISV0USxVTzw8TF1PJUpPUVNPPDxMXU8mMldRU088PExdTyVRUVVPPDxMXU9PUVE8PExfPDxMX085T1EoQ1tPPDxMX08jS2BRU088PExfTzh0UVNPPDxMX08mMmBRV08xRzR3TyYya1FTTzcrK3NPT1FRQU49WUFOPVlPOU9RKENbT0FOPVlPT1FRPD0gYjw9IGJPT1FRPD0gYzw9IGNPT1FRPDxMZzw8TGdPJjJzUVNPPDxMZ08mMnhRVU88PExnTyYzUFFTTzw9IGJPJjNVUVNPPD0gY09PUVExRzNxMUczcU8+UVFTTzcrKWJPJjNaUVNPPDxJeU8mM2ZRJElVTzw8SXlPT1FPPDxIczw8SHNPT1EoQ1lBTj9fQU4/X09PUU9BTj9XQU4/V08kNm5RKENqT0FOP1dPT1FPQU4+ekFOPnpPJVFRVU9BTj9XT09RTzw8TW88PE1vT09RUUcyNn1HMjZ9TyEldFEsVU9HMjZ9TyMhW1FTT0cyNn1PJjNwUVNPRzI2fU8kTVVRYk9HMjZ9TyYzeFEkSVVPPDxKYU8mNFZRJElVTzFHMlhPJjV7USRJVU8xRzJrTyY4T1EkSVVPMUcybU8mOlJRJElVTzw8S1JPJjpgUSRJVU88PEl0T09RTzFHMXIxRzFyTyEnXlEsVU9BTkFhT09RTzcrKlg3KypYTyY6bVFTTzcrKlhPJjp4UVNPPD0gWE8mO1FRYE83KypaT09RKENXPDxLajw8S2pPJCBtUVNPPDxLak9PUShDVzw8S2k8PEtpTyY7W1FgTzw8S2pPJCBtUVNPPDxLaU9PUU83KypkNysqZE85X1FTTzcrKmRPJjtjUVNPPD0gYU9PUVFHMjdpRzI3aU85T1EoQ1tPRzI3aU8hKWpRVU8xRzR0TyY7a1FTTzcrK3JPJUpPUVNPQU5Bd09PUVFBTkF3QU5Bd08hJXRRLFVPQU5Bd08mO3NRU09BTkF3T09RUUFOQXlBTkF5TzlPUShDW09BTkF5TyNLYFFTT0FOQXlPT1FPJyNIVScjSFVPT1FPNysqYzcrKmNPT1FRRzIydEcyMnRPT1FRQU5CUkFOQlJPJjt7UVNPQU5CUk9PUVFBTkR8QU5EfE9PUVFBTkR9QU5EfU9PUVE8PEx8PDxMfE8hKWpRVU9BTj9lT09RT0cyNHJHMjRyTyQ2blEoQ2pPRzI0ck8jIVtRU09MRCxpT09RUUxELGlMRCxpTyEldFEsVU9MRCxpTyY8UVFTT0xELGlPJjxZUSRJVU83KydzTyY+T1EkSVVPNysndU8mP3RRLFVPRzI2e09PUU88PE1zPDxNc09PUShDV0FOQVVBTkFVTyQgbVFTT0FOQVVPT1EoQ1dBTkFUQU5BVE9PUU88PE5PPDxOT09PUVFMRC1UTEQtVE8mQFVRJElVTzcrKmBPT1FRRzI3Y0cyN2NPJUpPUVNPRzI3Y08hJXRRLFVPRzI3Y09PUVFHMjdlRzI3ZU85T1EoQ1tPRzI3ZU9PUVFHMjdtRzI3bU8mQGBRJElVT0cyNVBPT1FPTEQqXkxEKl5PT1FRISQoIVQhJCghVE8jIVtRU08hJCghVE8hJXRRLFVPISQoIVRPJkBqUShDak9HMjZ7T09RKENXRzI2cEcyNnBPT1FRTEQsfUxELH1PJUpPUVNPTEQsfU9PUVFMRC1QTEQtUE9PUVEhKTlFbyEpOUVvTyMhW1FTTyEpOUVvT09RUSEkKCFpISQoIWlPT1FRIS5LO1ohLks7Wk8mQntRJElVT0cyNntPISlqUVVPJyNEdk8wdVFTTycjRVRPJkRxUWJPJyNKY08hKWpRVU8nI0RuTyZEeFFVTycjRHpPISlqUVVPJyNEfE8mRVBRYk8nI0NmTyZHZ1FiTycjQ2ZPJkd3UVVPLDU7U08hKWpRVU8sNTteTyEpalFVTyw1O15PISlqUVVPLDU7Xk8hKWpRVU8sNTteTyEpalFVTyw1O15PISlqUVVPLDU7Xk8hKWpRVU8sNTteTyEpalFVTyw1O15PISlqUVVPLDU7Xk8hKWpRVU8sNTteTyEpalFVTyw1O15PISlqUVVPJyNJZk8mSXpRU08sNTxjTyZKU1EsVU8sNTteTyZLZ1EsVU8sNTteTyEpalFVTyw1O3JPMHhRU08nI0RTTzB4UVNPJyNEU08hJXRRLFVPJyNGeE8mSlNRLFVPJyNGeE8hJXRRLFVPJyNGek8mSlNRLFVPJyNGek8hJXRRLFVPJyNHWU8mSlNRLFVPJyNHWU8hKWpRVU8sNTpmTyEpalFVTyw1QF9PJkd3UVVPMUcwbk8mS25RJElVTycjQ2ZPISlqUVVPMUcxek8hJXRRLFVPLDU9UE8mSlNRLFVPLDU9UE8hJXRRLFVPLDU9Uk8mSlNRLFVPLDU9Uk8hJXRRLFVPLDU8bU8mSlNRLFVPLDU8bU8mR3dRVU8xRzF7TyEpalFVTzcrJnVPISV0USxVTzFHMlhPJkpTUSxVTzFHMlhPISV0USxVTzFHMlpPJkpTUSxVTzFHMlpPJkd3UVVPNysnZ08mR3dRVU83KyZZTyEldFEsVU9BTkFhTyZKU1EsVU9BTkFhTyZLeFFTTycjRWhPJkt9UVNPJyNFaE8mTFZRU08nI0ZXTyZMW1FTTycjRXJPJkxhUVNPJyNKc08mTGxRU08nI0pxTyZMd1FTTyw1O1NPJkx8USxVTyw1PGBPJk1UUVNPJyNHUk8mTVlRU08nI0dSTyZNX1FTTyw1PGFPJk1nUVNPLDU7U08mTW9RJElVTzFHMVpPJk12UVNPLDU8bU8mTXtRU08sNTxtTyZOUVFTTyw1PG9PJk5WUVNPLDU8b08mTltRU08xRzF7TyZOYVFTTzFHMG5PJk5mUSxVTzw8S3VPJk5tUSxVTzw8S3VPN15RLFVPJyNGdk84dFFTTycjRnVPQG1RU08nI0VnTyEpalFVTyw1O29PITJkUVNPJyNHUk8hMmRRU08nI0dSTyEyZFFTTycjR1RPITJkUVNPJyNHVE8hJ15RLFVPNysoWk8hJ15RLFVPNysoWk8kSHlRYE8xRzJvTyRIeVFgTzFHMm9PISV0USxVTyw1PVRPISV0USxVTyw1PVRcIixcbiAgc3RhdGVEYXRhOiBcIicgdn5PJ21PUyduT1NST1Mnb1JRfk9QWU9RWU9WIVRPXnBPYXhPYndPaWtPa1lPbGtPbWtPc2tPdVlPd1lPfFdPIVFrTyFSa08hWFhPIWNzTyFoWk8ha1lPIWxZTyFtWU8hb3RPIXF1TyF0dk8heF1PI3B9TyRRek8kVWZPJWB7TyViIU9PJWR8TyVlfE8laCFQTyVqIVFPJW0hUk8lbiFSTyVwIVNPJXwhVU8mUyFWTyZVIVdPJlchWE8mWSFZTyZdIVpPJmMhW08maSFdTyZrIV5PJm0hX08mbyFgTyZxIWFPJ3RTTyd2VE8neVVPKFJWTyhhW08obmlPfk9QWU9RWU9hIWdPYiFmT2lrT2tZT2xrT21rT3NrT3VZT3dZT3xXTyFRa08hUmtPIVghY08hY3NPIWhaTyFrWU8hbFlPIW1ZTyFvdE8hcXVPIXQhZU8kUSFoTyRVZk8ndCFiTyd2VE8neVVPKFJWTyhhW08obmlPfk9eIXNPbCFrT3whbE8hWyF1TyFdIXJPIV4hck8heDltTyF8IW1PIX0hbU8jTyF0TyNQIW1PI1EhbU8jVCF2TyNVIXZPJ3UhaU8ndlRPJ3lVTyhVIWpPKGEhcE9+TydvIXdPfk9QWVhYWVheWVhrWVh5WVh6WVh8WVghVllYIWVZWCFmWVghaFlYIWxZWCNYWVgjZGNYI2dZWCNoWVgjaVlYI2pZWCNrWVgjbFlYI21ZWCNuWVgjb1lYI3FZWCNzWVgjdVlYI3ZZWCN7WVgna1lYKFJZWChiWVgoaVlYKGpZWH5PIWEkelh+UChnT1sheU8ndiF7Tyd3IXlPJ3ghe09+T1shfE8neCF7Tyd5IXtPJ3ohfE9+T3EjT08hTyNQTyhTI1BPKFQjUk9+T1BZT1FZT2EhZ09iIWZPaWtPa1lPbGtPbWtPc2tPdVlPd1lPfFdPIVFrTyFSa08hWCFjTyFjc08haFpPIWtZTyFsWU8hbVlPIW90TyFxdU8hdCFlTyRRIWhPJFVmTyd0OXJPJ3ZUTyd5VU8oUlZPKGFbTyhuaU9+TyFVI1ZPIVYjU08hUyhYUCFTKGZQflArc08hVyNfT35QYE9QWU9RWU9hIWdPYiFmT2tZT2xrT21rT3NrT3VZT3dZT3xXTyFRa08hUmtPIVghY08hY3NPIWhaTyFrWU8hbFlPIW1ZTyFvdE8hcXVPIXQhZU8kUSFoTyRVZk8ndlRPJ3lVTyhSVk8oYVtPKG5pT35PaSNpTyFVI2VPIXhdTyNiI2hPI2MjZU8ndDlzTyFnKGNQflAuX08haCNrTyd0I2pPfk8hdCNvTyF4XU8lYCNwT35PI2QjcU9+TyFhI3JPI2QjcU9+T1AkWU9YJGFPayN9T3kjdk96I3dPfCN4TyFWJF5PIWUkUE8hZiN0TyFoI3VPIWwkWU8jZyN7TyNoI3xPI2kjfE8jaiN8TyNrJE9PI2wkUE8jbSRQTyNuJGBPI28kUE8jcSRRTyNzJFNPI3UkVU8jdiRWTyhSVk8oYiRXTyhpI3lPKGojek9+T14oVlgnayhWWCdpKFZYIWcoVlghUyhWWCFYKFZYJWEoVlghYShWWH5QMWdPI1gkYk8jeyRiT1AoV1hYKFdYayhXWHkoV1h6KFdYfChXWCFWKFdYIWUoV1ghaChXWCFsKFdYI2coV1gjaChXWCNpKFdYI2ooV1gjayhXWCNsKFdYI20oV1gjbihXWCNvKFdYI3EoV1gjcyhXWCN1KFdYI3YoV1goUihXWChiKFdYKGkoV1goaihXWCFYKFdYJWEoV1h+T14oV1ghZihXWCdrKFdYJ2koV1ghUyhXWCFnKFdYbyhXWCFhKFdYflAzfU8jWCRiT35PJFckZE8kWSRjTyRhJGlPfk8hWCRqTyRVZk8kZCRrTyRmJG1Pfk9pJVBPayRxT2wkcE9tJHBPcyVRT3UlUk93JVNPfCR4TyFYJHlPIWMlWE8haCR1TyNjJVlPJFElVk8kbSVUTyRvJVVPJHIlV08ndCRvTyd2VE8neVVPJ30lT08oUiRyT2QoT1B+TyFoJVpPfk8hYSVdT35PXiVeTydrJV5Pfk8ndSFpT35QJVFPJ3QlZU9+TyFoJVpPJ3QlZU8ndSFpTyd9JU9Pfk9iJWxPIWglWk8ndCVlT35PI28kUE9+T3klcU8hWCVuTyFoJXBPJWIldE8ndCVlTyd1IWlPJ3ZUTyd5VU9dKHZQfk8hdCNvT35PfCV2TyFYJXdPJ3QlZU9+T3wldk8hWCV3TyVqJXtPJ3QlZU9+Tyd0JXxPfk8jcH1PJWIhT08lZHxPJWV8TyVoIVBPJWohUU8lbSFSTyVuIVJPfk9hJlZPYiZVTyF0JlNPJWAmVE8lciZST35QO2ZPYSZZT2J3TyFYJlhPIXR2TyF4XU8jcH1PJWB7TyVkfE8lZXxPJWghUE8laiFRTyVtIVJPJW4hUk8lcCFTT35PXyZdTyNYJmBPJWImWk8ndSFpT35QPGVPIWgmYU8hcSZlT35PIWgja09+TyFYWE9+T14lXk8naiZtTydrJV5Pfk9eJV5PJ2omcE8nayVeT35PXiVeTydqJnJPJ2slXk9+TydpWVghU1lYb1lYIWdZWCZRWVghWFlYJWFZWCFhWVh+UChnTyFbJ1BPIV0meE8hXiZ4Tyd1IWlPJ3ZUTyd5VU9+T2wmdk98JnVPIVUmeU8oVSZ0TyFXKFlQIVcoaFB+UD9mT2cnU08hWCdRTyd0JWVPfk9iJ1hPIWglWk8ndCVlT35PeSVxTyFoJXBPfk9sIWtPfCFsTyF4OW1PIXwhbU8hfSFtTyNQIW1PI1EhbU8ndSFpTyd2VE8neVVPKFUhak8oYSFwT35PIVsnX08hXSdeTyFeJ15PI08hbU8jVCdgTyNVJ2BPflBBUU9eJV5PIWEjck8haCVaTydrJV5PJ30lT08oYidiT35PIWwnZk8jWCdkT35QQmBPbCFrT3whbE8ndlRPJ3lVTyhVIWpPKGEhcE9+TyFYWE9sKF9YfChfWCFbKF9YIV0oX1ghXihfWCF4KF9YIXwoX1ghfShfWCNPKF9YI1AoX1gjUShfWCNUKF9YI1UoX1gndShfWCd2KF9YJ3koX1goVShfWChhKF9Yfk8hXSdeTyFeJ15PJ3UhaU9+UENPTydwJ2pPJ3Enak8ncidsT35PWyF5Tyd2J25PJ3cheU8neCduT35PWyF8Tyd4J25PJ3knbk8neiF8T35PcSNPTyFPI1BPKFMjUE8oVCdyT35PIVUndE8hUyZ8WCFTJ1NYIVYmfFghVidTWH5QK3NPIVYndk8hUyhYWH5PUCRZT1gkYU9rI31PeSN2T3ojd098I3hPIVYndk8hZSRQTyFmI3RPIWgjdU8hbCRZTyNnI3tPI2gjfE8jaSN8TyNqI3xPI2skT08jbCRQTyNtJFBPI24kYE8jbyRQTyNxJFFPI3MkU08jdSRVTyN2JFZPKFJWTyhiJFdPKGkjeU8oaiN6T35PIVMoWFh+UEZyTyFTJ3tPfk8hUyhlWCFWKGVYIWEoZVghZyhlWChiKGVYfk8jWChlWCNkI11YIVcoZVh+UEh4TyNYJ3xPIVMoZ1ghVihnWH5PIVYnfU8hUyhmWH5PIVMoUU9+TyNYJGJPflBIeE8hVyhST35QYE95I3ZPeiN3T3wjeE8hZiN0TyFoI3VPKFJWT1AhamFYIWphayFqYSFWIWphIWUhamEhbCFqYSNnIWphI2ghamEjaSFqYSNqIWphI2shamEjbCFqYSNtIWphI24hamEjbyFqYSNxIWphI3MhamEjdSFqYSN2IWphKGIhamEoaSFqYShqIWphfk9eIWphJ2shamEnaSFqYSFTIWphIWchamFvIWphIVghamElYSFqYSFhIWphflBKYE8hZyhTT35PIWEjck8jWChUTyhiJ2JPIVYoZFheKGRYJ2soZFh+TyFnKGRYflBNT098JXZPIVgld08heF1PI2IoWU8jYyhYTyd0JWVPfk8hVihaTyFnKGNYfk8hZyhdT35PfCV2TyFYJXdPI2MoWE8ndCVlT35PUChXWFgoV1hrKFdYeShXWHooV1h8KFdYIVYoV1ghZShXWCFmKFdYIWgoV1ghbChXWCNnKFdYI2goV1gjaShXWCNqKFdYI2soV1gjbChXWCNtKFdYI24oV1gjbyhXWCNxKFdYI3MoV1gjdShXWCN2KFdYKFIoV1goYihXWChpKFdYKGooV1h+TyFhI3JPIWcoV1h+UE5sT3koXk96KF9PIWYjdE8haCN1TyF4IXdhfCF3YX5PIXQhd2ElYCF3YSFYIXdhI2Ihd2EjYyF3YSd0IXdhflAhIXBPIXQoY09+T1BZT1FZT2EhZ09iIWZPaWtPa1lPbGtPbWtPc2tPdVlPd1lPfFdPIVFrTyFSa08hWFhPIWNzTyFoWk8ha1lPIWxZTyFtWU8hb3RPIXF1TyF0IWVPJFEhaE8kVWZPJ3QhYk8ndlRPJ3lVTyhSVk8oYVtPKG5pT35PaSVQT2skcU9sJHBPbSRwT3MlUU91JVJPdzpWT3wkeE8hWCR5TyFjO2FPIWgkdU8jYzpdTyRRJVZPJG06WE8kbzpaTyRyJVdPJ3QoZ08ndlRPJ3lVTyd9JU9PKFIkck9+TyNkKGlPfk9pJVBPayRxT2wkcE9tJHBPcyVRT3UlUk93JVNPfCR4TyFYJHlPIWMlWE8haCR1TyNjJVlPJFElVk8kbSVUTyRvJVVPJHIlV08ndChnTyd2VE8neVVPJ30lT08oUiRyT35PZChbUH5QISdeTyFVKG1PIWcoXVB+UCVRTyhVKG9PKGFbT35PfChxTyFoI3VPKFUob08oYVtPfk9QOWxPUTlsT2E7XU9iIWZPaWtPazlsT2xrT21rT3NrT3U5bE93OWxPfFdPIVFrTyFSa08hWCFjTyFjOW9PIWhaTyFrOWxPIWw5bE8hbTlsTyFvOXBPIXE5cU8hdCFlTyRRIWhPJFVmTyd0KVBPJ3ZUTyd5VU8oUlZPKGFbTyhuO1pPfk96KVNPIWgjdU9+TyFWJF5PXiRrYSdrJGthJ2kka2EhZyRrYSFTJGthIVgka2ElYSRrYSFhJGthfk8jcClXT35QISV0T3kpWk8hYSlZTyFYJFhYJFQkWFgkVyRYWCRZJFhYJGEkWFh+TyFhKVlPIVgoa1gkVChrWCRXKGtYJFkoa1gkYShrWH5PeSlaT35QIS1TT3kpWk8hWChrWCRUKGtYJFcoa1gkWShrWCRhKGtYfk8hWCldTyRUKWFPJFcpW08kWSlbTyRhKWJPfk8hVSllT35QISlqTyRXJGRPJFkkY08kYSlpT35PZyRzWHkkc1h8JHNYIWYkc1goaSRzWChqJHNYfk9kZlhkJHNYZ2ZYIVZmWCNYZlh+UCEueE9sKWtPfk9xKWxPKFMpbU8oVClvT35PZyl4T3kpcU98KXJPKGkpdE8oail2T35PZClwT35QITBST2QpeU9+T2klUE9rJHFPbCRwT20kcE9zJVFPdSVST3c6Vk98JHhPIVgkeU8hYzthTyFoJHVPI2M6XU8kUSVWTyRtOlhPJG86Wk8kciVXTyd2VE8neVVPJ30lT08oUiRyT35PIVUpfU8ndCl6TyFnKG9QflAhMHBPI2QqUE9+TyFoKlFPfk8hVSpWTyd0KlNPIVMocFB+UCEwcE9rKmNPfCpaTyFbKmFPIV0qWU8hXipZTyFoKlFPI1QqYk8lVypdTyd1IWlPKFUhak9+TyFXKmBPflAhMnZPIWYjdE9nKFFYeShRWHwoUVgoaShRWChqKFFYIVYoUVgjWChRWH5PZChRWCN5KFFYflAhM29PZypmTyNYKmVPZChQWCFWKFBYfk8hVipnT2QoT1h+Tyd0JXxPZChPUH5PIWgqbk9+Tyd0KGdPfk9pKnJPfCV2TyFVI2VPIVgld08heF1PI2IjaE8jYyNlTyd0JWVPIWcoY1B+TyFhI3JPI2Qqc09+T1AkWU9YJGFPayN9T3kjdk96I3dPfCN4TyFlJFBPIWYjdE8haCN1TyFsJFlPI2cje08jaCN8TyNpI3xPI2ojfE8jayRPTyNsJFBPI20kUE8jbiRgTyNvJFBPI3EkUU8jcyRTTyN1JFVPI3YkVk8oUlZPKGIkV08oaSN5TyhqI3pPfk9eIWJhIVYhYmEnayFiYSdpIWJhIVMhYmEhZyFiYW8hYmEhWCFiYSVhIWJhIWEhYmF+UCE2VU95I3ZPeiN3T3wjeE8hZiN0TyFoI3VPKFJWT1AhbmFYIW5hayFuYSFWIW5hIWUhbmEhbCFuYSNnIW5hI2ghbmEjaSFuYSNqIW5hI2shbmEjbCFuYSNtIW5hI24hbmEjbyFuYSNxIW5hI3MhbmEjdSFuYSN2IW5hKGIhbmEoaSFuYShqIW5hfk9eIW5hJ2shbmEnaSFuYSFTIW5hIWchbmFvIW5hIVghbmElYSFuYSFhIW5hflAhOG9PeSN2T3ojd098I3hPIWYjdE8haCN1TyhSVk9QIXBhWCFwYWshcGEhViFwYSFlIXBhIWwhcGEjZyFwYSNoIXBhI2khcGEjaiFwYSNrIXBhI2whcGEjbSFwYSNuIXBhI28hcGEjcSFwYSNzIXBhI3UhcGEjdiFwYShiIXBhKGkhcGEoaiFwYX5PXiFwYSdrIXBhJ2khcGEhUyFwYSFnIXBhbyFwYSFYIXBhJWEhcGEhYSFwYX5QITtZT2cqe08hWCdRTyVhKnpPJ30lT09+TyFhKn1PXid8WCFYJ3xYJ2snfFghVid8WH5PXiVeTyFYWE8nayVeT35PIWglWk8nfSVPT35PIWglWk8ndCVlTyd9JU9Pfk8hYSNyTyNkKGlPfk8lYitaTyd0K1ZPJ3ZUTyd5VU8hVyh3UH5PIVYrW09dKHZYfk8oVShvT35PWCtgT35PXSthT35PIVglbk8ndCVlTyd1IWlPXSh2UH5PfCV2TyFVK2VPIVYnfU8hWCV3Tyd0JWVPIVMoZlB+T2wmfE98K2dPIVUrZk8ndlRPJ3lVTyhVKG9Pfk8hVyhoUH5QIUB4TyFWK2hPXihzWCdrKHNYfk8jWCtsTyd9JU9Pfk9nK29PIVgkeU8nfSVPT35PIVgrcU9+T3krc08hWFhPfk8hdCt4T35PYit9T35PJ3Qjak8hVyh1UH5PYiVsT35PJWIhT08ndCV8T35QPGVPWCxUT10sU09+T1BZT1FZT2F4T2J3T2lrT2tZT2xrT21rT3NrT3VZT3dZT3xXTyFRa08hUmtPIWNzTyFoWk8ha1lPIWxZTyFtWU8hb3RPIXF1TyF0dk8heF1PJFVmTyVge08ndlRPJ3lVTyhSVk8oYVtPKG5pT35PIVghY08kUSFoTyd0IWJPflAhQ11PXSxTT14lXk8nayVeT35PXixYTyNwLFpPJWQsWk8lZSxaT35QJVFPIWgmYU9+TyZTLGBPfk8hWCxiT35PJmUsZE8mZyxlT1AmYmFRJmJhViZiYV4mYmFhJmJhYiZiYWkmYmFrJmJhbCZiYW0mYmFzJmJhdSZiYXcmYmF8JmJhIVEmYmEhUiZiYSFYJmJhIWMmYmEhaCZiYSFrJmJhIWwmYmEhbSZiYSFvJmJhIXEmYmEhdCZiYSF4JmJhI3AmYmEkUSZiYSRVJmJhJWAmYmElYiZiYSVkJmJhJWUmYmElaCZiYSVqJmJhJW0mYmElbiZiYSVwJmJhJXwmYmEmUyZiYSZVJmJhJlcmYmEmWSZiYSZdJmJhJmMmYmEmaSZiYSZrJmJhJm0mYmEmbyZiYSZxJmJhJ2kmYmEndCZiYSd2JmJhJ3kmYmEoUiZiYShhJmJhKG4mYmEhVyZiYSZaJmJhXyZiYSZgJmJhfk8ndCxqT35PIVZ7WCFWIV9YIVd7WCFXIV9YIWF7WCFhIV9YIWghX1gjWHtYJ30hX1h+TyFhLG9PI1gsbk8hViNhWCFWKFpYIVcjYVghVyhaWCFhKFpYIWgoWlgnfShaWH5PIWEscU8haCVaTyd9JU9PIVYhWlghVyFaWH5PbCFrT3whbE8ndlRPJ3lVTyhVIWpPfk9QOWxPUTlsT2E7XU9iIWZPaWtPazlsT2xrT21rT3NrT3U5bE93OWxPfFdPIVFrTyFSa08hWCFjTyFjOW9PIWhaTyFrOWxPIWw5bE8hbTlsTyFvOXBPIXE5cU8hdCFlTyRRIWhPJFVmTyd2VE8neVVPKFJWTyhhW08objtaT35PJ3Q6Yk9+UCFMck8hVix1TyFXKFlYfk8hVyx3T35PIWEsb08jWCxuTyFWI2FYIVcjYVh+TyFWLHhPIVcoaFh+TyFXLHpPfk8hXSx7TyFeLHtPJ3UhaU9+UCFMYU8hVy1PT35QJ1RPZy1STyFYJ1FPfk8hUy1XT35PbCF3YSFbIXdhIV0hd2EhXiF3YSF8IXdhIX0hd2EjTyF3YSNQIXdhI1Ehd2EjVCF3YSNVIXdhJ3Uhd2EndiF3YSd5IXdhKFUhd2EoYSF3YX5QISFwTyFsLV1PI1gtWk9+UEJgTyFdLV9PIV4tX08ndSFpT35QQ09PXiVeTyNYLVpPJ2slXk9+T14lXk8hYSNyTyNYLVpPJ2slXk9+T14lXk8hYSNyTyFsLV1PI1gtWk8nayVeTyhiJ2JPfk8ncCdqTydxJ2pPJ3ItZE9+T28tZU9+TyFTJnxhIVYmfGF+UCE2VU8hVS1pTyFTJnxYIVYmfFh+UCVRTyFWJ3ZPIVMoWGF+TyFTKFhhflBGck8hVid9TyFTKGZhfk98JXZPIVUtbU8hWCV3Tyd0JWVPIVMnU1ghVidTWH5PI1gtb08hVihkYSFnKGRhXihkYSdrKGRhfk8hYSNyT35QIyZ4TyFWKFpPIWcoY2F+T3wldk8hWCV3TyNjLXNPJ3QlZU9+T2kteE98JXZPIVUtdU8hWCV3TyF4XU8jYi13TyNjLXVPJ3QlZU8hVidWWCFnJ1ZYfk96LXxPIWgjdU9+T2cuUE8hWCdRTyVhLk9PJ30lT09+T14jW2khViNbaSdrI1tpJ2kjW2khUyNbaSFnI1tpbyNbaSFYI1tpJWEjW2khYSNbaX5QITZVT2c7Z095KXFPfClyTyhpKXRPKGopdk9+TyNkI1dhXiNXYSNYI1dhJ2sjV2EhViNXYSFnI1dhIVgjV2EhUyNXYX5QIyl0TyNkKFFYUChRWFgoUVheKFFYayhRWHooUVghZShRWCFoKFFYIWwoUVgjZyhRWCNoKFFYI2koUVgjaihRWCNrKFFYI2woUVgjbShRWCNuKFFYI28oUVgjcShRWCNzKFFYI3UoUVgjdihRWCdrKFFYKFIoUVgoYihRWCFnKFFYIVMoUVgnaShRWG8oUVghWChRWCVhKFFYIWEoUVh+UCEzb08hVi5ZT2QoW1h+UCEwUk9kLltPfk8hVi5dTyFnKF1YflAhNlVPIWcuYE9+TyFTLmJPfk9QJFlPeSN2T3ojd098I3hPIWYjdE8haCN1TyFsJFlPKFJWT1gjZmleI2ZpayNmaSFWI2ZpIWUjZmkjaCNmaSNpI2ZpI2ojZmkjayNmaSNsI2ZpI20jZmkjbiNmaSNvI2ZpI3EjZmkjcyNmaSN1I2ZpI3YjZmknayNmaShiI2ZpKGkjZmkoaiNmaSdpI2ZpIVMjZmkhZyNmaW8jZmkhWCNmaSVhI2ZpIWEjZml+TyNnI2ZpflAjLXBPI2cje09+UCMtcE9QJFlPeSN2T3ojd098I3hPIWYjdE8haCN1TyFsJFlPI2cje08jaCN8TyNpI3xPI2ojfE8oUlZPWCNmaV4jZmkhViNmaSFlI2ZpI2sjZmkjbCNmaSNtI2ZpI24jZmkjbyNmaSNxI2ZpI3MjZmkjdSNmaSN2I2ZpJ2sjZmkoYiNmaShpI2ZpKGojZmknaSNmaSFTI2ZpIWcjZmlvI2ZpIVgjZmklYSNmaSFhI2Zpfk9rI2ZpflAjMGJPayN9T35QIzBiT1AkWU9rI31PeSN2T3ojd098I3hPIWYjdE8haCN1TyFsJFlPI2cje08jaCN8TyNpI3xPI2ojfE8jayRPTyhSVk9eI2ZpIVYjZmkjcSNmaSNzI2ZpI3UjZmkjdiNmaSdrI2ZpKGIjZmkoaSNmaShqI2ZpJ2kjZmkhUyNmaSFnI2ZpbyNmaSFYI2ZpJWEjZmkhYSNmaX5PWCNmaSFlI2ZpI2wjZmkjbSNmaSNuI2ZpI28jZml+UCMzU09YJGFPIWUkUE8jbCRQTyNtJFBPI24kYE8jbyRQT35QIzNTT1AkWU9YJGFPayN9T3kjdk96I3dPfCN4TyFlJFBPIWYjdE8haCN1TyFsJFlPI2cje08jaCN8TyNpI3xPI2ojfE8jayRPTyNsJFBPI20kUE8jbiRgTyNvJFBPI3EkUU8oUlZPXiNmaSFWI2ZpI3MjZmkjdSNmaSN2I2ZpJ2sjZmkoYiNmaShqI2ZpJ2kjZmkhUyNmaSFnI2ZpbyNmaSFYI2ZpJWEjZmkhYSNmaX5PKGkjZml+UCM2VE8oaSN5T35QIzZUT1AkWU9YJGFPayN9T3kjdk96I3dPfCN4TyFlJFBPIWYjdE8haCN1TyFsJFlPI2cje08jaCN8TyNpI3xPI2ojfE8jayRPTyNsJFBPI20kUE8jbiRgTyNvJFBPI3EkUU8jcyRTTyhSVk8oaSN5T14jZmkhViNmaSN1I2ZpI3YjZmknayNmaShiI2ZpJ2kjZmkhUyNmaSFnI2ZpbyNmaSFYI2ZpJWEjZmkhYSNmaX5PKGojZml+UCM4dU8oaiN6T35QIzh1T1AkWU9YJGFPayN9T3kjdk96I3dPfCN4TyFlJFBPIWYjdE8haCN1TyFsJFlPI2cje08jaCN8TyNpI3xPI2ojfE8jayRPTyNsJFBPI20kUE8jbiRgTyNvJFBPI3EkUU8jcyRTTyN1JFVPKFJWTyhpI3lPKGojek9+T14jZmkhViNmaSN2I2ZpJ2sjZmkoYiNmaSdpI2ZpIVMjZmkhZyNmaW8jZmkhWCNmaSVhI2ZpIWEjZml+UCM7Z09QWVhYWVhrWVh5WVh6WVh8WVghZVlYIWZZWCFoWVghbFlYI1hZWCNkY1gjZ1lYI2hZWCNpWVgjallYI2tZWCNsWVgjbVlYI25ZWCNvWVgjcVlYI3NZWCN1WVgjdllYI3tZWChSWVgoYllYKGlZWChqWVghVllYIVdZWH5PI3lZWH5QIz5RT1AkWU9YOlRPazl3T3kjdk96I3dPfCN4TyFlOXlPIWYjdE8haCN1TyFsJFlPI2c5dU8jaDl2TyNpOXZPI2o5dk8jazl4TyNsOXlPI205eU8jbjpTTyNvOXlPI3E5ek8jczl8TyN1Ok9PI3Y6UE8oUlZPKGIkV08oaSN5TyhqI3pPfk8jeS5kT35QI0BfTyNYOlVPI3s6VU8jeShXWCFXKFdYflBObE9eJ1lhIVYnWWEnaydZYSdpJ1lhIWcnWWEhUydZYW8nWWEhWCdZYSVhJ1lhIWEnWWF+UCE2VU9QI2ZpWCNmaV4jZmlrI2ZpeiNmaSFWI2ZpIWUjZmkhZiNmaSFoI2ZpIWwjZmkjZyNmaSNoI2ZpI2kjZmkjaiNmaSNrI2ZpI2wjZmkjbSNmaSNuI2ZpI28jZmkjcSNmaSNzI2ZpI3UjZmkjdiNmaSdrI2ZpKFIjZmkoYiNmaSdpI2ZpIVMjZmkhZyNmaW8jZmkhWCNmaSVhI2ZpIWEjZml+UCMpdE9eI3ppIVYjemknayN6aSdpI3ppIVMjemkhZyN6aW8jemkhWCN6aSVhI3ppIWEjeml+UCE2VU8kVy5pTyRZLmlPfk8kVy5qTyRZLmpPfk8hYSlZTyNYLmtPIVgkXlgkVCReWCRXJF5YJFkkXlgkYSReWH5PIVUubE9+TyFYKV1PJFQubk8kVylbTyRZKVtPJGEub09+TyFWOlFPIVcoVlh+UCNAX08hVy5wT35PIWEpWU8kYShrWH5PJGEuck9+T3EpbE8oUyltTyhULnVPfk9sLnhPIVMueU8ndlRPJ3lVT35PIVZjWCFhY1ghZ2NYIWckc1goYmNYflAhLnhPIWcvUE9+UCMpdE8hVi9RTyFhI3JPKGInYk8hZyhvWH5PIWcvVk9+TyFVKX1PJ3QlZU8hZyhvUH5PI2QvWE9+TyFTJHNYIVYkc1ghYSR6WH5QIS54TyFWL1lPIVMocFh+UCMpdE8hYS9bT35PIVMvXk9+T2svYk8hYSNyTyFoJVpPJ30lT08oYidiT35PJ3QvZE9+TyFhKn1Pfk9eJV5PIVYvaE8nayVeT35PIVcvak9+UCEydk8hXS9rTyFeL2tPJ3UhaU8oVSFqT35PfC9tTyhVIWpPfk8jVC9uT35PJ3QlfE9kJ19YIVYnX1h+TyFWKmdPZChPYX5PZC9zT35PeS90T3ovdE98L3VPZ3ZhKGl2YShqdmEhVnZhI1h2YX5PZHZhI3l2YX5QI0x8T3kpcU98KXJPZyRsYShpJGxhKGokbGEhViRsYSNYJGxhfk9kJGxhI3kkbGF+UCNNck95KXFPfClyT2ckbmEoaSRuYShqJG5hIVYkbmEjWCRuYX5PZCRuYSN5JG5hflAjTmVPI2Qvd09+T2QkfGEhViR8YSNYJHxhI3kkfGF+UCEwUk8hYSNyT35PI2Qvek9+T3kjdk96I3dPfCN4TyFmI3RPIWgjdU8oUlZPUCFuaVghbmlrIW5pIVYhbmkhZSFuaSFsIW5pI2chbmkjaCFuaSNpIW5pI2ohbmkjayFuaSNsIW5pI20hbmkjbiFuaSNvIW5pI3EhbmkjcyFuaSN1IW5pI3YhbmkoYiFuaShpIW5pKGohbml+T14hbmknayFuaSdpIW5pIVMhbmkhZyFuaW8hbmkhWCFuaSVhIW5pIWEhbml+UCQgd09nLlBPIVgnUU8lYS5PT35PaTBSTyd0MFFPflAhMHNPIWEqfU9eJ3xhIVgnfGEnayd8YSFWJ3xhfk8jZDBYT35PWFlYIVZjWCFXY1h+TyFWMFlPIVcod1h+TyFXMFtPfk9YMF1Pfk8ndCtWTyd2VE8neVVPfk8hWCVuTyd0JWVPXSdnWCFWJ2dYfk8hVitbT10odmF+TyFnMGJPflAhNlVPWDBlT35PXTBmT35PIVYraE9eKHNhJ2soc2F+TyNYMGxPfk9nMG9PIVgkeU9+TyhVKG9PIVcodFB+T2cweE8hWDB1TyVhMHdPJ30lT09+T1gxU08hVjFRTyFXKHVYfk8hVzFUT35PXTFWT14lXk8nayVeT35PJ3Qjak8ndlRPJ3lVT35PI1gkYk8jeyRiT1AoV1hYKFdYayhXWHkoV1h6KFdYfChXWCFWKFdYIWUoV1ghaChXWCFsKFdYI2coV1gjaChXWCNpKFdYI2ooV1gjayhXWCNsKFdYI20oV1gjbihXWCNxKFdYI3MoV1gjdShXWCN2KFdYKFIoV1goYihXWChpKFdYKGooV1h+TyNvMVlPJlExWk9eKFdYIWYoV1h+UCQoeE8jWCRiTyNvMVlPJlExWk9+T14xW09+UCVRT14xXk9+TyZaMWJPUCZYaVEmWGlWJlhpXiZYaWEmWGliJlhpaSZYaWsmWGlsJlhpbSZYaXMmWGl1JlhpdyZYaXwmWGkhUSZYaSFSJlhpIVgmWGkhYyZYaSFoJlhpIWsmWGkhbCZYaSFtJlhpIW8mWGkhcSZYaSF0JlhpIXgmWGkjcCZYaSRRJlhpJFUmWGklYCZYaSViJlhpJWQmWGklZSZYaSVoJlhpJWomWGklbSZYaSVuJlhpJXAmWGklfCZYaSZTJlhpJlUmWGkmVyZYaSZZJlhpJl0mWGkmYyZYaSZpJlhpJmsmWGkmbSZYaSZvJlhpJnEmWGknaSZYaSd0JlhpJ3YmWGkneSZYaShSJlhpKGEmWGkobiZYaSFXJlhpXyZYaSZgJlhpfk9fMWhPIVcxZk8mYDFnT35QYE8hWFhPIWgxak9+TyZnLGVPUCZiaVEmYmlWJmJpXiZiaWEmYmliJmJpaSZiaWsmYmlsJmJpbSZiaXMmYml1JmJpdyZiaXwmYmkhUSZiaSFSJmJpIVgmYmkhYyZiaSFoJmJpIWsmYmkhbCZiaSFtJmJpIW8mYmkhcSZiaSF0JmJpIXgmYmkjcCZiaSRRJmJpJFUmYmklYCZiaSViJmJpJWQmYmklZSZiaSVoJmJpJWomYmklbSZiaSVuJmJpJXAmYmklfCZiaSZTJmJpJlUmYmkmVyZiaSZZJmJpJl0mYmkmYyZiaSZpJmJpJmsmYmkmbSZiaSZvJmJpJnEmYmknaSZiaSd0JmJpJ3YmYmkneSZiaShSJmJpKGEmYmkobiZiaSFXJmJpJlomYmlfJmJpJmAmYml+TyFTMXBPfk8hViFaYSFXIVphflAjQF9PbCFrT3whbE8hVTF2TyhVIWpPIVYmfVghVyZ9WH5QP2ZPIVYsdU8hVyhZYX5PIVYnVFghVydUWH5QIUB4TyFWLHhPIVcoaGF+TyFXMX1PflAnVE9eJV5PI1gyV08nayVeT35PXiVeTyFhI3JPI1gyV08nayVeT35PXiVeTyFhI3JPIWwyW08jWDJXTydrJV5PKGInYk9+T14lXk8nayVeT35QITZVTyFWJF5PbyRrYX5PIVMmfGkhViZ8aX5QITZVTyFWJ3ZPIVMoWGl+TyFWJ31PIVMoZml+TyFTKGdpIVYoZ2l+UCE2VU8hVihkaSFnKGRpXihkaSdrKGRpflAhNlVPI1gyXk8hVihkaSFnKGRpXihkaSdrKGRpfk8hVihaTyFnKGNpfk98JXZPIVgld08heF1PI2IyY08jYzJiTyd0JWVPfk98JXZPIVgld08jYzJiTyd0JWVPfk9nMmpPIVgnUU8lYTJpT35PZzJqTyFYJ1FPJWEyaU8nfSVPT35PI2R2YVB2YVh2YV52YWt2YSFldmEhZnZhIWh2YSFsdmEjZ3ZhI2h2YSNpdmEjanZhI2t2YSNsdmEjbXZhI252YSNvdmEjcXZhI3N2YSN1dmEjdnZhJ2t2YShSdmEoYnZhIWd2YSFTdmEnaXZhb3ZhIVh2YSVhdmEhYXZhflAjTHxPI2QkbGFQJGxhWCRsYV4kbGFrJGxheiRsYSFlJGxhIWYkbGEhaCRsYSFsJGxhI2ckbGEjaCRsYSNpJGxhI2okbGEjayRsYSNsJGxhI20kbGEjbiRsYSNvJGxhI3EkbGEjcyRsYSN1JGxhI3YkbGEnayRsYShSJGxhKGIkbGEhZyRsYSFTJGxhJ2kkbGFvJGxhIVgkbGElYSRsYSFhJGxhflAjTXJPI2QkbmFQJG5hWCRuYV4kbmFrJG5heiRuYSFlJG5hIWYkbmEhaCRuYSFsJG5hI2ckbmEjaCRuYSNpJG5hI2okbmEjayRuYSNsJG5hI20kbmEjbiRuYSNvJG5hI3EkbmEjcyRuYSN1JG5hI3YkbmEnayRuYShSJG5hKGIkbmEhZyRuYSFTJG5hJ2kkbmFvJG5hIVgkbmElYSRuYSFhJG5hflAjTmVPI2QkfGFQJHxhWCR8YV4kfGFrJHxheiR8YSFWJHxhIWUkfGEhZiR8YSFoJHxhIWwkfGEjZyR8YSNoJHxhI2kkfGEjaiR8YSNrJHxhI2wkfGEjbSR8YSNuJHxhI28kfGEjcSR8YSNzJHxhI3UkfGEjdiR8YSdrJHxhKFIkfGEoYiR8YSFnJHxhIVMkfGEnaSR8YSNYJHxhbyR8YSFYJHxhJWEkfGEhYSR8YX5QIyl0T14jW3EhViNbcSdrI1txJ2kjW3EhUyNbcSFnI1txbyNbcSFYI1txJWEjW3EhYSNbcX5QITZVT2QnT1ghVidPWH5QISdeTyFWLllPZChbYX5PIVUyck8hVidQWCFnJ1BYflAlUU8hVi5dTyFnKF1hfk8hVi5dTyFnKF1hflAhNlVPIVMydU9+TyN5IWphIVchamF+UEpgTyN5IWJhIVYhYmEhVyFiYX5QI0BfTyN5IW5hIVchbmF+UCE4b08jeSFwYSFXIXBhflAhO1lPIVgzWE8kVWZPJF8zWU9+TyFXM15Pfk9vM19PflAjKXRPXiRocSFWJGhxJ2skaHEnaSRocSFTJGhxIWckaHFvJGhxIVgkaHElYSRocSFhJGhxflAhNlVPIVMzYE9+T2wueE8ndlRPJ3lVT35PeSlxT3wpck8oail2T2clWGkoaSVYaSFWJVhpI1glWGl+T2QlWGkjeSVYaX5QJEdlT3kpcU98KXJPZyVaaShpJVppKGolWmkhViVaaSNYJVppfk9kJVppI3klWml+UCRIV08oYiRXT35QIyl0TyFVM2NPJ3QlZU8hVidaWCFnJ1pYfk8hVi9RTyFnKG9hfk8hVi9RTyFhI3JPIWcob2F+TyFWL1FPIWEjck8oYidiTyFnKG9hfk9kJHVpIVYkdWkjWCR1aSN5JHVpflAhMFJPIVUza08ndCpTTyFTJ11YIVYnXVh+UCEwcE8hVi9ZTyFTKHBhfk8hVi9ZTyFTKHBhflAjKXRPIWEjck8jbzNzT35PazN2TyFhI3JPKGInYk9+T2QoUGkhVihQaX5QITBSTyNYM3lPZChQaSFWKFBpflAhMFJPIWczfE9+T14kaXEhViRpcSdrJGlxJ2kkaXEhUyRpcSFnJGlxbyRpcSFYJGlxJWEkaXEhYSRpcX5QITZVTyFWNFFPIVgocVh+UCMpdE8hZiN0T35QM31PXiRzWCFYJHNYJVVZWCdrJHNYIVYkc1h+UCEueE8lVTRTT15oWGdoWHloWHxoWCFYaFgna2hYKGloWChqaFghVmhYfk8lVTRTT35PJWI0Wk8ndCtWTyd2VE8neVVPIVYnZlghVydmWH5PIVYwWU8hVyh3YX5PWDRfT35PXTRgT35PIVM0ZE9+T14lXk8nayVeT35QIyl0TyFYJHlPflAjKXRPIVY0aU8jWDRrTyFXKHRYfk8hVzRsT35PbCFrT3w0bU8hWyF1TyFdIXJPIV4hck8heDltTyF8IW1PIX0hbU8jTyFtTyNQIW1PI1EhbU8jVDRyTyNVIXZPJ3UhaU8ndlRPJ3lVTyhVIWpPKGEhcE9+TyFXNHFPflAlIVZPZzR3TyFYMHVPJWE0dk9+T2c0d08hWDB1TyVhNHZPJ30lT09+Tyd0I2pPIVYnZVghVydlWH5PIVYxUU8hVyh1YX5PJ3ZUTyd5VU8oVTVRT35PXTVVT35PIWc1WE9+UCVRT141Wk9+T141Wk9+UCVRTyNvNV1PJlE1Xk9+UE1PT18xaE8hVzViTyZgMWdPflBgTyFhNWRPfk8hYTVmTyFWKFppIVcoWmkhYShaaSFoKFppJ30oWml+TyFWI2FpIVcjYWl+UCNAX08jWDVnTyFWI2FpIVcjYWl+TyFWIVppIVchWml+UCNAX09eJV5PI1g1cE8nayVeT35PXiVeTyFhI3JPI1g1cE8nayVeT35PIVYoZHEhZyhkcV4oZHEnayhkcX5QITZVTyFWKFpPIWcoY3F+T3wldk8hWCV3TyNjNXdPJ3QlZU9+TyFYJ1FPJWE1ek9+T2c1fU8hWCdRTyVhNXpPfk8jZCVYaVAlWGlYJVhpXiVYaWslWGl6JVhpIWUlWGkhZiVYaSFoJVhpIWwlWGkjZyVYaSNoJVhpI2klWGkjaiVYaSNrJVhpI2wlWGkjbSVYaSNuJVhpI28lWGkjcSVYaSNzJVhpI3UlWGkjdiVYaSdrJVhpKFIlWGkoYiVYaSFnJVhpIVMlWGknaSVYaW8lWGkhWCVYaSVhJVhpIWElWGl+UCRHZU8jZCVaaVAlWmlYJVppXiVaaWslWml6JVppIWUlWmkhZiVaaSFoJVppIWwlWmkjZyVaaSNoJVppI2klWmkjaiVaaSNrJVppI2wlWmkjbSVaaSNuJVppI28lWmkjcSVaaSNzJVppI3UlWmkjdiVaaSdrJVppKFIlWmkoYiVaaSFnJVppIVMlWmknaSVaaW8lWmkhWCVaaSVhJVppIWElWml+UCRIV08jZCR1aVAkdWlYJHVpXiR1aWskdWl6JHVpIVYkdWkhZSR1aSFmJHVpIWgkdWkhbCR1aSNnJHVpI2gkdWkjaSR1aSNqJHVpI2skdWkjbCR1aSNtJHVpI24kdWkjbyR1aSNxJHVpI3MkdWkjdSR1aSN2JHVpJ2skdWkoUiR1aShiJHVpIWckdWkhUyR1aSdpJHVpI1gkdWlvJHVpIVgkdWklYSR1aSFhJHVpflAjKXRPZCdPYSFWJ09hflAhMFJPIVYnUGEhZydQYX5QITZVTyFWLl1PIWcoXWl+TyN5I1tpIVYjW2khVyNbaX5QI0BfT1AkWU95I3ZPeiN3T3wjeE8hZiN0TyFoI3VPIWwkWU8oUlZPWCNmaWsjZmkhZSNmaSNoI2ZpI2kjZmkjaiNmaSNrI2ZpI2wjZmkjbSNmaSNuI2ZpI28jZmkjcSNmaSNzI2ZpI3UjZmkjdiNmaSN5I2ZpKGIjZmkoaSNmaShqI2ZpIVYjZmkhVyNmaX5PI2cjZml+UCUwZk8jZzl1T35QJTBmT1AkWU95I3ZPeiN3T3wjeE8hZiN0TyFoI3VPIWwkWU8jZzl1TyNoOXZPI2k5dk8jajl2TyhSVk9YI2ZpIWUjZmkjayNmaSNsI2ZpI20jZmkjbiNmaSNvI2ZpI3EjZmkjcyNmaSN1I2ZpI3YjZmkjeSNmaShiI2ZpKGkjZmkoaiNmaSFWI2ZpIVcjZml+T2sjZml+UCUycU9rOXdPflAlMnFPUCRZT2s5d095I3ZPeiN3T3wjeE8hZiN0TyFoI3VPIWwkWU8jZzl1TyNoOXZPI2k5dk8jajl2TyNrOXhPKFJWTyNxI2ZpI3MjZmkjdSNmaSN2I2ZpI3kjZmkoYiNmaShpI2ZpKGojZmkhViNmaSFXI2Zpfk9YI2ZpIWUjZmkjbCNmaSNtI2ZpI24jZmkjbyNmaX5QJTR8T1g6VE8hZTl5TyNsOXlPI205eU8jbjpTTyNvOXlPflAlNHxPUCRZT1g6VE9rOXdPeSN2T3ojd098I3hPIWU5eU8hZiN0TyFoI3VPIWwkWU8jZzl1TyNoOXZPI2k5dk8jajl2TyNrOXhPI2w5eU8jbTl5TyNuOlNPI285eU8jcTl6TyhSVk8jcyNmaSN1I2ZpI3YjZmkjeSNmaShiI2ZpKGojZmkhViNmaSFXI2Zpfk8oaSNmaX5QJTdoTyhpI3lPflAlN2hPUCRZT1g6VE9rOXdPeSN2T3ojd098I3hPIWU5eU8hZiN0TyFoI3VPIWwkWU8jZzl1TyNoOXZPI2k5dk8jajl2TyNrOXhPI2w5eU8jbTl5TyNuOlNPI285eU8jcTl6TyNzOXxPKFJWTyhpI3lPI3UjZmkjdiNmaSN5I2ZpKGIjZmkhViNmaSFXI2Zpfk8oaiNmaX5QJTlzTyhqI3pPflAlOXNPUCRZT1g6VE9rOXdPeSN2T3ojd098I3hPIWU5eU8hZiN0TyFoI3VPIWwkWU8jZzl1TyNoOXZPI2k5dk8jajl2TyNrOXhPI2w5eU8jbTl5TyNuOlNPI285eU8jcTl6TyNzOXxPI3U6T08oUlZPKGkjeU8oaiN6T35PI3YjZmkjeSNmaShiI2ZpIVYjZmkhVyNmaX5QJTxPT14jd3khViN3eSdrI3d5J2kjd3khUyN3eSFnI3d5byN3eSFYI3d5JWEjd3khYSN3eX5QITZVT2c7aE95KXFPfClyTyhpKXRPKGopdk9+T1AjZmlYI2ZpayNmaXojZmkhZSNmaSFmI2ZpIWgjZmkhbCNmaSNnI2ZpI2gjZmkjaSNmaSNqI2ZpI2sjZmkjbCNmaSNtI2ZpI24jZmkjbyNmaSNxI2ZpI3MjZmkjdSNmaSN2I2ZpI3kjZmkoUiNmaShiI2ZpIVYjZmkhVyNmaX5QJT52TyFmI3RPUChRWFgoUVhnKFFYayhRWHkoUVh6KFFYfChRWCFlKFFYIWgoUVghbChRWCNnKFFYI2goUVgjaShRWCNqKFFYI2soUVgjbChRWCNtKFFYI24oUVgjbyhRWCNxKFFYI3MoUVgjdShRWCN2KFFYI3koUVgoUihRWChiKFFYKGkoUVgoaihRWCFWKFFYIVcoUVh+TyN5I3ppIVYjemkhVyN6aX5QI0BfTyN5IW5pIVchbml+UCQgd08hVzZaT35PIVYnWWEhVydZYX5QI0BfTyFhI3JPKGInYk8hVidaYSFnJ1phfk8hVi9RTyFnKG9pfk8hVi9RTyFhI3JPIWcob2l+T2QkdXEhViR1cSNYJHVxI3kkdXF+UCEwUk8hUyddYSFWJ11hflAjKXRPIWE2Yk9+TyFWL1lPIVMocGl+UCMpdE8hVi9ZTyFTKHBpfk8hUzZmT35PIWEjck8jbzZrT35PazZsTyFhI3JPKGInYk9+TyFTNm5Pfk9kJHdxIVYkd3EjWCR3cSN5JHdxflAhMFJPXiRpeSFWJGl5J2skaXknaSRpeSFTJGl5IWckaXlvJGl5IVgkaXklYSRpeSFhJGl5flAhNlVPIVY0UU8hWChxYX5PXiNbeSFWI1t5J2sjW3knaSNbeSFTI1t5IWcjW3lvI1t5IVgjW3klYSNbeSFhI1t5flAhNlVPWDZzT35PIVYwWU8hVyh3aX5PXTZ5T35PIWE1Zk9+TyhVKG9PIVYnYlghVydiWH5PIVY0aU8hVyh0YX5PaWtPJ3Q3UU9+UC5fTyFXN1RPflAlIVZPbCFrT3w3VU8ndlRPJ3lVTyhVIWpPKGEhcE9+TyFYMHVPfk8hWDB1TyVhN1dPfk9nN1pPIVgwdU8lYTdXT35PWDdgTyFWJ2VhIVcnZWF+TyFWMVFPIVcodWl+TyFnN2RPfk8hZzdlT35PIWc3Zk9+TyFnN2ZPflAlUU9eN2hPfk8hYTdrT35PIWc3bE9+TyFWKGdpIVcoZ2l+UCNAX09eJV5PI1g3dE8nayVeT35PIVYoZHkhZyhkeV4oZHknayhkeX5QITZVTyFWKFpPIWcoY3l+TyFYJ1FPJWE3d09+TyNkJHVxUCR1cVgkdXFeJHVxayR1cXokdXEhViR1cSFlJHVxIWYkdXEhaCR1cSFsJHVxI2ckdXEjaCR1cSNpJHVxI2okdXEjayR1cSNsJHVxI20kdXEjbiR1cSNvJHVxI3EkdXEjcyR1cSN1JHVxI3YkdXEnayR1cShSJHVxKGIkdXEhZyR1cSFTJHVxJ2kkdXEjWCR1cW8kdXEhWCR1cSVhJHVxIWEkdXF+UCMpdE8jZCR3cVAkd3FYJHdxXiR3cWskd3F6JHdxIVYkd3EhZSR3cSFmJHdxIWgkd3EhbCR3cSNnJHdxI2gkd3EjaSR3cSNqJHdxI2skd3EjbCR3cSNtJHdxI24kd3EjbyR3cSNxJHdxI3Mkd3EjdSR3cSN2JHdxJ2skd3EoUiR3cShiJHdxIWckd3EhUyR3cSdpJHdxI1gkd3FvJHdxIVgkd3ElYSR3cSFhJHdxflAjKXRPIVYnUGkhZydQaX5QITZVTyN5I1txIVYjW3EhVyNbcX5QI0BfT3kvdE96L3RPfC91T1B2YVh2YWd2YWt2YSFldmEhZnZhIWh2YSFsdmEjZ3ZhI2h2YSNpdmEjanZhI2t2YSNsdmEjbXZhI252YSNvdmEjcXZhI3N2YSN1dmEjdnZhI3l2YShSdmEoYnZhKGl2YShqdmEhVnZhIVd2YX5PeSlxT3wpck9QJGxhWCRsYWckbGFrJGxheiRsYSFlJGxhIWYkbGEhaCRsYSFsJGxhI2ckbGEjaCRsYSNpJGxhI2okbGEjayRsYSNsJGxhI20kbGEjbiRsYSNvJGxhI3EkbGEjcyRsYSN1JGxhI3YkbGEjeSRsYShSJGxhKGIkbGEoaSRsYShqJGxhIVYkbGEhVyRsYX5PeSlxT3wpck9QJG5hWCRuYWckbmFrJG5heiRuYSFlJG5hIWYkbmEhaCRuYSFsJG5hI2ckbmEjaCRuYSNpJG5hI2okbmEjayRuYSNsJG5hI20kbmEjbiRuYSNvJG5hI3EkbmEjcyRuYSN1JG5hI3YkbmEjeSRuYShSJG5hKGIkbmEoaSRuYShqJG5hIVYkbmEhVyRuYX5PUCR8YVgkfGFrJHxheiR8YSFlJHxhIWYkfGEhaCR8YSFsJHxhI2ckfGEjaCR8YSNpJHxhI2okfGEjayR8YSNsJHxhI20kfGEjbiR8YSNvJHxhI3EkfGEjcyR8YSN1JHxhI3YkfGEjeSR8YShSJHxhKGIkfGEhViR8YSFXJHxhflAlPnZPI3kkaHEhViRocSFXJGhxflAjQF9PI3kkaXEhViRpcSFXJGlxflAjQF9PIVc4Uk9+TyN5OFNPflAhMFJPIWEjck8hVidaaSFnJ1ppfk8hYSNyTyhiJ2JPIVYnWmkhZydaaX5PIVYvUU8hZyhvcX5PIVMnXWkhViddaX5QIyl0TyFWL1lPIVMocHF+TyFTOFlPflAjKXRPIVM4WU9+T2QoUHkhVihQeX5QITBSTyFWJ2BhIVgnYGF+UCMpdE9eJVRxIVglVHEnayVUcSFWJVRxflAjKXRPWDhfT35PIVYwWU8hVyh3cX5PI1g4Y08hVidiYSFXJ2Jhfk8hVjRpTyFXKHRpflAjQF9PUFlYWFlYa1lYeVlYellYfFlYIVNZWCFWWVghZVlYIWZZWCFoWVghbFlYI1hZWCNkY1gjZ1lYI2hZWCNpWVgjallYI2tZWCNsWVgjbVlYI25ZWCNvWVgjcVlYI3NZWCN1WVgjdllYI3tZWChSWVgoYllYKGlZWChqWVh+TyFhJVJYI28lUlh+UCYvdk8hWDB1TyVhOGdPfk8ndlRPJ3lVTyhVOGxPfk8hVjFRTyFXKHVxfk8hZzhvT35PIWc4b09+UCVRTyFnOHFPfk8hZzhyT35PI1g4dE8hViNheSFXI2F5fk8hViNheSFXI2F5flAjQF9PIVgnUU8lYTh5T35PI3kjd3khViN3eSFXI3d5flAjQF9PUCR1aVgkdWlrJHVpeiR1aSFlJHVpIWYkdWkhaCR1aSFsJHVpI2ckdWkjaCR1aSNpJHVpI2okdWkjayR1aSNsJHVpI20kdWkjbiR1aSNvJHVpI3EkdWkjcyR1aSN1JHVpI3YkdWkjeSR1aShSJHVpKGIkdWkhViR1aSFXJHVpflAlPnZPeSlxT3wpck8oail2T1AlWGlYJVhpZyVYaWslWGl6JVhpIWUlWGkhZiVYaSFoJVhpIWwlWGkjZyVYaSNoJVhpI2klWGkjaiVYaSNrJVhpI2wlWGkjbSVYaSNuJVhpI28lWGkjcSVYaSNzJVhpI3UlWGkjdiVYaSN5JVhpKFIlWGkoYiVYaShpJVhpIVYlWGkhVyVYaX5PeSlxT3wpck9QJVppWCVaaWclWmlrJVppeiVaaSFlJVppIWYlWmkhaCVaaSFsJVppI2clWmkjaCVaaSNpJVppI2olWmkjayVaaSNsJVppI20lWmkjbiVaaSNvJVppI3ElWmkjcyVaaSN1JVppI3YlWmkjeSVaaShSJVppKGIlWmkoaSVaaShqJVppIVYlWmkhVyVaaX5PI3kkaXkhViRpeSFXJGl5flAjQF9PI3kjW3khViNbeSFXI1t5flAjQF9PIWEjck8hVidacSFnJ1pxfk8hVi9RTyFnKG95fk8hUyddcSFWJ11xflAjKXRPIVM5UU9+UCMpdE8hVjBZTyFXKHd5fk8hVjRpTyFXKHRxfk8hWDB1TyVhOVhPfk8hZzlbT35PIVgnUU8lYTlhT35PUCR1cVgkdXFrJHVxeiR1cSFlJHVxIWYkdXEhaCR1cSFsJHVxI2ckdXEjaCR1cSNpJHVxI2okdXEjayR1cSNsJHVxI20kdXEjbiR1cSNvJHVxI3EkdXEjcyR1cSN1JHVxI3YkdXEjeSR1cShSJHVxKGIkdXEhViR1cSFXJHVxflAlPnZPUCR3cVgkd3FrJHdxeiR3cSFlJHdxIWYkd3EhaCR3cSFsJHdxI2ckd3EjaCR3cSNpJHdxI2okd3EjayR3cSNsJHdxI20kd3EjbiR3cSNvJHdxI3Ekd3EjcyR3cSN1JHdxI3Ykd3EjeSR3cShSJHdxKGIkd3EhViR3cSFXJHdxflAlPnZPZCVdIVohViVdIVojWCVdIVojeSVdIVp+UCEwUk8hVidicSFXJ2JxflAjQF9PIVYjYSFaIVcjYSFaflAjQF9PI2QlXSFaUCVdIVpYJV0hWl4lXSFaayVdIVp6JV0hWiFWJV0hWiFlJV0hWiFmJV0hWiFoJV0hWiFsJV0hWiNnJV0hWiNoJV0hWiNpJV0hWiNqJV0hWiNrJV0hWiNsJV0hWiNtJV0hWiNuJV0hWiNvJV0hWiNxJV0hWiNzJV0hWiN1JV0hWiN2JV0hWidrJV0hWihSJV0hWihiJV0hWiFnJV0hWiFTJV0hWidpJV0hWiNYJV0hWm8lXSFaIVglXSFaJWElXSFaIWElXSFaflAjKXRPUCVdIVpYJV0hWmslXSFaeiVdIVohZSVdIVohZiVdIVohaCVdIVohbCVdIVojZyVdIVojaCVdIVojaSVdIVojaiVdIVojayVdIVojbCVdIVojbSVdIVojbiVdIVojbyVdIVojcSVdIVojcyVdIVojdSVdIVojdiVdIVojeSVdIVooUiVdIVooYiVdIVohViVdIVohVyVdIVp+UCU+dk9vKFZYflAxZ08ndSFpT35QISlqTyFTY1ghVmNYI1hjWH5QJi92T1BZWFhZWGtZWHlZWHpZWHxZWCFWWVghVmNYIWVZWCFmWVghaFlYIWxZWCNYWVgjWGNYI2RjWCNnWVgjaFlYI2lZWCNqWVgja1lYI2xZWCNtWVgjbllYI29ZWCNxWVgjc1lYI3VZWCN2WVgje1lYKFJZWChiWVgoaVlYKGpZWH5PIWFjWCFnWVghZ2NYKGJjWH5QJkVeT1A5bE9ROWxPYTtdT2IhZk9pa09rOWxPbGtPbWtPc2tPdTlsT3c5bE98V08hUWtPIVJrTyFYWE8hYzlvTyFoWk8hazlsTyFsOWxPIW05bE8hbzlwTyFxOXFPIXQhZU8kUSFoTyRVZk8ndClQTyd2VE8neVVPKFJWTyhhW08objtaT35PIVY6UU8hVyRrYX5PaSVQT2skcU9sJHBPbSRwT3MlUU91JVJPdzpXT3wkeE8hWCR5TyFjO2JPIWgkdU8jYzpeTyRRJVZPJG06WU8kbzpbTyRyJVdPJ3QoZ08ndlRPJ3lVTyd9JU9PKFIkck9+TyNwKVdPflAmSlNPIVdZWCFXY1h+UCZFXk8jZDl0T35PIWEjck8jZDl0T35PI1g6VU9+TyNvOXlPfk8jWDpgTyFWKGdYIVcoZ1h+TyNYOlVPIVYoZVghVyhlWH5PI2Q6YU9+T2Q6Y09+UCEwUk8jZDpoT35PI2Q6aU9+TyFhI3JPI2Q6ak9+TyFhI3JPI2Q6YU9+TyN5OmtPflAjQF9PI2Q6bE9+TyNkOm1Pfk8jZDpuT35PI2Q6b09+TyNkOnBPfk8jZDpxT35PI3k6ck9+UCEwUk8jeTpzT35QITBSTyRVfiFmIXwhfSNQI1EjVCNiI2MjbihuJG0kbyRyJVUlYCVhJWIlaCVqJW0lbiVwJXJ+J29SJFUobiNoIVInbSd1I2lsI2cjamt5J24oVSduJ3QkVyRZJFd+XCIsXG4gIGdvdG86IFwiJCVaKHtQUFBQKHxQKVBQKWFQKnAuclBQUFA1U1BQNWlQO2Q+aVA+fFA+fFBQUD58UEBsUD58UD58UD58UEBwUFBAdVBBYFBGVVBQUEZZUFBQUEZZSVhQUFBJX0pZUEZZUExnUFBQUE51RllQUFBGWVBGWVAhI1RGWVAhJmchJ2khJ3JQIShlIShpIShlUFBQUFAhK3IhJ2lQUCEsYCEtWVAhL3xGWUZZITBSITNaITduITduITtjUFBQITtqRllQUFBQUFBQUFBQUCE+dVAhQFdQUEZZIUFlUEZZUEZZRllGWUZZUEZZIUJ3UFAhRX1QIUlQUCFJVCFJXyFJYyFJY1AhRXpQIUlnIUlnUCFMaVAhTG1GWUZZIUxzIyB0PnxQPnxQPnw+fFAjI08+fD58IyR4PnwjJ1Y+fCMoeT58PnwjKWcjK2MjK2MjK2cjK28jK2MjK3dQIytjUD58IyxhPnwjLWk+fD58NVNQUFAjLnRQUCMvXiMvXlAjL15QIy9zIy9eUFAjL3lQIy9wUCMvcCMwXSMvcCMwdyMwfTVQKVAjMVEpUFAjMVgjMVgjMVhQKVBQKVBQKVBQKVBQUClQUCMxXyMxYlAjMWIpUFAjMWZQIzFpUClQUClQUClQUClQUClQUClQKVBQUCMxbyMxdSMyUCMyViMyXSMyYyMyaSMydyMyfSMzVCMzXyMzZSMzbyM0TyM0VSM0dSM1WCM1XyM1ZSM1cyM2WSM3aiM3eCM4TyM4VSM4WyM4YiM4bCM4ciM4eCM5UyM5ZiM5bFBQUFBQUFBQUFAjOXJQUFBQUFBQIzpmIz1tUCM+fCM/VCM/XVBQUFAjQ2cjRl0jTHIjTHUjTHgjTXEjTXQjTXcjTk8jTldQUCNOXiNOYiQgWiQhWiQhXyQhc1BQJCF3JCF9JCNSUCQjVSQjWSQjXSQkUiQkaSQkbiQkcSQkdCQkeiQkfSQlUiQlVlIheFJtcE9YciFYI2AlXSZkJmYmZyZpLF0sYjFiMWVZIXJRJ1EsfTB1NHBRJWN0USVrd1ElcnpRJlshVFMmeCFjLHVRJ1chZlMnXiFvIXVTKlkkeSpfUStUJWxRK2IldFErfCZVUSx7J1BRLVYnWFEtXydfUS9rKmFRMVArfVI6XzlwJHpkT1BXWFlacnN0dSFYIV4hbCNPI1MjViNgI2sjcSN1I3gjeyN8I30kTyRQJFEkUiRTJFQkVSRWJF4kYiVdJWMlcCZdJmAmZCZmJmcmaSZtJnUnUydkJ3Qndid8KFQoaShtKHEpcCpzK2csWCxdLGItUi1aLWktby5dLmQvdS96MFgweDFZMVoxWzFeMWIxZTFnMlcyXjJyNG00dzVaNV01XjVwN1U3WjdoN3RTI21dOW0hcilSJFgkaiZ5KWUsbixxLmwxdjNYNGs1ZzhjOHQ5bDlvOXA5cTl0OXU5djl3OXg5eTl6OXs5fDl9Ok86UDpROlU6XzpgOmE6YzpqOms6cDpxO15RKmolU1ErWSVuUSxPJlhRLFYmYVEuUzpWUTBPKntRMFMqfVEwXytaUTFYLFRRMmYuUFE0WTBZUTVPMVFRNXwyalE2UzpXUTZ1NFpSN3o1fSZ4a09QV1hZWnJzdHUhWCFeIWwjTyNTI1YjYCNrI3EjdSN4I3sjfCN9JE8kUCRRJFIkUyRUJFUkViRYJF4kYiRqJV0lYyVwJl0mYCZhJmQmZiZnJmkmbSZ1JnknUydkJ3Qndid8KFQoaShtKHEpZSlwKnMqeytnLFgsXSxiLG4scS1SLVotaS1vLlAuXS5kLmwvdS96MFgweDFZMVoxWzFeMWIxZTFnMXYyVzJeMmoycjNYNGs0bTR3NVo1XTVeNWc1cDV9N1U3WjdoN3Q4Yzh0OWw5bzlwOXE5dDl1OXY5dzl4OXk5ejl7OXw5fTpPOlA6UTpVOl86YDphOmM6ajprOnA6cTtedCFrUSFvIXIhdSF2JngnUCdRJ14nXydgLHUseyx9LV8wdTRwNHIkWSRwaSNyI3QkYCRhJHUkeCVUJVUlWSlsKXUpdyl4KlAqViplKmYqeip9K2wrby5PLlkvWC9ZL1svdzBsMG8wdzJpM2EzazNzM3k0UTRTNHY1ejZiNms3Vzd3OFM4Zzh5OVg5YTpTOlQ6WDpZOlo6WzpdOl46ZDplOmY6ZzpoOmk6bDptOm46bzpyOnM7WjtjO2Q7ZztoUSV1elEmdiFjUyZ8JXcseFErWSVuUy54KXIuelEvdipuUTBfK1pRMGQrYVExVyxTUTFYLFRRNFkwWVE0YzBmUTVSMVNRNVMxVlE2dTRaUTZ4NGBRN2M1VVE4YjZ5UjhtN2BwbU9YciFUIVgjYCVdJlomZCZmJmcmaSxdLGIxYjFlUixRJl0mcl5PUFhZcnN0dXghWCFeIWchbCNPI2AjayNxI3UjeCN7I3wjfSRPJFAkUSRSJFMkVCRVJFYkWCReJGIkaiVdJWMlcCZdJmAmYSZkJmYmZyZpJm0mdSdTJ2Qndid8KFQoaShtKHEpZSlwKnMqeytnLFgsXSxiLG4scS1SLVotaS1vLlAuXS5kLmwvdS96MFgweDFZMVoxWzFeMWIxZTFnMXYyVzJeMmoycjNYNGs0bTR3NVo1XTVeNWc1cDV9N1U3WjdoN3Q4Yzh0OWw5bzlwOXE5dDl1OXY5dzl4OXk5ejl7OXw5fTpPOlA6UTpVOl86YDphOmM6ajprOnA6cTtdO15bI1hXWiNTI1YmeSd0USVmdlElandTJW96JXQhVSV4fH0jZCNlI2glWiV2J30oWChZKForZStmK2gsWixvLW0tcy10LXUtdzFqMmIyYzVmNXdRJlEhUlEnVCFlUSdWIWZRKGIjb1MpfCR1KlFTK1MlayVsUStXJW5RK3cmU1EreyZVUy1VJ1cnWFEuUihjUS9VKX1RMFcrVFEwXitaUTBgK1tRMGMrYFEweit4UzFPK3wrfVEyUy1WUTNiL1FRNFgwWVE0XTBdUTRiMGVRNH0xUFE2XzNjUTZ0NFpRNnc0X1E4XjZzUjlTOF92JHdpI3QlVCVVJVkpdSl3KlAqZSpmLlkvWC93M2EzeThTO1o7YztkIVMlaHchZiFxJWolayVsJncnVidXJ1gnXSdnKlgrUytULHItVS1WLV4vYzBXMXsyUzJaM3VRKnwlZlErbSV9UStwJk9RK3omVVEuUShiUTB5K3dVMH0reyt8K31RMmsuUlE0eDB6UzR8MU8xUFE3XzR9IXo7XyNyJGAkYSR1JHgpbCl4KlYqeip9K2wrby5PL1kvWzBsMG8wdzJpM2szczRRNFM0djV6NmI2azdXN3c4Zzh5OVg5YTpYOlo6XTpkOmY6aDpsOm46cjtnO2hnO2A6UzpUOlk6WzpeOmU6ZzppOm06bzpzVyR8aSVPKmc7WlMlfSFPJlpRJk8hUFEmUCFRUitrJXskWiR7aSNyI3QkYCRhJHUkeCVUJVUlWSlsKXUpdyl4KlAqViplKmYqeip9K2wrby5PLlkvWC9ZL1svdzBsMG8wdzJpM2EzazNzM3k0UTRTNHY1ejZiNms3Vzd3OFM4Zzh5OVg5YTpTOlQ6WDpZOlo6WzpdOl46ZDplOmY6ZzpoOmk6bDptOm46bzpyOnM7WjtjO2Q7ZztoVCltJHIpblYqayVTOlY6V1UmfCFjJXcseFMocCN2I3dRK18lcVMteiheKF9RMHArcVEzei90UjZ9NGkmeGtPUFdYWVpyc3R1IVghXiFsI08jUyNWI2AjayNxI3UjeCN7I3wjfSRPJFAkUSRSJFMkVCRVJFYkWCReJGIkaiVdJWMlcCZdJmAmYSZkJmYmZyZpJm0mdSZ5J1MnZCd0J3YnfChUKGkobShxKWUpcCpzKnsrZyxYLF0sYixuLHEtUi1aLWktby5QLl0uZC5sL3UvejBYMHgxWTFaMVsxXjFiMWUxZzF2MlcyXjJqMnIzWDRrNG00dzVaNV01XjVnNXA1fTdVN1o3aDd0OGM4dDlsOW85cDlxOXQ5dTl2OXc5eDl5OXo5ezl8OX06TzpQOlE6VTpfOmA6YTpjOmo6azpwOnE7XiRpJF1jI1UjYSVhJWIlZCdzJ3koZShsKHQodSh2KHcoeCh5KHooeyh8KH0pTylRKVQpWCljKngrXixzLWItZy1sLW4uWC5fLmMuZS5mLmcudi94MXExdDJVMl0ycTJ2MncyeDJ5MnoyezJ8Mn0zTzNQM1EzUjNTM1YzVzNdNE80VjVpNW81dDZRNlI2VzZYN1A3bjdyN3s4UDhROHY5VTldOW47UVQjUFYjUSZ5a09QV1hZWnJzdHUhWCFeIWwjTyNTI1YjYCNrI3EjdSN4I3sjfCN9JE8kUCRRJFIkUyRUJFUkViRYJF4kYiRqJV0lYyVwJl0mYCZhJmQmZiZnJmkmbSZ1JnknUydkJ3Qndid8KFQoaShtKHEpZSlwKnMqeytnLFgsXSxiLG4scS1SLVotaS1vLlAuXS5kLmwvdS96MFgweDFZMVoxWzFeMWIxZTFnMXYyVzJeMmoycjNYNGs0bTR3NVo1XTVeNWc1cDV9N1U3WjdoN3Q4Yzh0OWw5bzlwOXE5dDl1OXY5dzl4OXk5ejl7OXw5fTpPOlA6UTpVOl86YDphOmM6ajprOnA6cTteUSZ6IWNSMXcsdXYha1EhYyFvIXIhdSF2JngnUCdRJ14nXydgLHUseyx9LV8wdTRwNHJTKlgkeSpfUy9jKlkqYVEvbCpiUTByK3NRM3Uva1IzeC9ubHBPWHIhWCNgJV0mZCZmJmcmaSxdLGIxYjFlUSZrIVtRJ2ghdFMoZCNxOXRRK1ElaVErdSZRUSt2JlJRLVMnVVEtYSdhUy5XKGk6YVMveSpzOmpRMFUrUlEwdCt0UTFpLGRRMWssZVExcyxwUTJRLVRRMlQtWFM0UC96OnBRNFQwVlM0VzBYOnFRNWgxdVE1bDJSUTVxMllRNnI0VVE3bzVqUTdwNW1RN3M1clI4czdsJGQkW2MjVSNhJWIlZCdzJ3koZShsKHQodSh2KHcoeCh5KHooeyh8KH0pTylRKVQpWCljKngrXixzLWItZy1sLW4uWC5fLmMuZi5nLnYveDFxMXQyVTJdMnEydjJ3MngyeTJ6MnsyfDJ9M08zUDNRM1IzUzNWM1czXTRPNFY1aTVvNXQ2UTZSNlc2WDdQN243cjd7OFA4UTh2OVU5XTluO1FTKGEjbCdaVSpkJHooaDNVUyp3JWEuZVEyZzBPUTV5MmZRN3k1fFI4ejd6JGQkWmMjVSNhJWIlZCdzJ3koZShsKHQodSh2KHcoeCh5KHooeyh8KH0pTylRKVQpWCljKngrXixzLWItZy1sLW4uWC5fLmMuZi5nLnYveDFxMXQyVTJdMnEydjJ3MngyeTJ6MnsyfDJ9M08zUDNRM1IzUzNWM1czXTRPNFY1aTVvNXQ2UTZSNlc2WDdQN243cjd7OFA4UTh2OVU5XTluO1FTKGAjbCdaUyhyI3ckW1MqdiVhLmVTLXsoXyhhUS5oKVNRL3sqd1IyZC18JnhrT1BXWFlacnN0dSFYIV4hbCNPI1MjViNgI2sjcSN1I3gjeyN8I30kTyRQJFEkUiRTJFQkVSRWJFgkXiRiJGolXSVjJXAmXSZgJmEmZCZmJmcmaSZtJnUmeSdTJ2QndCd2J3woVChpKG0ocSllKXAqcyp7K2csWCxdLGIsbixxLVItWi1pLW8uUC5dLmQubC91L3owWDB4MVkxWjFbMV4xYjFlMWcxdjJXMl4yajJyM1g0azRtNHc1WjVdNV41ZzVwNX03VTdaN2g3dDhjOHQ5bDlvOXA5cTl0OXU5djl3OXg5eTl6OXs5fDl9Ok86UDpROlU6XzpgOmE6YzpqOms6cDpxO15TI21dOW1RJmYhVlEmZyFXUSZpIVlRJmohWlIxYSxgUSdSIWVRKnklZlEtUSdUUy19KGIqfFEyTy1QVzJoLlEuUi99MFBRNWsyUFU1eDJlMmcya1M3djV5NXtTOHg3eDd5UzlfOHc4elE5ZzlgUjlqOWhVIXNRJ1EsfVQ0bjB1NHAhT19PWFpgciFUIVgjYCNkJVolXSZaJl0mZCZmJmcmaShaLF0sYi10MWIxZV0hbVEhbydRLH0wdTRwVCNtXTltJVV5T1BXWFlacnN0dSFYIV4hbCNPI1MjViNgI2sjcSN1I3gjeyN8I30kTyRQJFEkUiRTJFQkVSRWJF4kYiVdJWMlcCZdJmAmYSZkJmYmZyZpJm0mdSdTJ2QndCd2J3woVChpKG0ocSlwKnMqeytnLFgsXSxiLVItWi1pLW8uUC5dLmQvdS96MFgweDFZMVoxWzFeMWIxZTFnMlcyXjJqMnI0bTR3NVo1XTVeNXA1fTdVN1o3aDd0UyhwI3Yjd1MteiheKF8hczp3JFgkaiZ5KWUsbixxLmwxdjNYNGs1ZzhjOHQ5bDlvOXA5cTl0OXU5djl3OXg5eTl6OXs5fDl9Ok86UDpROlU6XzpgOmE6YzpqOms6cDpxO15ZIXFRJ1EsfTB1NHBRJ10hb1MnZyFyIXVTJ2khdjRyUy1eJ14nX1EtYCdgUjJaLV9RJ2YhcVMoViNjMV9TLV0nXSdpUS9UKXxRL2EqWFEyWy1gUTNnL1VTM3AvYi9sUTZeM2JTNmkzdjN4UThVNl9SOF02bFEjc2JRJ2UhcVMoVSNjMV9TKFcjaSpyUSp0JVtRK08lZ1ErVSVtVS1bJ10nZidpUS1wKFZRL1MpfFEvYCpYUS9mKltRMFQrUFEweyt5UzJYLV0tYFEyYS14UzNmL1QvVVMzby9hL2xRM3IvZVEzdC9nUTR6MHxRNXMyW1E2XTNiUTZhM2dTNmUzcDN4UTZqM3dRN100e1M4VDZeNl9ROFg2ZlE4WjZpUThqN15ROU84VVE5UDhZUTlSOF1ROVo4a1E5YzlRUTp6OnVRO1Y7T1I7VztQViFzUSdRLH0lVWFPUFdYWVpyc3R1IVghXiFsI08jUyNWI2AjayNxI3UjeCN7I3wjfSRPJFAkUSRSJFMkVCRVJFYkXiRiJV0lYyVwJl0mYCZhJmQmZiZnJmkmbSZ1J1MnZCd0J3YnfChUKGkobShxKXAqcyp7K2csWCxdLGItUi1aLWktby5QLl0uZC91L3owWDB4MVkxWjFbMV4xYjFlMWcyVzJeMmoycjRtNHc1WjVdNV41cDV9N1U3WjdoN3RTI3N4IWchcjp0JFgkaiZ5KWUsbixxLmwxdjNYNGs1ZzhjOHQ5bDlvOXA5cTl0OXU5djl3OXg5eTl6OXs5fDl9Ok86UDpROlU6XzpgOmE6YzpqOms6cDpxO15SOno7XSVVYk9QV1hZWnJzdHUhWCFeIWwjTyNTI1YjYCNrI3EjdSN4I3sjfCN9JE8kUCRRJFIkUyRUJFUkViReJGIlXSVjJXAmXSZgJmEmZCZmJmcmaSZtJnUnUydkJ3Qndid8KFQoaShtKHEpcCpzKnsrZyxYLF0sYi1SLVotaS1vLlAuXS5kL3UvejBYMHgxWTFaMVsxXjFiMWUxZzJXMl4yajJyNG00dzVaNV01XjVwNX03VTdaN2g3dFElW2ohUyVndyFmIXElaiVrJWwmdydWJ1cnWCddJ2cqWCtTK1Qsci1VLVYtXi9jMFcxezJTMlozdVMlbXghZ1ErUCVoUSt5JlVXMHwreit7K3wrfVU0ezB9MU8xUFM3XjR8NH1ROGs3XyFyOnUkWCRqJnkpZSxuLHEubDF2M1g0azVnOGM4dDlsOW85cDlxOXQ5dTl2OXc5eDl5OXo5ezl8OX06TzpQOlE6VTpfOmA6YTpjOmo6azpwOnE7XlE7TztbUjtQO10keGVPUFhZcnN0dSFYIV4hbCNPI2AjayNxI3UjeCN7I3wjfSRPJFAkUSRSJFMkVCRVJFYkXiRiJV0lYyVwJl0mYCZkJmYmZyZpJm0mdSdTJ2Qndid8KFQoaShtKHEpcCpzKnsrZyxYLF0sYi1SLVotaS1vLlAuXS5kL3UvejBYMHgxWTFaMVsxXjFiMWUxZzJXMl4yajJyNG00dzVaNV01XjVwNX03VTdaN2g3dFkjXldaI1MjVid0IVUleHx9I2QjZSNoJVoldid9KFgoWShaK2UrZitoLFosby1tLXMtdC11LXcxajJiMmM1ZjV3USxXJmEhcDp2JFgkaillLG4scS5sMXYzWDRrNWc4Yzh0OWw5bzlwOXE5dDl1OXY5dzl4OXk5ejl7OXw5fTpPOlA6UTpVOl86YDphOmM6ajprOnA6cTteUjp5JnlTJn0hYyV3UjF5LHgkemRPUFdYWVpyc3R1IVghXiFsI08jUyNWI2AjayNxI3UjeCN7I3wjfSRPJFAkUSRSJFMkVCRVJFYkXiRiJV0lYyVwJl0mYCZkJmYmZyZpJm0mdSdTJ2QndCd2J3woVChpKG0ocSlwKnMrZyxYLF0sYi1SLVotaS1vLl0uZC91L3owWDB4MVkxWjFbMV4xYjFlMWcyVzJeMnI0bTR3NVo1XTVeNXA3VTdaN2g3dCFyKVIkWCRqJnkpZSxuLHEubDF2M1g0azVnOGM4dDlsOW85cDlxOXQ5dTl2OXc5eDl5OXo5ezl8OX06TzpQOlE6VTpfOmA6YTpjOmo6azpwOnE7XlEsViZhUTBPKntRMmYuUFE1fDJqUjd6NX0hZiRSYyNVJWEncyd5KGUobCh7KHwofSlPKVQpWCteLWItZy1sLW4uWC5fLnYveDJVMl0ycTNTNE80VjVvNXQ2UTdyOHY5biFUOXspUSljLHMuZTFxMXQydjNPM1AzUTNSM1YzXTVpNlI2VzZYN1A3bjd7OFA4UTlVOV07USFiJFRjI1UlYSdzJ3koZShsKH0pTylUKVgrXi1iLWctbC1uLlguXy52L3gyVTJdMnEzUzRPNFY1bzV0NlE3cjh2OW4hUDl9KVEpYyxzLmUxcTF0MnYzUTNSM1YzXTVpNlI2VzZYN1A3bjd7OFA4UTlVOV07USFeJFhjI1UlYSdzJ3koZShsKVQpWCteLWItZy1sLW4uWC5fLnYveDJVMl0ycTNTNE80VjVvNXQ2UTdyOHY5blEzYS9PejteKVEpYyxzLmUxcTF0MnYzVjNdNWk2UjZXNlg3UDduN3s4UDhROVU5XTtRUTtjO2VSO2Q7ZiZ4a09QV1hZWnJzdHUhWCFeIWwjTyNTI1YjYCNrI3EjdSN4I3sjfCN9JE8kUCRRJFIkUyRUJFUkViRYJF4kYiRqJV0lYyVwJl0mYCZhJmQmZiZnJmkmbSZ1JnknUydkJ3Qndid8KFQoaShtKHEpZSlwKnMqeytnLFgsXSxiLG4scS1SLVotaS1vLlAuXS5kLmwvdS96MFgweDFZMVoxWzFeMWIxZTFnMXYyVzJeMmoycjNYNGs0bTR3NVo1XTVeNWc1cDV9N1U3WjdoN3Q4Yzh0OWw5bzlwOXE5dDl1OXY5dzl4OXk5ejl7OXw5fTpPOlA6UTpVOl86YDphOmM6ajprOnA6cTteUyRraCRsUjNZLmsnUGdPUFdYWVpocnN0dSFYIV4hbCNPI1MjViNgI2sjcSN1I3gjeyN8I30kTyRQJFEkUiRTJFQkVSRWJFgkXiRiJGokbCVdJWMlcCZdJmAmYSZkJmYmZyZpJm0mdSZ5J1MnZCd0J3YnfChUKGkobShxKWUpcCpzKnsrZyxYLF0sYixuLHEtUi1aLWktby5QLl0uZC5rLmwvdS96MFgweDFZMVoxWzFeMWIxZTFnMXYyVzJeMmoycjNYNGs0bTR3NVo1XTVeNWc1cDV9N1U3WjdoN3Q4Yzh0OWw5bzlwOXE5dDl1OXY5dzl4OXk5ejl7OXw5fTpPOlA6UTpVOl86YDphOmM6ajprOnA6cTteVCRnZiRtUSRlZlMpWyRoKWBSKWgkbVQkZmYkbVQpXiRoKWAnUGhPUFdYWVpocnN0dSFYIV4hbCNPI1MjViNgI2sjcSN1I3gjeyN8I30kTyRQJFEkUiRTJFQkVSRWJFgkXiRiJGokbCVdJWMlcCZdJmAmYSZkJmYmZyZpJm0mdSZ5J1MnZCd0J3YnfChUKGkobShxKWUpcCpzKnsrZyxYLF0sYixuLHEtUi1aLWktby5QLl0uZC5rLmwvdS96MFgweDFZMVoxWzFeMWIxZTFnMXYyVzJeMmoycjNYNGs0bTR3NVo1XTVeNWc1cDV9N1U3WjdoN3Q4Yzh0OWw5bzlwOXE5dDl1OXY5dzl4OXk5ejl7OXw5fTpPOlA6UTpVOl86YDphOmM6ajprOnA6cTteVCRraCRsUSRuaFIpZyRsJVVqT1BXWFlacnN0dSFYIV4hbCNPI1MjViNgI2sjcSN1I3gjeyN8I30kTyRQJFEkUiRTJFQkVSRWJF4kYiVdJWMlcCZdJmAmYSZkJmYmZyZpJm0mdSdTJ2QndCd2J3woVChpKG0ocSlwKnMqeytnLFgsXSxiLVItWi1pLW8uUC5dLmQvdS96MFgweDFZMVoxWzFeMWIxZTFnMlcyXjJqMnI0bTR3NVo1XTVeNXA1fTdVN1o3aDd0IXM7WyRYJGomeSllLG4scS5sMXYzWDRrNWc4Yzh0OWw5bzlwOXE5dDl1OXY5dzl4OXk5ejl7OXw5fTpPOlA6UTpVOl86YDphOmM6ajprOnA6cTteI2FsT1BYWnIhWCFeIWwjTyNgI2sjeCRqJV0mXSZgJmEmZCZmJmcmaSZtJnUnUyhxKWUqeytnLFgsXSxiLVIuUC5sL3UweDFZMVoxWzFeMWIxZTFnMmozWDRtNHc1WjVdNV41fTdVN1o3aHYkemkjdCVUJVUlWSl1KXcqUCplKmYuWS9YL3czYTN5OFM7WjtjO2QheihoI3IkYCRhJHUkeClsKXgqVip6Kn0rbCtvLk8vWS9bMGwwbzB3MmkzazNzNFE0UzR2NXo2YjZrN1c3dzhnOHk5WDlhOlg6WjpdOmQ6ZjpoOmw6bjpyO2c7aFEqbyVXUS53KXFnM1U6UzpUOlk6WzpeOmU6ZzppOm06bzpzdiR2aSN0JVQlVSVZKXUpdypQKmUqZi5ZL1gvdzNhM3k4UztaO2M7ZFEqUiR3UypbJHkqX1EqcCVYUS9nKl0hejp8I3IkYCRhJHUkeClsKXgqVip6Kn0rbCtvLk8vWS9bMGwwbzB3MmkzazNzNFE0UzR2NXo2YjZrN1c3dzhnOHk5WDlhOlg6WjpdOmQ6ZjpoOmw6bjpyO2c7aGY6fTpTOlQ6WTpbOl46ZTpnOmk6bTpvOnNRO1I7X1E7UztgUTtUO2FSO1U7YnYkemkjdCVUJVUlWSl1KXcqUCplKmYuWS9YL3czYTN5OFM7WjtjO2QheihoI3IkYCRhJHUkeClsKXgqVip6Kn0rbCtvLk8vWS9bMGwwbzB3MmkzazNzNFE0UzR2NXo2YjZrN1c3dzhnOHk5WDlhOlg6WjpdOmQ6ZjpoOmw6bjpyO2c7aGczVTpTOlQ6WTpbOl46ZTpnOmk6bTpvOnNsbk9YciFYI2AlXSZkJmYmZyZpLF0sYjFiMWVRKlUkeFEsayZwUSxsJnJSM2ovWSRZJHtpI3IjdCRgJGEkdSR4JVQlVSVZKWwpdSl3KXgqUCpWKmUqZip6Kn0rbCtvLk8uWS9YL1kvWy93MGwwbzB3MmkzYTNrM3MzeTRRNFM0djV6NmI2azdXN3c4UzhnOHk5WDlhOlM6VDpYOlk6WjpbOl06XjpkOmU6ZjpnOmg6aTpsOm06bjpvOnI6cztaO2M7ZDtnO2hRK24mT1EwbitwUTRnMG1SNnw0aFQqXiR5Kl9TKl4keSpfVDRvMHU0cFMvZSpaNG1UM3cvbTdVUStPJWdRL2YqW1EwVCtQUTB7K3lRNHowfFE3XTR7UThqN15SOVo4a24pdSRzKGoqcS9XL28vcDJvM2gzfTZbNm04fTp7O1g7WSFXOmQoZilWKXsqVC5WLnMvTy9dL3wwazBtMm4zaTNtNGY0aDZPNlA2YzZnNm82cThXOFs5YjtlO2ZdOmUzVDZWN3w4ezh8OWtwKXckcyhqKnEufC9XL28vcDJvM2gzfTZbNm04fTp7O1g7WSFZOmYoZilWKXsqVC5WLnMvTy9dL3wwazBtMmwybjNpM200ZjRoNk82UDZjNmc2bzZxOFc4WzliO2U7Zl86ZzNUNlY3fDd9OHs4fDlrcG1PWHIhVCFYI2AlXSZaJmQmZiZnJmksXSxiMWIxZVEmVyFTUixYJmFwbU9YciFUIVgjYCVdJlomZCZmJmcmaSxdLGIxYjFlUiZXIVNRK3ImUFIwaitrcW1PWHIhVCFYI2AlXSZaJmQmZiZnJmksXSxiMWIxZVEwdit3UzR1MHkwelU3VjRzNHQ0eFM4ZjdYN1lTOVY4ZThoUTlkOVdSOWk5ZVEmXyFUUixSJlpSNVIxU1Mlb3oldFIwYCtbUSZkIVVSLF0mZVIsYyZqVDFjLGIxZVIsZyZrUSxmJmtSMWwsZ1EnayF3Ui1jJ2tRck9RI2BYVCVgciNgUSF6VFInbSF6USF9VVInbyF9USluJHJSLnQpblEjUVZSJ3EjUVEjVFdVJ3cjVCd4LWpRJ3gjVVItaid5USx2JnpSMXgsdlEuWihqUjJwLlpRLl4obFMycy5eMnRSMnQuX1EsfSdRUjF8LH1ZIW9RJ1EsfTB1NHBSJ1shb1MjWlcldlUoTyNaKFAta1EoUCNbUi1rJ3pRLHkmfVIxeix5cmBPWHIhVCFYI2AlXSZaJl0mZCZmJmcmaSxdLGIxYjFlUyNkWiVaVSNuYCNkLXRSLXQoWlEoWyNmUS1xKFdXLXkoWy1xMl81dVEyXy1yUjV1MmBRKWAkaFIubSlgUSRsaFIpZiRsUSRfY1UpVSRfLWY6UlEtZjluUjpSKWNRL1IpfFczZC9SM2U2YDhWVTNlL1MvVC9VUzZgM2YzZ1I4VjZhI20pcyRzKGYoailWKXsqVCpsKm0qcS5ULlUuVi5zLnwufS9PL1cvXS9vL3AvfDBrMG0ybDJtMm4ybzNUM2gzaTNtM300ZjRoNk82UDZUNlU2VjZbNmM2ZzZtNm82cTd8N304TzhXOFs4ezh8OH05YjlrOns7WDtZO2U7ZlEvWipUVTNsL1ozbjZkUTNuL11SNmQzbVEqXyR5Ui9pKl9RKmgkfVIvcipoUTRSL3xSNnA0UlEraSV5UjBpK2lRNGowcFM3TzRqOGRSOGQ3UFErdCZRUjBzK3RRNHAwdVI3UzRwUTFSLE9TNVAxUjdhUjdhNVJRMForV1c0WzBaNF42djhgUTReMF5RNnY0XVI4YDZ3UStdJW9SMGErXVExZSxiUjVhMWVXcU9YciNgUSZoIVhRKnUlXVEsWyZkUSxeJmZRLF8mZ1EsYSZpUTFgLF1TMWMsYjFlUjVgMWJRJV9vUSZsIV1RJm8hX1EmcSFgUSZzIWFRJ2MhcVErUSVpUStkJXVRK2olelEsUSZfUSxpJm5XLVknXSdlJ2YnaVEtYSdhUS9oKl5RMFUrUlMxVSxSLFVRMW0saFExbixrUTFvLGxRMlQtWFcyVi1bLV0tYC1iUTRUMFZRNGEwZFE0ZTBrUTR5MHtRNVQxV1E1XzFhVTVuMlUyWDJbUTVxMllRNnI0VVE2ejRjUTZ7NGZRN1I0b1E3WzR6UTdiNVNTN3E1bzVzUTdzNXJROGE2eFE4aTddUThuN2NROHU3clE5VDhiUTlZOGpROV44dlI5ZjlaUSVpd1EnVSFmUSdhIXFVK1IlaiVrJWxRLHAmd1UtVCdWJ1cnWFMtWCddJ2dRL18qWFMwVitTK1RRMXUsclMyUi1VLVZRMlktXlEzcS9jUTRVMFdRNWoxe1E1bTJTUTVyMlpSNmgzdVMkdGk7WlIqaSVPVSR9aSVPO1pSL3EqZ1Ekc2lTKGYjcip9UShqI3RTKVYkYCRhUSl7JHVRKlQkeFEqbCVUUSptJVVRKnElWVEuVDpYUS5VOlpRLlY6XVEucylsUS58KXVRLn0pd1EvTyl4US9XKlBRL10qVlEvbyplUS9wKmZoL3wqei5PMHcyaTR2NXo3Vzd3OGc4eTlYOWFRMGsrbFEwbStvUTJsOmRRMm06ZlEybjpoUTJvLllTM1Q6UzpUUTNoL1hRM2kvWVEzbS9bUTN9L3dRNGYwbFE0aDBvUTZPOmxRNlA6blE2VDpZUTZVOltRNlY6XlE2WzNhUTZjM2tRNmczc1E2bTN5UTZvNFFRNnE0U1E3fDppUTd9OmVROE86Z1E4VzZiUThbNmtROHs6bVE4fDpvUTh9OFNROWI6clE5azpzUTp7O1pRO1g7Y1E7WTtkUTtlO2dSO2Y7aGxvT1hyIVgjYCVdJmQmZiZnJmksXSxiMWIxZVEhZFBTI2JaI2tRJm4hXlUnWSFsNG03VVEncCNPUShzI3hRKWQkalMsVSZdJmBRLFkmYVEsaCZtUSxtJnVRLVAnU1EuYShxUS5xKWVRMFAqe1EwZytnUTFdLFhRMlAtUlEyZy5QUTNbLmxRM3svdVE0dDB4UTVWMVlRNVcxWlE1WTFbUTVbMV5RNWMxZ1E1eTJqUTZZM1hRN1k0d1E3ZzVaUTdpNV1RN2o1XlE3eTV9UThoN1pSOHA3aCNVY09QWFpyIVghXiFsI2AjayN4JV0mXSZgJmEmZCZmJmcmaSZtJnUnUyhxKnsrZyxYLF0sYi1SLlAvdTB4MVkxWjFbMV4xYjFlMWcyajRtNHc1WjVdNV41fTdVN1o3aFEjVVdRI2FZUSVhc1ElYnRRJWR1UydzI1MndlEneSNWUShlI3FRKGwjdVEodCN7USh1I3xRKHYjfVEodyRPUSh4JFBRKHkkUVEoeiRSUSh7JFNRKHwkVFEofSRVUSlPJFZRKVEkWFEpVCReUSlYJGJXKWMkaillLmwzWFEqeCVjUSteJXBTLHMmeTF2US1iJ2RTLWcndC1pUS1sJ3xRLW4oVFEuWChpUS5fKG1RLmM5bFEuZTlvUS5mOXBRLmc5cVEudilwUS94KnNRMXEsblExdCxxUTJVLVpRMl0tb1EycS5dUTJ2OXRRMnc5dVEyeDl2UTJ5OXdRMno5eFEyezl5UTJ8OXpRMn05e1EzTzl8UTNQOX1RM1E6T1EzUjpQUTNTLmRRM1Y6VVEzVzpfUTNdOlFRNE8velE0VjBYUTVpOmBRNW8yV1E1dDJeUTZRMnJRNlI6YVE2VzpjUTZYOmpRN1A0a1E3bjVnUTdyNXBRN3s6a1E4UDpwUThROnFROHY3dFE5VThjUTldOHRROW4jT1I7UTteUiNXV1ImeyFjWSFxUSdRLH0wdTRwUyZ3IWMsdVEnXSFvUydnIXIhdVMnaSF2NHJTLHImeCdQUy1eJ14nX1EtYCdgUTF7LHtSMlotX1IoayN0UihuI3VRIWRRVCx8J1EsfV0hblEhbydRLH0wdTRwUSNsXVInWjltVCNnWiVaUyNmWiVaVSV5fH0sWlUoVyNkI2UjaFMtcihYKFlRLXYoWlEwaCtoUTJgLXNVMmEtdC11LXdTNXYyYjJjUjd1NXdgI1lXI1MjViV2J3QnfStlLW10I2NafH0jZCNlI2glWihYKFkoWitoLXMtdC11LXcyYjJjNXdRMV8sWlExcixvUTVlMWpRN201ZlQ6eCZ5K2ZUI11XJXZTI1tXJXZTJ3UjUyd9Uyd6I1YrZVMsdCZ5K2ZULWgndC1tVCdPIWMld1EkaGZSKWokbVQpXyRoKWBSM1oua1QqTyR1KlFSKlckeFEvfSp6UTJlLk9RNHMwd1E1ezJpUTdYNHZRN3g1elE4ZTdXUTh3N3dROVc4Z1E5YDh5UTllOVhSOWg5YWxwT1hyIVgjYCVdJmQmZiZnJmksXSxiMWIxZVEmXiFUUixRJlpWJXp8fSxaUjBxK3FSLFAmWFElc3pSK2MldFIrWCVuVCZiIVUmZVQmYyFVJmVUMWQsYjFlXCIsXG4gIG5vZGVOYW1lczogXCLimqAgQXJpdGhPcCBBcml0aE9wIExpbmVDb21tZW50IEJsb2NrQ29tbWVudCBTY3JpcHQgRXhwb3J0RGVjbGFyYXRpb24gZXhwb3J0IFN0YXIgYXMgVmFyaWFibGVOYW1lIFN0cmluZyBFc2NhcGUgZnJvbSA7IGRlZmF1bHQgRnVuY3Rpb25EZWNsYXJhdGlvbiBhc3luYyBmdW5jdGlvbiBWYXJpYWJsZURlZmluaXRpb24gPiBUeXBlUGFyYW1MaXN0IFR5cGVEZWZpbml0aW9uIGV4dGVuZHMgVGhpc1R5cGUgdGhpcyBMaXRlcmFsVHlwZSBBcml0aE9wIE51bWJlciBCb29sZWFuTGl0ZXJhbCBUZW1wbGF0ZVR5cGUgSW50ZXJwb2xhdGlvbkVuZCBJbnRlcnBvbGF0aW9uIEludGVycG9sYXRpb25TdGFydCBOdWxsVHlwZSBudWxsIFZvaWRUeXBlIHZvaWQgVHlwZW9mVHlwZSB0eXBlb2YgTWVtYmVyRXhwcmVzc2lvbiAuID8uIFByb3BlcnR5TmFtZSBbIFRlbXBsYXRlU3RyaW5nIEVzY2FwZSBJbnRlcnBvbGF0aW9uIHN1cGVyIFJlZ0V4cCBdIEFycmF5RXhwcmVzc2lvbiBTcHJlYWQgLCB9IHsgT2JqZWN0RXhwcmVzc2lvbiBQcm9wZXJ0eSBhc3luYyBnZXQgc2V0IFByb3BlcnR5RGVmaW5pdGlvbiBCbG9jayA6IE5ld0V4cHJlc3Npb24gbmV3IFR5cGVBcmdMaXN0IENvbXBhcmVPcCA8ICkgKCBBcmdMaXN0IFVuYXJ5RXhwcmVzc2lvbiBkZWxldGUgTG9naWNPcCBCaXRPcCBZaWVsZEV4cHJlc3Npb24geWllbGQgQXdhaXRFeHByZXNzaW9uIGF3YWl0IFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIENsYXNzRXhwcmVzc2lvbiBjbGFzcyBDbGFzc0JvZHkgTWV0aG9kRGVjbGFyYXRpb24gRGVjb3JhdG9yIEAgTWVtYmVyRXhwcmVzc2lvbiBQcml2YXRlUHJvcGVydHlOYW1lIENhbGxFeHByZXNzaW9uIGRlY2xhcmUgUHJpdmFjeSBzdGF0aWMgYWJzdHJhY3Qgb3ZlcnJpZGUgUHJpdmF0ZVByb3BlcnR5RGVmaW5pdGlvbiBQcm9wZXJ0eURlY2xhcmF0aW9uIHJlYWRvbmx5IGFjY2Vzc29yIE9wdGlvbmFsIFR5cGVBbm5vdGF0aW9uIEVxdWFscyBTdGF0aWNCbG9jayBGdW5jdGlvbkV4cHJlc3Npb24gQXJyb3dGdW5jdGlvbiBQYXJhbUxpc3QgUGFyYW1MaXN0IEFycmF5UGF0dGVybiBPYmplY3RQYXR0ZXJuIFBhdHRlcm5Qcm9wZXJ0eSBQcml2YWN5IHJlYWRvbmx5IEFycm93IE1lbWJlckV4cHJlc3Npb24gQmluYXJ5RXhwcmVzc2lvbiBBcml0aE9wIEFyaXRoT3AgQXJpdGhPcCBBcml0aE9wIEJpdE9wIENvbXBhcmVPcCBpbnN0YW5jZW9mIHNhdGlzZmllcyBpbiBjb25zdCBDb21wYXJlT3AgQml0T3AgQml0T3AgQml0T3AgTG9naWNPcCBMb2dpY09wIENvbmRpdGlvbmFsRXhwcmVzc2lvbiBMb2dpY09wIExvZ2ljT3AgQXNzaWdubWVudEV4cHJlc3Npb24gVXBkYXRlT3AgUG9zdGZpeEV4cHJlc3Npb24gQ2FsbEV4cHJlc3Npb24gVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uIER5bmFtaWNJbXBvcnQgaW1wb3J0IEltcG9ydE1ldGEgSlNYRWxlbWVudCBKU1hTZWxmQ2xvc2VFbmRUYWcgSlNYU3RhcnRUYWcgSlNYU2VsZkNsb3NpbmdUYWcgSlNYSWRlbnRpZmllciBKU1hCdWlsdGluIEpTWElkZW50aWZpZXIgSlNYTmFtZXNwYWNlZE5hbWUgSlNYTWVtYmVyRXhwcmVzc2lvbiBKU1hTcHJlYWRBdHRyaWJ1dGUgSlNYQXR0cmlidXRlIEpTWEF0dHJpYnV0ZVZhbHVlIEpTWEVzY2FwZSBKU1hFbmRUYWcgSlNYT3BlblRhZyBKU1hGcmFnbWVudFRhZyBKU1hUZXh0IEpTWEVzY2FwZSBKU1hTdGFydENsb3NlVGFnIEpTWENsb3NlVGFnIFByZWZpeENhc3QgQXJyb3dGdW5jdGlvbiBUeXBlUGFyYW1MaXN0IFNlcXVlbmNlRXhwcmVzc2lvbiBLZXlvZlR5cGUga2V5b2YgVW5pcXVlVHlwZSB1bmlxdWUgSW1wb3J0VHlwZSBJbmZlcnJlZFR5cGUgaW5mZXIgVHlwZU5hbWUgUGFyZW50aGVzaXplZFR5cGUgRnVuY3Rpb25TaWduYXR1cmUgUGFyYW1MaXN0IE5ld1NpZ25hdHVyZSBJbmRleGVkVHlwZSBUdXBsZVR5cGUgTGFiZWwgQXJyYXlUeXBlIFJlYWRvbmx5VHlwZSBPYmplY3RUeXBlIE1ldGhvZFR5cGUgUHJvcGVydHlUeXBlIEluZGV4U2lnbmF0dXJlIFByb3BlcnR5RGVmaW5pdGlvbiBDYWxsU2lnbmF0dXJlIFR5cGVQcmVkaWNhdGUgaXMgTmV3U2lnbmF0dXJlIG5ldyBVbmlvblR5cGUgTG9naWNPcCBJbnRlcnNlY3Rpb25UeXBlIExvZ2ljT3AgQ29uZGl0aW9uYWxUeXBlIFBhcmFtZXRlcml6ZWRUeXBlIENsYXNzRGVjbGFyYXRpb24gYWJzdHJhY3QgaW1wbGVtZW50cyB0eXBlIFZhcmlhYmxlRGVjbGFyYXRpb24gbGV0IHZhciBUeXBlQWxpYXNEZWNsYXJhdGlvbiBJbnRlcmZhY2VEZWNsYXJhdGlvbiBpbnRlcmZhY2UgRW51bURlY2xhcmF0aW9uIGVudW0gRW51bUJvZHkgTmFtZXNwYWNlRGVjbGFyYXRpb24gbmFtZXNwYWNlIG1vZHVsZSBBbWJpZW50RGVjbGFyYXRpb24gZGVjbGFyZSBHbG9iYWxEZWNsYXJhdGlvbiBnbG9iYWwgQ2xhc3NEZWNsYXJhdGlvbiBDbGFzc0JvZHkgQW1iaWVudEZ1bmN0aW9uRGVjbGFyYXRpb24gRXhwb3J0R3JvdXAgVmFyaWFibGVOYW1lIFZhcmlhYmxlTmFtZSBJbXBvcnREZWNsYXJhdGlvbiBJbXBvcnRHcm91cCBGb3JTdGF0ZW1lbnQgZm9yIEZvclNwZWMgRm9ySW5TcGVjIEZvck9mU3BlYyBvZiBXaGlsZVN0YXRlbWVudCB3aGlsZSBXaXRoU3RhdGVtZW50IHdpdGggRG9TdGF0ZW1lbnQgZG8gSWZTdGF0ZW1lbnQgaWYgZWxzZSBTd2l0Y2hTdGF0ZW1lbnQgc3dpdGNoIFN3aXRjaEJvZHkgQ2FzZUxhYmVsIGNhc2UgRGVmYXVsdExhYmVsIFRyeVN0YXRlbWVudCB0cnkgQ2F0Y2hDbGF1c2UgY2F0Y2ggRmluYWxseUNsYXVzZSBmaW5hbGx5IFJldHVyblN0YXRlbWVudCByZXR1cm4gVGhyb3dTdGF0ZW1lbnQgdGhyb3cgQnJlYWtTdGF0ZW1lbnQgYnJlYWsgQ29udGludWVTdGF0ZW1lbnQgY29udGludWUgRGVidWdnZXJTdGF0ZW1lbnQgZGVidWdnZXIgTGFiZWxlZFN0YXRlbWVudCBFeHByZXNzaW9uU3RhdGVtZW50IFNpbmdsZUV4cHJlc3Npb24gU2luZ2xlQ2xhc3NJdGVtXCIsXG4gIG1heFRlcm06IDM2NCxcbiAgY29udGV4dDogdHJhY2tOZXdsaW5lLFxuICBub2RlUHJvcHM6IFtcbiAgICBbXCJncm91cFwiLCAtMjYsNiwxNCwxNiw2MiwxOTksMjAzLDIwNiwyMDcsMjA5LDIxMiwyMTUsMjI1LDIyNywyMzMsMjM1LDIzNywyMzksMjQyLDI0OCwyNTQsMjU2LDI1OCwyNjAsMjYyLDI2NCwyNjUsXCJTdGF0ZW1lbnRcIiwtMzIsMTAsMTEsMjUsMjgsMjksMzUsNDUsNDgsNDksNTEsNTYsNjQsNzIsNzYsNzgsODAsODEsMTAzLDEwNCwxMTMsMTE0LDEzMSwxMzQsMTM2LDEzNywxMzgsMTM5LDE0MSwxNDIsMTYyLDE2MywxNjUsXCJFeHByZXNzaW9uXCIsLTIzLDI0LDI2LDMwLDM0LDM2LDM4LDE2NiwxNjgsMTcwLDE3MSwxNzMsMTc0LDE3NSwxNzcsMTc4LDE3OSwxODEsMTgyLDE4MywxOTMsMTk1LDE5NywxOTgsXCJUeXBlXCIsLTMsODQsOTYsMTAyLFwiQ2xhc3NJdGVtXCJdLFxuICAgIFtcIm9wZW5lZEJ5XCIsIDMxLFwiSW50ZXJwb2xhdGlvblN0YXJ0XCIsNTAsXCJbXCIsNTQsXCJ7XCIsNjksXCIoXCIsMTQzLFwiSlNYU3RhcnRUYWdcIiwxNTUsXCJKU1hTdGFydFRhZyBKU1hTdGFydENsb3NlVGFnXCJdLFxuICAgIFtcImNsb3NlZEJ5XCIsIDMzLFwiSW50ZXJwb2xhdGlvbkVuZFwiLDQ0LFwiXVwiLDU1LFwifVwiLDcwLFwiKVwiLDE0NCxcIkpTWFNlbGZDbG9zZUVuZFRhZyBKU1hFbmRUYWdcIiwxNjAsXCJKU1hFbmRUYWdcIl1cbiAgXSxcbiAgcHJvcFNvdXJjZXM6IFtqc0hpZ2hsaWdodF0sXG4gIHNraXBwZWROb2RlczogWzAsMyw0LDI2OF0sXG4gIHJlcGVhdE5vZGVDb3VudDogMzMsXG4gIHRva2VuRGF0YTogXCIkPnkoQ1NSIWJPWCVaWFkrZ1laLXlaWytnW10lWl1eLmNecCVacHErZ3FyL21yczNjc3Q6X3R1PlB1dkJhdndEeHd4R2d4eU12eXohIFF6eyEhW3t8ISVPfH0hJl19IU8hJU8hTyFQISdnIVAhUSExdyFRIVIjMHQhUiFbIzNUIVshXSNAVCFdIV4jQWEhXiFfI0JrIV8hYCNHUyFgIWEjSW4hYSFiI057IWIhYyQkeiFjIX0+UCF9I08kJlUjTyNQJCdgI1AjUSQsdyNRI1IkLlIjUiNTPlAjUyNUJC9gI1QjbyQwaiNvI3AkNHojcCNxJDVwI3EjciQ3USNyI3MkOF4jcyRmJVokZiRnK2ckZyNCWT5QI0JZI0JaJDloI0JaJElTPlAkSVMkSV8kOWgkSV8kSXw+UCRJfCRJfSQ8cyRJfSRKTyQ8cyRKTyRKVD5QJEpUJEpVJDloJEpVJEtWPlAkS1YkS1ckOWgkS1cmRlU+UCZGVSZGViQ5aCZGVjsnUz5QOydTOz1gQlo8JWw/SFQ+UD9IVD9IVSQ5aD9IVU8+UChuJWRfJGQmaid3cCd6IWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiZqJmhUJGQmak8hXiZjIV8jbyZjI3A7J1MmYzsnUzs9YCZ3PCVsTyZjJmomelA7PWA8JWwmYyd8J1VdJGQmaid6IWJPWSZ9WVomY1p3Jn13eCZjeCFeJn0hXiFfJ30hXyNPJn0jTyNQJmMjUCNvJn0jbyNwJ30jcDsnUyZ9OydTOz1gKGw8JWxPJn0hYihTVSd6IWJPWSd9WncnfXgjTyd9I1A7J1MnfTsnUzs9YChmPCVsTyd9IWIoaVA7PWA8JWwnfSd8KG9QOz1gPCVsJn0nWyh5XSRkJmond3BPWShyWVomY1pyKHJycyZjcyFeKHIhXiFfKXIhXyNPKHIjTyNQJmMjUCNvKHIjbyNwKXIjcDsnUyhyOydTOz1gKmE8JWxPKHJwKXdVJ3dwT1kpclpyKXJzI08pciNQOydTKXI7J1M7PWAqWjwlbE8pcnAqXlA7PWA8JWwpcidbKmRQOz1gPCVsKHIjUypuWCd3cCd6IWJPWSpnWnIqZ3JzJ31zdypnd3gpcngjTypnI1A7J1MqZzsnUzs9YCtaPCVsTypnI1MrXlA7PWA8JWwqZyhuK2RQOz1gPCVsJVooQ1MrcnEkZCZqJ3dwJ3ohYidtKDtkT1glWlhZK2dZWiZjWlsrZ1twJVpwcStncXIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3AkZiVaJGYkZytnJGcjQlklWiNCWSNCWitnI0JaJElTJVokSVMkSV8rZyRJXyRKVCVaJEpUJEpVK2ckSlUkS1YlWiRLViRLVytnJEtXJkZVJVomRlUmRlYrZyZGVjsnUyVaOydTOz1gK2E8JWw/SFQlWj9IVD9IVStnP0hVTyVaKENTLlNUJ3gjUyRkJmonbig7ZE8hXiZjIV8jbyZjI3A7J1MmYzsnUzs9YCZ3PCVsTyZjKENTLm5fJGQmaid3cCd6IWInbig7ZE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJSNgL3hgJGQmaiFsJElwJ3dwJ3ohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYDB6IWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJSNTMVZgI3EkSWQkZCZqJ3dwJ3ohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYDJYIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJSNTMmRfI3EkSWQkZCZqJ3dwJ3ohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJDJiM2xfJ3YkKG4kZCZqJ3ohYk9ZNGtZWjVxWnI0a3JzN25zdzRrd3g1cXghXjRrIV4hXzhwIV8jTzRrI08jUDVxI1AjbzRrI28jcDhwI3A7J1M0azsnUzs9YDpYPCVsTzRrKnI0cl8kZCZqJ3ohYk9ZNGtZWjVxWnI0a3JzN25zdzRrd3g1cXghXjRrIV4hXzhwIV8jTzRrI08jUDVxI1AjbzRrI28jcDhwI3A7J1M0azsnUzs9YDpYPCVsTzRrKWA1dlgkZCZqT3I1cXJzNmNzIV41cSFeIV82eSFfI281cSNvI3A2eSNwOydTNXE7J1M7PWA3aDwlbE81cSlgNmpUJF8jdCRkJmpPIV4mYyFfI28mYyNwOydTJmM7J1M7PWAmdzwlbE8mYyN0NnxUT3I2eXJzN11zOydTNnk7J1M7PWA3YjwlbE82eSN0N2JPJF8jdCN0N2VQOz1gPCVsNnkpYDdrUDs9YDwlbDVxKnI3d10kXyN0JGQmaid6IWJPWSZ9WVomY1p3Jn13eCZjeCFeJn0hXiFfJ30hXyNPJn0jTyNQJmMjUCNvJn0jbyNwJ30jcDsnUyZ9OydTOz1gKGw8JWxPJn0lVzh1Wid6IWJPWThwWVo2eVpyOHByczloc3c4cHd4Nnl4I084cCNPI1A2eSNQOydTOHA7J1M7PWA6UjwlbE84cCVXOW9VJF8jdCd6IWJPWSd9WncnfXgjTyd9I1A7J1MnfTsnUzs9YChmPCVsTyd9JVc6VVA7PWA8JWw4cCpyOltQOz1gPCVsNGsjJXw6aGckZCZqJ3dwJ3ohYk9ZJVpZWiZjWnIlWnJzJn1zdCVadHU8UHV3JVp3eChyeCFeJVohXiFfKmchXyFjJVohYyF9PFAhfSNPJVojTyNQJmMjUCNSJVojUiNTPFAjUyNUJVojVCNvPFAjbyNwKmcjcCRnJVokZzsnUzxQOydTOz1gPXk8JWxPPFAjJXw8W2kkZCZqKGEhTF4nd3AneiFiT1klWllaJmNaciVacnMmfXN0JVp0dTxQdXclWnd4KHJ4IVElWiFRIVs8UCFbIV4lWiFeIV8qZyFfIWMlWiFjIX08UCF9I08lWiNPI1AmYyNQI1IlWiNSI1M8UCNTI1QlWiNUI288UCNvI3AqZyNwJGclWiRnOydTPFA7J1M7PWA9eTwlbE88UCMlfD18UDs9YDwlbDxQKENTPmBrJGQmaid3cCd6IWIoVSFMWSd0JjtkJFcjdE9ZJVpZWiZjWnIlWnJzJn1zdCVadHU+UHV3JVp3eChyeH0lWn0hT0BUIU8hUSVaIVEhWz5QIVshXiVaIV4hXypnIV8hYyVaIWMhfT5QIX0jTyVaI08jUCZjI1AjUiVaI1IjUz5QI1MjVCVaI1Qjbz5QI28jcCpnI3AkZyVaJGc7J1M+UDsnUzs9YEJaPCVsTz5QK2RAYGskZCZqJ3dwJ3ohYiRXI3RPWSVaWVomY1pyJVpycyZ9c3QlWnR1QFR1dyVad3gocnh9JVp9IU9AVCFPIVElWiFRIVtAVCFbIV4lWiFeIV8qZyFfIWMlWiFjIX1AVCF9I08lWiNPI1AmYyNQI1IlWiNSI1NAVCNTI1QlWiNUI29AVCNvI3AqZyNwJGclWiRnOydTQFQ7J1M7PWBCVDwlbE9AVCtkQldQOz1gPCVsQFQoQ1NCXlA7PWA8JWw+UCUjU0JsYCRkJmond3AneiFiI2kkSWRPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBDbiFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiUjU0N5XyRkJmojeyRJZCd3cCd6IWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiVEZkVUYShqJTx2JGQmaid3cCd6IWJPWSVaWVomY1pyJVpycyZ9c3YlWnZ3Rll3eChyeCFeJVohXiFfKmchXyFgQ24hYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI1NGZWAkZCZqI3UkSWQnd3AneiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgQ24hYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVokMmJHcF8neSQpYCRkJmond3BPWUhvWVpJdVpySG9yc0l1c3dIb3d4S1Z4IV5IbyFeIV9MWCFfI09IbyNPI1BJdSNQI29IbyNvI3BMWCNwOydTSG87J1M7PWBNcDwlbE9IbypRSHZfJGQmaid3cE9ZSG9ZWkl1WnJIb3JzSXVzd0hvd3hLVnghXkhvIV4hX0xYIV8jT0hvI08jUEl1I1Ajb0hvI28jcExYI3A7J1NIbzsnUzs9YE1wPCVsT0hvKWBJelgkZCZqT3dJdXd4NmN4IV5JdSFeIV9KZyFfI29JdSNvI3BKZyNwOydTSXU7J1M7PWBLUDwlbE9JdSN0SmpUT3dKZ3d4N114OydTSmc7J1M7PWBKeTwlbE9KZyN0SnxQOz1gPCVsSmcpYEtTUDs9YDwlbEl1KlFLYF0kXyN0JGQmaid3cE9ZKHJZWiZjWnIocnJzJmNzIV4ociFeIV8pciFfI08ociNPI1AmYyNQI28ociNvI3ApciNwOydTKHI7J1M7PWAqYTwlbE8ociRmTF5aJ3dwT1lMWFlaSmdackxYcnNKZ3N3TFh3eE1QeCNPTFgjTyNQSmcjUDsnU0xYOydTOz1gTWo8JWxPTFgkZk1XVSRfI3Qnd3BPWSlyWnIpcnMjTylyI1A7J1MpcjsnUzs9YCpaPCVsTylyJGZNbVA7PWA8JWxMWCpRTXNQOz1gPCVsSG8oKlFOUl8haCghYiRkJmond3AneiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVohJ2whIF1fIWdNfCRkJmond3AneiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonK2ghIWliJGQmaid3cCd6IWIndSMpZCNqJElkT1klWllaJmNaciVacnMmfXN3JVp3eChyeHolWnp7ISNxeyFeJVohXiFfKmchXyFgQ24hYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI1MhI3xgJGQmaid3cCd6IWIjZyRJZE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYENuIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJi1PISVaYCRkJmond3AneiFiayYlYE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYENuIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJkNbISZoXyFWJjtsJGQmaid3cCd6IWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihDUyEncmMkZCZqJ3dwJ3ohYnknPG5PWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IU8lWiFPIVAhKH0hUCFRJVohUSFbIStnIVshXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaISdkISlXYSRkJmond3AneiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFPJVohTyFQISpdIVAhXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaISdkISpoXyFVTXQkZCZqJ3dwJ3ohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJC9sIStyZyRkJmond3AneiFibCQnfE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhWyErZyFbIV4lWiFeIV8qZyFfIWclWiFnIWghLVohaCNPJVojTyNQJmMjUCNSJVojUiNTIStnI1MjWCVaI1gjWSEtWiNZI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiQvbCEtZGckZCZqJ3dwJ3ohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnh7JVp7fCEue3x9JVp9IU8hLnshTyFRJVohUSFbITBhIVshXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyEwYSNTI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiQvbCEvVWMkZCZqJ3dwJ3ohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhWyEwYSFbIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI1IlWiNSI1MhMGEjUyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVokL2whMGxjJGQmaid3cCd6IWJsJCd8T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFbITBhIVshXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyEwYSNTI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihDUyEyU2YkZCZqJ3dwJ3ohYiNoJElkT1khM2hZWiZjWnIhM2hycyE0e3N3ITNod3ghQ314eiEzaHp7IyRzeyFQITNoIVAhUSMmWSFRIV4hM2ghXiFfIU1oIV8hYCMteCFgIWEjL18hYSF9ITNoIX0jTyMjWyNPI1AhPHcjUCNvITNoI28jcCFNaCNwOydTITNoOydTOz1gIyRtPCVsTyEzaChyITNzYiRkJmond3AneiFiIVJTT1khM2hZWiZjWnIhM2hycyE0e3N3ITNod3ghQ314IVAhM2ghUCFRIUtoIVEhXiEzaCFeIV8hTWghXyF9ITNoIX0jTyMjWyNPI1AhPHcjUCNvITNoI28jcCFNaCNwOydTITNoOydTOz1gIyRtPCVsTyEzaChRITVVYCRkJmoneiFiIVJTT1khNHtZWiZjWnchNHt3eCE2V3ghUCE0eyFQIVEhPW8hUSFeITR7IV4hXyE/ZyFfIX0hNHshfSNPIUJuI08jUCE8dyNQI28hNHsjbyNwIT9nI3A7J1MhNHs7J1M7PWAhQ3c8JWxPITR7Jm4hNl9eJGQmaiFSU09ZITZXWVomY1ohUCE2VyFQIVEhN1ohUSFeITZXIV4hXyE4ZyFfIX0hNlchfSNPITtVI08jUCE8dyNQI28hNlcjbyNwIThnI3A7J1MhNlc7J1M7PWAhPWk8JWxPITZXJm4hN2JhJGQmaiFSU08hXiZjIV8jWiZjI1ojWyE3WiNbI10mYyNdI14hN1ojXiNhJmMjYSNiITdaI2IjZyZjI2cjaCE3WiNoI2kmYyNpI2ohN1ojaiNtJmMjbSNuITdaI24jbyZjI3A7J1MmYzsnUzs9YCZ3PCVsTyZjUyE4bFghUlNPWSE4Z1ohUCE4ZyFQIVEhOVghUSF9IThnIX0jTyE5cCNPI1AhOm8jUDsnUyE4ZzsnUzs9YCE7TzwlbE8hOGdTITleVSFSUyNaI1shOVgjXSNeITlYI2EjYiE5WCNnI2ghOVgjaSNqITlYI20jbiE5WFMhOXNWT1khOXBaI08hOXAjTyNQITpZI1AjUSE4ZyNROydTITlwOydTOz1gITppPCVsTyE5cFMhOl1TT1khOXBaOydTITlwOydTOz1gITppPCVsTyE5cFMhOmxQOz1gPCVsITlwUyE6clNPWSE4Z1o7J1MhOGc7J1M7PWAhO088JWxPIThnUyE7UlA7PWA8JWwhOGcmbiE7WlskZCZqT1khO1VZWiZjWiFeITtVIV4hXyE5cCFfI08hO1UjTyNQITxQI1AjUSE2VyNRI28hO1UjbyNwITlwI3A7J1MhO1U7J1M7PWAhPHE8JWxPITtVJm4hPFVYJGQmak9ZITtVWVomY1ohXiE7VSFeIV8hOXAhXyNvITtVI28jcCE5cCNwOydTITtVOydTOz1gITxxPCVsTyE7VSZuITx0UDs9YDwlbCE7VSZuITx8WCRkJmpPWSE2V1laJmNaIV4hNlchXiFfIThnIV8jbyE2VyNvI3AhOGcjcDsnUyE2VzsnUzs9YCE9aTwlbE8hNlcmbiE9bFA7PWA8JWwhNlcoUSE9eGkkZCZqJ3ohYiFSU09ZJn1ZWiZjWncmfXd4JmN4IV4mfSFeIV8nfSFfI08mfSNPI1AmYyNQI1omfSNaI1shPW8jWyNdJn0jXSNeIT1vI14jYSZ9I2EjYiE9byNiI2cmfSNnI2ghPW8jaCNpJn0jaSNqIT1vI2ojbSZ9I20jbiE9byNuI28mfSNvI3AnfSNwOydTJn07J1M7PWAobDwlbE8mfSFmIT9uWid6IWIhUlNPWSE/Z1p3IT9nd3ghOGd4IVAhP2chUCFRIUBhIVEhfSE/ZyF9I08hQXAjTyNQITpvI1A7J1MhP2c7J1M7PWAhQmg8JWxPIT9nIWYhQGhiJ3ohYiFSU09ZJ31adyd9eCNPJ30jUCNaJ30jWiNbIUBhI1sjXSd9I10jXiFAYSNeI2EnfSNhI2IhQGEjYiNnJ30jZyNoIUBhI2gjaSd9I2kjaiFAYSNqI20nfSNtI24hQGEjbjsnUyd9OydTOz1gKGY8JWxPJ30hZiFBdVgneiFiT1khQXBadyFBcHd4ITlweCNPIUFwI08jUCE6WSNQI1EhP2cjUTsnUyFBcDsnUzs9YCFCYjwlbE8hQXAhZiFCZVA7PWA8JWwhQXAhZiFCa1A7PWA8JWwhP2coUSFCdV4kZCZqJ3ohYk9ZIUJuWVomY1p3IUJud3ghO1V4IV4hQm4hXiFfIUFwIV8jTyFCbiNPI1AhPFAjUCNRITR7I1EjbyFCbiNvI3AhQXAjcDsnUyFCbjsnUzs9YCFDcTwlbE8hQm4oUSFDdFA7PWA8JWwhQm4oUSFDelA7PWA8JWwhNHsnYCFEV2AkZCZqJ3dwIVJTT1khQ31ZWiZjWnIhQ31ycyE2V3MhUCFDfSFQIVEhRVkhUSFeIUN9IV4hXyFHUSFfIX0hQ30hfSNPIUpYI08jUCE8dyNQI28hQ30jbyNwIUdRI3A7J1MhQ307J1M7PWAhS2I8JWxPIUN9J2AhRWNpJGQmaid3cCFSU09ZKHJZWiZjWnIocnJzJmNzIV4ociFeIV8pciFfI08ociNPI1AmYyNQI1oociNaI1shRVkjWyNdKHIjXSNeIUVZI14jYShyI2EjYiFFWSNiI2cociNnI2ghRVkjaCNpKHIjaSNqIUVZI2ojbShyI20jbiFFWSNuI28ociNvI3ApciNwOydTKHI7J1M7PWAqYTwlbE8ocnQhR1haJ3dwIVJTT1khR1FaciFHUXJzIThncyFQIUdRIVAhUSFHeiFRIX0hR1EhfSNPIUlaI08jUCE6byNQOydTIUdROydTOz1gIUpSPCVsTyFHUXQhSFJiJ3dwIVJTT1kpclpyKXJzI08pciNQI1opciNaI1shR3ojWyNdKXIjXSNeIUd6I14jYSlyI2EjYiFHeiNiI2cpciNnI2ghR3ojaCNpKXIjaSNqIUd6I2ojbSlyI20jbiFHeiNuOydTKXI7J1M7PWAqWjwlbE8pcnQhSWBYJ3dwT1khSVpaciFJWnJzITlwcyNPIUlaI08jUCE6WSNQI1EhR1EjUTsnUyFJWjsnUzs9YCFJezwlbE8hSVp0IUpPUDs9YDwlbCFJWnQhSlVQOz1gPCVsIUdRJ2AhSmBeJGQmaid3cE9ZIUpYWVomY1pyIUpYcnMhO1VzIV4hSlghXiFfIUlaIV8jTyFKWCNPI1AhPFAjUCNRIUN9I1EjbyFKWCNvI3AhSVojcDsnUyFKWDsnUzs9YCFLWzwlbE8hSlgnYCFLX1A7PWA8JWwhSlgnYCFLZVA7PWA8JWwhQ30ociFLc2skZCZqJ3dwJ3ohYiFSU09ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjWiVaI1ojWyFLaCNbI10lWiNdI14hS2gjXiNhJVojYSNiIUtoI2IjZyVaI2cjaCFLaCNoI2klWiNpI2ohS2gjaiNtJVojbSNuIUtoI24jbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaI1chTXFdJ3dwJ3ohYiFSU09ZIU1oWnIhTWhycyE/Z3N3IU1od3ghR1F4IVAhTWghUCFRIU5qIVEhfSFNaCF9I08jIVUjTyNQITpvI1A7J1MhTWg7J1M7PWAjI1U8JWxPIU1oI1chTnNlJ3dwJ3ohYiFSU09ZKmdacipncnMnfXN3Kmd3eClyeCNPKmcjUCNaKmcjWiNbIU5qI1sjXSpnI10jXiFOaiNeI2EqZyNhI2IhTmojYiNnKmcjZyNoIU5qI2gjaSpnI2kjaiFOaiNqI20qZyNtI24hTmojbjsnUypnOydTOz1gK1o8JWxPKmcjVyMhXVond3AneiFiT1kjIVVaciMhVXJzIUFwc3cjIVV3eCFJWngjTyMhVSNPI1AhOlkjUCNRIU1oI1E7J1MjIVU7J1M7PWAjI088JWxPIyFVI1cjI1JQOz1gPCVsIyFVI1cjI1hQOz1gPCVsIU1oKHIjI2VgJGQmaid3cCd6IWJPWSMjW1laJmNaciMjW3JzIUJuc3cjI1t3eCFKWHghXiMjWyFeIV8jIVUhXyNPIyNbI08jUCE8UCNQI1EhM2gjUSNvIyNbI28jcCMhVSNwOydTIyNbOydTOz1gIyRnPCVsTyMjWyhyIyRqUDs9YDwlbCMjWyhyIyRwUDs9YDwlbCEzaChDUyMlUWIkZCZqJ3dwJ3ohYidvKDtkIVJTT1khM2hZWiZjWnIhM2hycyE0e3N3ITNod3ghQ314IVAhM2ghUCFRIUtoIVEhXiEzaCFeIV8hTWghXyF9ITNoIX0jTyMjWyNPI1AhPHcjUCNvITNoI28jcCFNaCNwOydTITNoOydTOz1gIyRtPCVsTyEzaChDUyMmZV8kZCZqJ3dwJ3ohYlIoO2RPWSMmWVlaJmNaciMmWXJzIydkc3cjJll3eCMqdHghXiMmWSFeIV8jLHMhXyNPIyZZI08jUCMoZiNQI28jJlkjbyNwIyxzI3A7J1MjJlk7J1M7PWAjLXI8JWxPIyZZKEJiIydtXSRkJmoneiFiUig7ZE9ZIydkWVomY1p3Iydkd3gjKGZ4IV4jJ2QhXiFfIyl3IV8jTyMnZCNPI1AjKGYjUCNvIydkI28jcCMpdyNwOydTIydkOydTOz1gIypuPCVsTyMnZChBTyMobVgkZCZqUig7ZE9ZIyhmWVomY1ohXiMoZiFeIV8jKVkhXyNvIyhmI28jcCMpWSNwOydTIyhmOydTOz1gIylxPCVsTyMoZig7ZCMpX1NSKDtkT1kjKVlaOydTIylZOydTOz1gIylrPCVsTyMpWSg7ZCMpblA7PWA8JWwjKVkoQU8jKXRQOz1gPCVsIyhmKDx2IypPVyd6IWJSKDtkT1kjKXdadyMpd3d4IylZeCNPIyl3I08jUCMpWSNQOydTIyl3OydTOz1gIypoPCVsTyMpdyg8diMqa1A7PWA8JWwjKXcoQmIjKnFQOz1gPCVsIydkKEFwIyp9XSRkJmond3BSKDtkT1kjKnRZWiZjWnIjKnRycyMoZnMhXiMqdCFeIV8jK3YhXyNPIyp0I08jUCMoZiNQI28jKnQjbyNwIyt2I3A7J1MjKnQ7J1M7PWAjLG08JWxPIyp0KDxVIyt9Vyd3cFIoO2RPWSMrdlpyIyt2cnMjKVlzI08jK3YjTyNQIylZI1A7J1MjK3Y7J1M7PWAjLGc8JWxPIyt2KDxVIyxqUDs9YDwlbCMrdihBcCMscFA7PWA8JWwjKnQoPWgjLHxZJ3dwJ3ohYlIoO2RPWSMsc1pyIyxzcnMjKXdzdyMsc3d4Iyt2eCNPIyxzI08jUCMpWSNQOydTIyxzOydTOz1gIy1sPCVsTyMscyg9aCMtb1A7PWA8JWwjLHMoQ1MjLXVQOz1gPCVsIyZZJSNXIy5WYiRkJmojeyRJZCd3cCd6IWIhUlNPWSEzaFlaJmNaciEzaHJzITR7c3chM2h3eCFDfXghUCEzaCFQIVEhS2ghUSFeITNoIV4hXyFNaCFfIX0hM2ghfSNPIyNbI08jUCE8dyNQI28hM2gjbyNwIU1oI3A7J1MhM2g7J1M7PWAjJG08JWxPITNoK2gjL2xiJFQjdCRkJmond3AneiFiIVJTT1khM2hZWiZjWnIhM2hycyE0e3N3ITNod3ghQ314IVAhM2ghUCFRIUtoIVEhXiEzaCFeIV8hTWghXyF9ITNoIX0jTyMjWyNPI1AhPHcjUCNvITNoI28jcCFNaCNwOydTITNoOydTOz1gIyRtPCVsTyEzaCQvbCMxUHAkZCZqJ3dwJ3ohYmwkJ3xPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IU8lWiFPIVAhK2chUCFRJVohUSFbIzNUIVshXiVaIV4hXypnIV8hZyVaIWchaCEtWiFoI08lWiNPI1AmYyNQI1IlWiNSI1MjM1QjUyNVJVojVSNWIzZfI1YjWCVaI1gjWSEtWiNZI2IlWiNiI2MjNVQjYyNkIzlnI2QjbCVaI2wjbSM8aSNtI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiQvbCMzYGskZCZqJ3dwJ3ohYmwkJ3xPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IU8lWiFPIVAhK2chUCFRJVohUSFbIzNUIVshXiVaIV4hXypnIV8hZyVaIWchaCEtWiFoI08lWiNPI1AmYyNQI1IlWiNSI1MjM1QjUyNYJVojWCNZIS1aI1kjYiVaI2IjYyM1VCNjI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiQvbCM1YF8kZCZqJ3dwJ3ohYmwkJ3xPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiQvbCM2aGQkZCZqJ3dwJ3ohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhUiM3diFSIVMjN3YhUyFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTIzd2I1MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJC9sIzhSZiRkJmond3AneiFibCQnfE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhUiM3diFSIVMjN3YhUyFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTIzd2I1MjYiVaI2IjYyM1VCNjI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiQvbCM5cGMkZCZqJ3dwJ3ohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhWSM6eyFZIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI1IlWiNSI1MjOnsjUyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVokL2wjO1dlJGQmaid3cCd6IWJsJCd8T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFZIzp7IVkhXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyM6eyNTI2IlWiNiI2MjNVQjYyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVokL2wjPHJnJGQmaid3cCd6IWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVsjPlohWyFeJVohXiFfKmchXyFjJVohYyFpIz5aIWkjTyVaI08jUCZjI1AjUiVaI1IjUyM+WiNTI1QlWiNUI1ojPlojWiNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVokL2wjPmZpJGQmaid3cCd6IWJsJCd8T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFbIz5aIVshXiVaIV4hXypnIV8hYyVaIWMhaSM+WiFpI08lWiNPI1AmYyNQI1IlWiNSI1MjPlojUyNUJVojVCNaIz5aI1ojYiVaI2IjYyM1VCNjI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiVHaCNAYl8hYSRiJGQmaiN5JTxmJ3dwJ3ohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKVsjQWxfXmwkZCZqJ3dwJ3ohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKENTI0J6Xid9ISp2IWUnLnInd3AneiFiJFUpZChuU09ZKmdacipncnMnfXN3Kmd3eClyeCFQKmchUCFRI0N2IVEhXipnIV4hXyNEbCFfIWAjRl4hYCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcobiNEUFgkZiZqJ3dwJ3ohYk9ZKmdacipncnMnfXN3Kmd3eClyeCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmckS2gjRHVaI2skSWQnd3AneiFiT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4IV8qZyFfIWAjRWghYCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmckS2gjRXFYI3skSWQnd3AneiFiT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4I08qZyNQOydTKmc7J1M7PWArWjwlbE8qZyRLaCNGZ1gjbCRJZCd3cCd6IWJPWSpnWnIqZ3JzJ31zdypnd3gpcngjTypnI1A7J1MqZzsnUzs9YCtaPCVsTypnJUdoI0dfYSNYJT94JGQmaid3cCd6IWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWAweiFgIWEjSGQhYSNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI1cjSG9fI2QkSWgkZCZqJ3dwJ3ohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJUdoI0l9YWRCZiNsJElkJGEjfCRkJmond3AneiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgI0tTIWAhYSNMXiFhI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiUjUyNLX18jbCRJZCRkJmond3AneiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI1MjTGlhI2skSWQkZCZqJ3dwJ3ohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYENuIWAhYSNNbiFhI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiUjUyNNeWAjayRJZCRkJmond3AneiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgQ24hYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonK2gkIFdjKGIkSXAkZCZqJ3dwJ3ohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghTyVaIU8hUCQhYyFQIV4lWiFeIV8qZyFfIWElWiFhIWIkI20hYiNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonK2AkIW5feicjcCRkJmond3AneiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI1MkI3hgJGQmaiN2JElkJ3dwJ3ohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYENuIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaIyZeJCVWXyF4IUxuJGQmaid3cCd6IWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihAXiQmYV98KDhuJGQmaid3cCd6IWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihuJCdlWiRkJmpPIV4kKFchXiFfJChuIV8jaSQoVyNpI2okKHMjaiNsJChXI2wjbSQqZiNtI28kKFcjbyNwJChuI3A7J1MkKFc7J1M7PWAkLHE8JWxPJChXKG4kKF9UWyNTJGQmak8hXiZjIV8jbyZjI3A7J1MmYzsnUzs9YCZ3PCVsTyZjI1MkKHNPWyNTKG4kKHhbJGQmak8hUSZjIVEhWyQpbiFbIV4mYyFfIWMmYyFjIWkkKW4haSNUJmMjVCNaJCluI1ojbyZjI28jcCQsVSNwOydTJmM7J1M7PWAmdzwlbE8mYyhuJClzWiRkJmpPIVEmYyFRIVskKmYhWyFeJmMhXyFjJmMhYyFpJCpmIWkjVCZjI1QjWiQqZiNaI28mYyNwOydTJmM7J1M7PWAmdzwlbE8mYyhuJCprWiRkJmpPIVEmYyFRIVskK14hWyFeJmMhXyFjJmMhYyFpJCteIWkjVCZjI1QjWiQrXiNaI28mYyNwOydTJmM7J1M7PWAmdzwlbE8mYyhuJCtjWiRkJmpPIVEmYyFRIVskKFchWyFeJmMhXyFjJmMhYyFpJChXIWkjVCZjI1QjWiQoVyNaI28mYyNwOydTJmM7J1M7PWAmdzwlbE8mYyNTJCxYUiFRIVskLGIhYyFpJCxiI1QjWiQsYiNTJCxlUyFRIVskLGIhYyFpJCxiI1QjWiQsYiNxI3IkKG4obiQsdFA7PWA8JWwkKFchJ2wkLVNfIVNNfCRkJmond3AneiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI1MkLl5gI3MkSWQkZCZqJ3dwJ3ohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYENuIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJix2JC9rXyRkJmond3AneiFiKFImJVdPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihDUyQweWskZCZqJ3dwJ3ohYihVIUxZJ3QmO2QkWSN0T1klWllaJmNaciVacnMmfXN0JVp0dSQwanV3JVp3eChyeH0lWn0hTyQybiFPIVElWiFRIVskMGohWyFeJVohXiFfKmchXyFjJVohYyF9JDBqIX0jTyVaI08jUCZjI1AjUiVaI1IjUyQwaiNTI1QlWiNUI28kMGojbyNwKmcjcCRnJVokZzsnUyQwajsnUzs9YCQ0dDwlbE8kMGorZCQyeWskZCZqJ3dwJ3ohYiRZI3RPWSVaWVomY1pyJVpycyZ9c3QlWnR1JDJudXclWnd4KHJ4fSVafSFPJDJuIU8hUSVaIVEhWyQybiFbIV4lWiFeIV8qZyFfIWMlWiFjIX0kMm4hfSNPJVojTyNQJmMjUCNSJVojUiNTJDJuI1MjVCVaI1QjbyQybiNvI3AqZyNwJGclWiRnOydTJDJuOydTOz1gJDRuPCVsTyQybitkJDRxUDs9YDwlbCQybihDUyQ0d1A7PWA8JWwkMGohNXAkNVRYIVghM2wnd3AneiFiT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4I08qZyNQOydTKmc7J1M7PWArWjwlbE8qZyVEZiQ1e2EoaSU8diRkJmond3AneiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgQ24hYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcCNxJCNtI3E7J1MlWjsnUzs9YCthPCVsTyVaJSNgJDdfXyFXJElgb2AkZCZqJ3dwJ3ohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKHIkOGlfIW1TJGQmaid3cCd6IWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihDUyQ5eXwkZCZqJ3dwJ3ohYidtKDtkKFUhTFkndCY7ZCRXI3RPWCVaWFkrZ1laJmNaWytnW3AlWnBxK2dxciVacnMmfXN0JVp0dT5QdXclWnd4KHJ4fSVafSFPQFQhTyFRJVohUSFbPlAhWyFeJVohXiFfKmchXyFjJVohYyF9PlAhfSNPJVojTyNQJmMjUCNSJVojUiNTPlAjUyNUJVojVCNvPlAjbyNwKmcjcCRmJVokZiRnK2ckZyNCWT5QI0JZI0JaJDloI0JaJElTPlAkSVMkSV8kOWgkSV8kSlQ+UCRKVCRKVSQ5aCRKVSRLVj5QJEtWJEtXJDloJEtXJkZVPlAmRlUmRlYkOWgmRlY7J1M+UDsnUzs9YEJaPCVsP0hUPlA/SFQ/SFUkOWg/SFVPPlAoQ1MkPVVrJGQmaid3cCd6IWInbig7ZChVIUxZJ3QmO2QkVyN0T1klWllaJmNaciVacnMmfXN0JVp0dT5QdXclWnd4KHJ4fSVafSFPQFQhTyFRJVohUSFbPlAhWyFeJVohXiFfKmchXyFjJVohYyF9PlAhfSNPJVojTyNQJmMjUCNSJVojUiNTPlAjUyNUJVojVCNvPlAjbyNwKmcjcCRnJVokZzsnUz5QOydTOz1gQlo8JWxPPlBcIixcbiAgdG9rZW5pemVyczogW25vU2VtaWNvbG9uLCBpbmNkZWNUb2tlbiwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIGluc2VydFNlbWljb2xvbiwgbmV3IExvY2FsVG9rZW5Hcm91cChcIiRTflJSdHVbI08jUGcjUyNUI3x+X1AjbyNwYn5nT3F+fmpWTyNpIVAjaSNqIVUjaiNsIVAjbCNtIXEjbTsnUyFQOydTOz1gI3Y8JWxPIVB+IVVPIU9+fiFYUyFRIVshZSFjIWkhZSNUI1ohZSNvI3AjWn4haFIhUSFbIXEhYyFpIXEjVCNaIXF+IXRSIVEhWyF9IWMhaSF9I1QjWiF9fiNRUiFRIVshUCFjIWkhUCNUI1ohUH4jXlIhUSFbI2chYyFpI2cjVCNaI2d+I2pTIVEhWyNnIWMhaSNnI1QjWiNnI3EjciFQfiN5UDs9YDwlbCFQfiRSTyhUfn5cIiwgMTQxLCAzMjYpLCBuZXcgTG9jYWxUb2tlbkdyb3VwKFwian5SUVlaWHp7Xn5eTydxfn5hUCFQIVFkfmlPJ3J+flwiLCAyNSwgMzA4KV0sXG4gIHRvcFJ1bGVzOiB7XCJTY3JpcHRcIjpbMCw1XSxcIlNpbmdsZUV4cHJlc3Npb25cIjpbMSwyNjZdLFwiU2luZ2xlQ2xhc3NJdGVtXCI6WzIsMjY3XX0sXG4gIGRpYWxlY3RzOiB7anN4OiAxMjY4NiwgdHM6IDEyNjg4fSxcbiAgZHluYW1pY1ByZWNlZGVuY2VzOiB7XCI3NlwiOjEsXCI3OFwiOjEsXCIxNjNcIjoxLFwiMTkxXCI6MX0sXG4gIHNwZWNpYWxpemVkOiBbe3Rlcm06IDMxMiwgZ2V0OiB2YWx1ZSA9PiBzcGVjX2lkZW50aWZpZXJbdmFsdWVdIHx8IC0xfSx7dGVybTogMzI4LCBnZXQ6IHZhbHVlID0+IHNwZWNfd29yZFt2YWx1ZV0gfHwgLTF9LHt0ZXJtOiA2NywgZ2V0OiB2YWx1ZSA9PiBzcGVjX0xlc3NUaGFuW3ZhbHVlXSB8fCAtMX1dLFxuICB0b2tlblByZWM6IDEyNzEyXG59KTtcblxuZXhwb3J0IHsgcGFyc2VyIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/javascript/dist/index.es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/lr/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@lezer/lr/dist/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContextTracker: () => (/* binding */ ContextTracker),\n/* harmony export */   ExternalTokenizer: () => (/* binding */ ExternalTokenizer),\n/* harmony export */   InputStream: () => (/* binding */ InputStream),\n/* harmony export */   LRParser: () => (/* binding */ LRParser),\n/* harmony export */   LocalTokenGroup: () => (/* binding */ LocalTokenGroup),\n/* harmony export */   Stack: () => (/* binding */ Stack)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\n\n/// A parse stack. These are used internally by the parser to track\n/// parsing progress. They also provide some properties and methods\n/// that external code such as a tokenizer can use to get information\n/// about the parse state.\nclass Stack {\n    /// @internal\n    constructor(\n    /// The parse that this stack is part of @internal\n    p, \n    /// Holds state, input pos, buffer index triplets for all but the\n    /// top state @internal\n    stack, \n    /// The current parse state @internal\n    state, \n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /// @internal\n    reducePos, \n    /// The input position up to which this stack has parsed.\n    pos, \n    /// The dynamic score of the stack, including dynamic precedence\n    /// and error-recovery penalties\n    /// @internal\n    score, \n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /// @internal\n    buffer, \n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /// @internal\n    bufferBase, \n    /// @internal\n    curContext, \n    /// @internal\n    lookAhead = 0, \n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /// @internal\n    parent) {\n        this.p = p;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.score = score;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.curContext = curContext;\n        this.lookAhead = lookAhead;\n        this.parent = parent;\n    }\n    /// @internal\n    toString() {\n        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n    }\n    // Start an empty stack\n    /// @internal\n    static start(p, state, pos = 0) {\n        let cx = p.parser.context;\n        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);\n    }\n    /// The stack's current [context](#lr.ContextTracker) value, if\n    /// any. Its type will depend on the context tracker's type\n    /// parameter, or it will be `null` if there is no context\n    /// tracker.\n    get context() { return this.curContext ? this.curContext.context : null; }\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /// @internal\n    pushState(state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    }\n    // Apply a reduce action\n    /// @internal\n    reduce(action) {\n        var _a;\n        let depth = action >> 19 /* Action.ReduceDepthShift */, type = action & 65535 /* Action.ValueMask */;\n        let { parser } = this.p;\n        let dPrec = parser.dynamicPrecedence(type);\n        if (dPrec)\n            this.score += dPrec;\n        if (depth == 0) {\n            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n            // Zero-depth reductions are a special caseâ€”they add stuff to\n            // the stack without popping anything off.\n            if (type < parser.minRepeatTerm)\n                this.storeNode(type, this.reducePos, this.reducePos, 4, true);\n            this.reduceContext(type, this.reducePos);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* Action.StayFlag */ ? 6 : 0);\n        let start = base ? this.stack[base - 2] : this.p.ranges[0].from, size = this.reducePos - start;\n        // This is a kludge to try and detect overly deep left-associative\n        // trees, which will not increase the parse stack depth and thus\n        // won't be caught by the regular stack-depth limit check.\n        if (size >= 2000 /* Recover.MinBigReduction */ && !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {\n            if (start == this.p.lastBigReductionStart) {\n                this.p.bigReductionCount++;\n                this.p.lastBigReductionSize = size;\n            }\n            else if (this.p.lastBigReductionSize < size) {\n                this.p.bigReductionCount = 1;\n                this.p.lastBigReductionStart = start;\n                this.p.lastBigReductionSize = size;\n            }\n        }\n        let bufferBase = base ? this.stack[base - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;\n        // Store normal terms or `R -> R R` repeat reductions\n        if (type < parser.minRepeatTerm || (action & 131072 /* Action.RepeatFlag */)) {\n            let pos = parser.stateFlag(this.state, 1 /* StateFlag.Skipped */) ? this.pos : this.reducePos;\n            this.storeNode(type, start, pos, count + 4, true);\n        }\n        if (action & 262144 /* Action.StayFlag */) {\n            this.state = this.stack[base];\n        }\n        else {\n            let baseStateID = this.stack[base - 3];\n            this.state = parser.getGoto(baseStateID, type, true);\n        }\n        while (this.stack.length > base)\n            this.stack.pop();\n        this.reduceContext(type, start);\n    }\n    // Shift a value into the buffer\n    /// @internal\n    storeNode(term, start, end, size = 4, isReduce = false) {\n        if (term == 0 /* Term.Err */ &&\n            (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {\n            // Try to omit/merge adjacent error nodes\n            let cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 0 /* Term.Err */ && cur.buffer[top - 1] > -1) {\n                if (start == end)\n                    return;\n                if (cur.buffer[top - 2] >= start) {\n                    cur.buffer[top - 2] = end;\n                    return;\n                }\n            }\n        }\n        if (!isReduce || this.pos == end) { // Simple case, just append\n            this.buffer.push(term, start, end, size);\n        }\n        else { // There may be skipped nodes that have to be moved forward\n            let index = this.buffer.length;\n            if (index > 0 && this.buffer[index - 4] != 0 /* Term.Err */)\n                while (index > 0 && this.buffer[index - 2] > end) {\n                    // Move this record forward\n                    this.buffer[index] = this.buffer[index - 4];\n                    this.buffer[index + 1] = this.buffer[index - 3];\n                    this.buffer[index + 2] = this.buffer[index - 2];\n                    this.buffer[index + 3] = this.buffer[index - 1];\n                    index -= 4;\n                    if (size > 4)\n                        size -= 4;\n                }\n            this.buffer[index] = term;\n            this.buffer[index + 1] = start;\n            this.buffer[index + 2] = end;\n            this.buffer[index + 3] = size;\n        }\n    }\n    // Apply a shift action\n    /// @internal\n    shift(action, next, nextEnd) {\n        let start = this.pos;\n        if (action & 131072 /* Action.GotoFlag */) {\n            this.pushState(action & 65535 /* Action.ValueMask */, this.pos);\n        }\n        else if ((action & 262144 /* Action.StayFlag */) == 0) { // Regular shift\n            let nextState = action, { parser } = this.p;\n            if (nextEnd > this.pos || next <= parser.maxNode) {\n                this.pos = nextEnd;\n                if (!parser.stateFlag(nextState, 1 /* StateFlag.Skipped */))\n                    this.reducePos = nextEnd;\n            }\n            this.pushState(nextState, start);\n            this.shiftContext(next, start);\n            if (next <= parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n        }\n        else { // Shift-and-stay, which means this is a skipped token\n            this.pos = nextEnd;\n            this.shiftContext(next, start);\n            if (next <= this.p.parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n        }\n    }\n    // Apply an action\n    /// @internal\n    apply(action, next, nextEnd) {\n        if (action & 65536 /* Action.ReduceFlag */)\n            this.reduce(action);\n        else\n            this.shift(action, next, nextEnd);\n    }\n    // Add a prebuilt (reused) node into the buffer.\n    /// @internal\n    useNode(value, next) {\n        let index = this.p.reused.length - 1;\n        if (index < 0 || this.p.reused[index] != value) {\n            this.p.reused.push(value);\n            index++;\n        }\n        let start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));\n    }\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /// @internal\n    split() {\n        let parent = this;\n        let off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)\n            off -= 4;\n        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while (parent && base == parent.bufferBase)\n            parent = parent.parent;\n        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);\n    }\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /// @internal\n    recoverByDelete(next, nextEnd) {\n        let isNode = next <= this.p.parser.maxNode;\n        if (isNode)\n            this.storeNode(next, this.pos, nextEnd, 4);\n        this.storeNode(0 /* Term.Err */, this.pos, nextEnd, isNode ? 8 : 4);\n        this.pos = this.reducePos = nextEnd;\n        this.score -= 190 /* Recover.Delete */;\n    }\n    /// Check if the given term would be able to be shifted (optionally\n    /// after some reductions) on this stack. This can be useful for\n    /// external tokenizers that want to make sure they only provide a\n    /// given token when it applies.\n    canShift(term) {\n        for (let sim = new SimulatedStack(this);;) {\n            let action = this.p.parser.stateSlot(sim.state, 4 /* ParseState.DefaultReduce */) || this.p.parser.hasAction(sim.state, term);\n            if (action == 0)\n                return false;\n            if ((action & 65536 /* Action.ReduceFlag */) == 0)\n                return true;\n            sim.reduce(action);\n        }\n    }\n    // Apply up to Recover.MaxNext recovery actions that conceptually\n    // inserts some missing token or rule.\n    /// @internal\n    recoverByInsert(next) {\n        if (this.stack.length >= 300 /* Recover.MaxInsertStackDepth */)\n            return [];\n        let nextStates = this.p.parser.nextStates(this.state);\n        if (nextStates.length > 4 /* Recover.MaxNext */ << 1 || this.stack.length >= 120 /* Recover.DampenInsertStackDepth */) {\n            let best = [];\n            for (let i = 0, s; i < nextStates.length; i += 2) {\n                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))\n                    best.push(nextStates[i], s);\n            }\n            if (this.stack.length < 120 /* Recover.DampenInsertStackDepth */)\n                for (let i = 0; best.length < 4 /* Recover.MaxNext */ << 1 && i < nextStates.length; i += 2) {\n                    let s = nextStates[i + 1];\n                    if (!best.some((v, i) => (i & 1) && v == s))\n                        best.push(nextStates[i], s);\n                }\n            nextStates = best;\n        }\n        let result = [];\n        for (let i = 0; i < nextStates.length && result.length < 4 /* Recover.MaxNext */; i += 2) {\n            let s = nextStates[i + 1];\n            if (s == this.state)\n                continue;\n            let stack = this.split();\n            stack.pushState(s, this.pos);\n            stack.storeNode(0 /* Term.Err */, stack.pos, stack.pos, 4, true);\n            stack.shiftContext(nextStates[i], this.pos);\n            stack.score -= 200 /* Recover.Insert */;\n            result.push(stack);\n        }\n        return result;\n    }\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /// @internal\n    forceReduce() {\n        let { parser } = this.p;\n        let reduce = parser.stateSlot(this.state, 5 /* ParseState.ForcedReduce */);\n        if ((reduce & 65536 /* Action.ReduceFlag */) == 0)\n            return false;\n        if (!parser.validAction(this.state, reduce)) {\n            let depth = reduce >> 19 /* Action.ReduceDepthShift */, term = reduce & 65535 /* Action.ValueMask */;\n            let target = this.stack.length - depth * 3;\n            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0) {\n                let backup = this.findForcedReduction();\n                if (backup == null)\n                    return false;\n                reduce = backup;\n            }\n            this.storeNode(0 /* Term.Err */, this.reducePos, this.reducePos, 4, true);\n            this.score -= 100 /* Recover.Reduce */;\n        }\n        this.reducePos = this.pos;\n        this.reduce(reduce);\n        return true;\n    }\n    /// Try to scan through the automaton to find some kind of reduction\n    /// that can be applied. Used when the regular ForcedReduce field\n    /// isn't a valid action. @internal\n    findForcedReduction() {\n        let { parser } = this.p, seen = [];\n        let explore = (state, depth) => {\n            if (seen.includes(state))\n                return;\n            seen.push(state);\n            return parser.allActions(state, (action) => {\n                if (action & (262144 /* Action.StayFlag */ | 131072 /* Action.GotoFlag */)) ;\n                else if (action & 65536 /* Action.ReduceFlag */) {\n                    let rDepth = (action >> 19 /* Action.ReduceDepthShift */) - depth;\n                    if (rDepth > 1) {\n                        let term = action & 65535 /* Action.ValueMask */, target = this.stack.length - rDepth * 3;\n                        if (target >= 0 && parser.getGoto(this.stack[target], term, false) >= 0)\n                            return (rDepth << 19 /* Action.ReduceDepthShift */) | 65536 /* Action.ReduceFlag */ | term;\n                    }\n                }\n                else {\n                    let found = explore(action, depth + 1);\n                    if (found != null)\n                        return found;\n                }\n            });\n        };\n        return explore(this.state, 0);\n    }\n    /// @internal\n    forceAll() {\n        while (!this.p.parser.stateFlag(this.state, 2 /* StateFlag.Accepting */)) {\n            if (!this.forceReduce()) {\n                this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n                break;\n            }\n        }\n        return this;\n    }\n    /// Check whether this state has no further actions (assumed to be a direct descendant of the\n    /// top state, since any other states must be able to continue\n    /// somehow). @internal\n    get deadEnd() {\n        if (this.stack.length != 3)\n            return false;\n        let { parser } = this.p;\n        return parser.data[parser.stateSlot(this.state, 1 /* ParseState.Actions */)] == 65535 /* Seq.End */ &&\n            !parser.stateSlot(this.state, 4 /* ParseState.DefaultReduce */);\n    }\n    /// Restart the stack (put it back in its start state). Only safe\n    /// when this.stack.length == 3 (state is directly below the top\n    /// state). @internal\n    restart() {\n        this.state = this.stack[0];\n        this.stack.length = 0;\n    }\n    /// @internal\n    sameState(other) {\n        if (this.state != other.state || this.stack.length != other.stack.length)\n            return false;\n        for (let i = 0; i < this.stack.length; i += 3)\n            if (this.stack[i] != other.stack[i])\n                return false;\n        return true;\n    }\n    /// Get the parser used by this stack.\n    get parser() { return this.p.parser; }\n    /// Test whether a given dialect (by numeric ID, as exported from\n    /// the terms file) is enabled.\n    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }\n    shiftContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    reduceContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    /// @internal\n    emitContext() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -3)\n            this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);\n    }\n    /// @internal\n    emitLookAhead() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -4)\n            this.buffer.push(this.lookAhead, this.pos, this.pos, -4);\n    }\n    updateContext(context) {\n        if (context != this.curContext.context) {\n            let newCx = new StackContext(this.curContext.tracker, context);\n            if (newCx.hash != this.curContext.hash)\n                this.emitContext();\n            this.curContext = newCx;\n        }\n    }\n    /// @internal\n    setLookAhead(lookAhead) {\n        if (lookAhead > this.lookAhead) {\n            this.emitLookAhead();\n            this.lookAhead = lookAhead;\n        }\n    }\n    /// @internal\n    close() {\n        if (this.curContext && this.curContext.tracker.strict)\n            this.emitContext();\n        if (this.lookAhead > 0)\n            this.emitLookAhead();\n    }\n}\nclass StackContext {\n    constructor(tracker, context) {\n        this.tracker = tracker;\n        this.context = context;\n        this.hash = tracker.strict ? tracker.hash(context) : 0;\n    }\n}\nvar Recover;\n(function (Recover) {\n    Recover[Recover[\"Insert\"] = 200] = \"Insert\";\n    Recover[Recover[\"Delete\"] = 190] = \"Delete\";\n    Recover[Recover[\"Reduce\"] = 100] = \"Reduce\";\n    Recover[Recover[\"MaxNext\"] = 4] = \"MaxNext\";\n    Recover[Recover[\"MaxInsertStackDepth\"] = 300] = \"MaxInsertStackDepth\";\n    Recover[Recover[\"DampenInsertStackDepth\"] = 120] = \"DampenInsertStackDepth\";\n    Recover[Recover[\"MinBigReduction\"] = 2000] = \"MinBigReduction\";\n})(Recover || (Recover = {}));\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n    constructor(start) {\n        this.start = start;\n        this.state = start.state;\n        this.stack = start.stack;\n        this.base = this.stack.length;\n    }\n    reduce(action) {\n        let term = action & 65535 /* Action.ValueMask */, depth = action >> 19 /* Action.ReduceDepthShift */;\n        if (depth == 0) {\n            if (this.stack == this.start.stack)\n                this.stack = this.stack.slice();\n            this.stack.push(this.state, 0, 0);\n            this.base += 3;\n        }\n        else {\n            this.base -= (depth - 1) * 3;\n        }\n        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);\n        this.state = goto;\n    }\n}\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor {\n    constructor(stack, pos, index) {\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    static create(stack, pos = stack.bufferBase + stack.buffer.length) {\n        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);\n    }\n    maybeNext() {\n        let next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    next() {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    fork() {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    }\n}\n\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type = Uint16Array) {\n    if (typeof input != \"string\")\n        return input;\n    let array = null;\n    for (let pos = 0, out = 0; pos < input.length;) {\n        let value = 0;\n        for (;;) {\n            let next = input.charCodeAt(pos++), stop = false;\n            if (next == 126 /* Encode.BigValCode */) {\n                value = 65535 /* Encode.BigVal */;\n                break;\n            }\n            if (next >= 92 /* Encode.Gap2 */)\n                next--;\n            if (next >= 34 /* Encode.Gap1 */)\n                next--;\n            let digit = next - 32 /* Encode.Start */;\n            if (digit >= 46 /* Encode.Base */) {\n                digit -= 46 /* Encode.Base */;\n                stop = true;\n            }\n            value += digit;\n            if (stop)\n                break;\n            value *= 46 /* Encode.Base */;\n        }\n        if (array)\n            array[out++] = value;\n        else\n            array = new Type(value);\n    }\n    return array;\n}\n\nclass CachedToken {\n    constructor() {\n        this.start = -1;\n        this.value = -1;\n        this.end = -1;\n        this.extended = -1;\n        this.lookAhead = 0;\n        this.mask = 0;\n        this.context = 0;\n    }\n}\nconst nullToken = new CachedToken;\n/// [Tokenizers](#lr.ExternalTokenizer) interact with the input\n/// through this interface. It presents the input as a stream of\n/// characters, tracking lookahead and hiding the complexity of\n/// [ranges](#common.Parser.parse^ranges) from tokenizer code.\nclass InputStream {\n    /// @internal\n    constructor(\n    /// @internal\n    input, \n    /// @internal\n    ranges) {\n        this.input = input;\n        this.ranges = ranges;\n        /// @internal\n        this.chunk = \"\";\n        /// @internal\n        this.chunkOff = 0;\n        /// Backup chunk\n        this.chunk2 = \"\";\n        this.chunk2Pos = 0;\n        /// The character code of the next code unit in the input, or -1\n        /// when the stream is at the end of the input.\n        this.next = -1;\n        /// @internal\n        this.token = nullToken;\n        this.rangeIndex = 0;\n        this.pos = this.chunkPos = ranges[0].from;\n        this.range = ranges[0];\n        this.end = ranges[ranges.length - 1].to;\n        this.readNext();\n    }\n    /// @internal\n    resolveOffset(offset, assoc) {\n        let range = this.range, index = this.rangeIndex;\n        let pos = this.pos + offset;\n        while (pos < range.from) {\n            if (!index)\n                return null;\n            let next = this.ranges[--index];\n            pos -= range.from - next.to;\n            range = next;\n        }\n        while (assoc < 0 ? pos > range.to : pos >= range.to) {\n            if (index == this.ranges.length - 1)\n                return null;\n            let next = this.ranges[++index];\n            pos += next.from - range.to;\n            range = next;\n        }\n        return pos;\n    }\n    /// @internal\n    clipPos(pos) {\n        if (pos >= this.range.from && pos < this.range.to)\n            return pos;\n        for (let range of this.ranges)\n            if (range.to > pos)\n                return Math.max(pos, range.from);\n        return this.end;\n    }\n    /// Look at a code unit near the stream position. `.peek(0)` equals\n    /// `.next`, `.peek(-1)` gives you the previous character, and so\n    /// on.\n    ///\n    /// Note that looking around during tokenizing creates dependencies\n    /// on potentially far-away content, which may reduce the\n    /// effectiveness incremental parsingâ€”when looking forwardâ€”or even\n    /// cause invalid reparses when looking backward more than 25 code\n    /// units, since the library does not track lookbehind.\n    peek(offset) {\n        let idx = this.chunkOff + offset, pos, result;\n        if (idx >= 0 && idx < this.chunk.length) {\n            pos = this.pos + offset;\n            result = this.chunk.charCodeAt(idx);\n        }\n        else {\n            let resolved = this.resolveOffset(offset, 1);\n            if (resolved == null)\n                return -1;\n            pos = resolved;\n            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {\n                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);\n            }\n            else {\n                let i = this.rangeIndex, range = this.range;\n                while (range.to <= pos)\n                    range = this.ranges[++i];\n                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);\n                if (pos + this.chunk2.length > range.to)\n                    this.chunk2 = this.chunk2.slice(0, range.to - pos);\n                result = this.chunk2.charCodeAt(0);\n            }\n        }\n        if (pos >= this.token.lookAhead)\n            this.token.lookAhead = pos + 1;\n        return result;\n    }\n    /// Accept a token. By default, the end of the token is set to the\n    /// current stream position, but you can pass an offset (relative to\n    /// the stream position) to change that.\n    acceptToken(token, endOffset = 0) {\n        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;\n        if (end == null || end < this.token.start)\n            throw new RangeError(\"Token end out of bounds\");\n        this.token.value = token;\n        this.token.end = end;\n    }\n    getChunk() {\n        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {\n            let { chunk, chunkPos } = this;\n            this.chunk = this.chunk2;\n            this.chunkPos = this.chunk2Pos;\n            this.chunk2 = chunk;\n            this.chunk2Pos = chunkPos;\n            this.chunkOff = this.pos - this.chunkPos;\n        }\n        else {\n            this.chunk2 = this.chunk;\n            this.chunk2Pos = this.chunkPos;\n            let nextChunk = this.input.chunk(this.pos);\n            let end = this.pos + nextChunk.length;\n            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;\n            this.chunkPos = this.pos;\n            this.chunkOff = 0;\n        }\n    }\n    readNext() {\n        if (this.chunkOff >= this.chunk.length) {\n            this.getChunk();\n            if (this.chunkOff == this.chunk.length)\n                return this.next = -1;\n        }\n        return this.next = this.chunk.charCodeAt(this.chunkOff);\n    }\n    /// Move the stream forward N (defaults to 1) code units. Returns\n    /// the new value of [`next`](#lr.InputStream.next).\n    advance(n = 1) {\n        this.chunkOff += n;\n        while (this.pos + n >= this.range.to) {\n            if (this.rangeIndex == this.ranges.length - 1)\n                return this.setDone();\n            n -= this.range.to - this.pos;\n            this.range = this.ranges[++this.rangeIndex];\n            this.pos = this.range.from;\n        }\n        this.pos += n;\n        if (this.pos >= this.token.lookAhead)\n            this.token.lookAhead = this.pos + 1;\n        return this.readNext();\n    }\n    setDone() {\n        this.pos = this.chunkPos = this.end;\n        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];\n        this.chunk = \"\";\n        return this.next = -1;\n    }\n    /// @internal\n    reset(pos, token) {\n        if (token) {\n            this.token = token;\n            token.start = pos;\n            token.lookAhead = pos + 1;\n            token.value = token.extended = -1;\n        }\n        else {\n            this.token = nullToken;\n        }\n        if (this.pos != pos) {\n            this.pos = pos;\n            if (pos == this.end) {\n                this.setDone();\n                return this;\n            }\n            while (pos < this.range.from)\n                this.range = this.ranges[--this.rangeIndex];\n            while (pos >= this.range.to)\n                this.range = this.ranges[++this.rangeIndex];\n            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {\n                this.chunkOff = pos - this.chunkPos;\n            }\n            else {\n                this.chunk = \"\";\n                this.chunkOff = 0;\n            }\n            this.readNext();\n        }\n        return this;\n    }\n    /// @internal\n    read(from, to) {\n        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)\n            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);\n        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)\n            return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);\n        if (from >= this.range.from && to <= this.range.to)\n            return this.input.read(from, to);\n        let result = \"\";\n        for (let r of this.ranges) {\n            if (r.from >= to)\n                break;\n            if (r.to > from)\n                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));\n        }\n        return result;\n    }\n}\n/// @internal\nclass TokenGroup {\n    constructor(data, id) {\n        this.data = data;\n        this.id = id;\n    }\n    token(input, stack) {\n        let { parser } = stack.p;\n        readToken(this.data, input, stack, this.id, parser.data, parser.tokenPrecTable);\n    }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/// @hide\nclass LocalTokenGroup {\n    constructor(data, precTable, elseToken) {\n        this.precTable = precTable;\n        this.elseToken = elseToken;\n        this.data = typeof data == \"string\" ? decodeArray(data) : data;\n    }\n    token(input, stack) {\n        let start = input.pos, skipped = 0;\n        for (;;) {\n            let nextPos = input.resolveOffset(1, -1);\n            readToken(this.data, input, stack, 0, this.data, this.precTable);\n            if (input.token.value > -1)\n                break;\n            if (this.elseToken == null)\n                return;\n            if (nextPos == null)\n                break;\n            input.reset(nextPos, input.token);\n            skipped++;\n        }\n        if (skipped) {\n            input.reset(start, input.token);\n            input.acceptToken(this.elseToken, skipped);\n        }\n    }\n}\nLocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/// `@external tokens` declarations in the grammar should resolve to\n/// an instance of this class.\nclass ExternalTokenizer {\n    /// Create a tokenizer. The first argument is the function that,\n    /// given an input stream, scans for the types of tokens it\n    /// recognizes at the stream's position, and calls\n    /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds\n    /// one.\n    constructor(\n    /// @internal\n    token, options = {}) {\n        this.token = token;\n        this.contextual = !!options.contextual;\n        this.fallback = !!options.fallback;\n        this.extend = !!options.extend;\n    }\n}\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `input.token` when it matches a token.\nfunction readToken(data, input, stack, group, precTable, precOffset) {\n    let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;\n    scan: for (;;) {\n        if ((groupMask & data[state]) == 0)\n            break;\n        let accEnd = data[state + 1];\n        // Check whether this state can lead to a token in the current group\n        // Accept tokens in this state, possibly overwriting\n        // lower-precedence / shorter tokens\n        for (let i = state + 3; i < accEnd; i += 2)\n            if ((data[i + 1] & groupMask) > 0) {\n                let term = data[i];\n                if (dialect.allows(term) &&\n                    (input.token.value == -1 || input.token.value == term ||\n                        overrides(term, input.token.value, precTable, precOffset))) {\n                    input.acceptToken(term);\n                    break;\n                }\n            }\n        let next = input.next, low = 0, high = data[state + 2];\n        // Special case for EOF\n        if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 /* Seq.End */ && data[accEnd + high * 3 - 3] == 65535 /* Seq.End */) {\n            state = data[accEnd + high * 3 - 1];\n            continue scan;\n        }\n        // Do a binary search on the state's edges\n        for (; low < high;) {\n            let mid = (low + high) >> 1;\n            let index = accEnd + mid + (mid << 1);\n            let from = data[index], to = data[index + 1] || 0x10000;\n            if (next < from)\n                high = mid;\n            else if (next >= to)\n                low = mid + 1;\n            else {\n                state = data[index + 2];\n                input.advance();\n                continue scan;\n            }\n        }\n        break;\n    }\n}\nfunction findOffset(data, start, term) {\n    for (let i = start, next; (next = data[i]) != 65535 /* Seq.End */; i++)\n        if (next == term)\n            return i - start;\n    return -1;\n}\nfunction overrides(token, prev, tableData, tableOffset) {\n    let iPrev = findOffset(tableData, tableOffset, prev);\n    return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;\n}\n\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && process.env && /\\bparse\\b/.test(process.env.LOG);\nlet stackIDs = null;\nvar Safety;\n(function (Safety) {\n    Safety[Safety[\"Margin\"] = 25] = \"Margin\";\n})(Safety || (Safety = {}));\nfunction cutAt(tree, pos, side) {\n    let cursor = tree.cursor(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.IterMode.IncludeAnonymous);\n    cursor.moveTo(pos);\n    for (;;) {\n        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))\n            for (;;) {\n                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)\n                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Safety.Margin */))\n                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Safety.Margin */));\n                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())\n                    break;\n                if (!cursor.parent())\n                    return side < 0 ? 0 : tree.length;\n            }\n    }\n}\nclass FragmentCursor {\n    constructor(fragments, nodeSet) {\n        this.fragments = fragments;\n        this.nodeSet = nodeSet;\n        this.i = 0;\n        this.fragment = null;\n        this.safeFrom = -1;\n        this.safeTo = -1;\n        this.trees = [];\n        this.start = [];\n        this.index = [];\n        this.nextFragment();\n    }\n    nextFragment() {\n        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n        if (fr) {\n            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n            while (this.trees.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n            }\n            this.trees.push(fr.tree);\n            this.start.push(-fr.offset);\n            this.index.push(0);\n            this.nextStart = this.safeFrom;\n        }\n        else {\n            this.nextStart = 1e9;\n        }\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    nodeAt(pos) {\n        if (pos < this.nextStart)\n            return null;\n        while (this.fragment && this.safeTo <= pos)\n            this.nextFragment();\n        if (!this.fragment)\n            return null;\n        for (;;) {\n            let last = this.trees.length - 1;\n            if (last < 0) { // End of tree\n                this.nextFragment();\n                return null;\n            }\n            let top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            let next = top.children[index];\n            let start = this.start[last] + top.positions[index];\n            if (start > pos) {\n                this.nextStart = start;\n                return null;\n            }\n            if (next instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {\n                if (start == pos) {\n                    if (start < this.safeFrom)\n                        return null;\n                    let end = start + next.length;\n                    if (end <= this.safeTo) {\n                        let lookAhead = next.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.lookAhead);\n                        if (!lookAhead || end + lookAhead < this.fragment.to)\n                            return next;\n                    }\n                }\n                this.index[last]++;\n                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            }\n            else {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n        }\n    }\n}\nclass TokenCache {\n    constructor(parser, stream) {\n        this.stream = stream;\n        this.tokens = [];\n        this.mainToken = null;\n        this.actions = [];\n        this.tokens = parser.tokenizers.map(_ => new CachedToken);\n    }\n    getActions(stack) {\n        let actionIndex = 0;\n        let main = null;\n        let { parser } = stack.p, { tokenizers } = parser;\n        let mask = parser.stateSlot(stack.state, 3 /* ParseState.TokenizerMask */);\n        let context = stack.curContext ? stack.curContext.hash : 0;\n        let lookAhead = 0;\n        for (let i = 0; i < tokenizers.length; i++) {\n            if (((1 << i) & mask) == 0)\n                continue;\n            let tokenizer = tokenizers[i], token = this.tokens[i];\n            if (main && !tokenizer.fallback)\n                continue;\n            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n                this.updateCachedToken(token, tokenizer, stack);\n                token.mask = mask;\n                token.context = context;\n            }\n            if (token.lookAhead > token.end + 25 /* Safety.Margin */)\n                lookAhead = Math.max(token.lookAhead, lookAhead);\n            if (token.value != 0 /* Term.Err */) {\n                let startIndex = actionIndex;\n                if (token.extended > -1)\n                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n                if (!tokenizer.extend) {\n                    main = token;\n                    if (actionIndex > startIndex)\n                        break;\n                }\n            }\n        }\n        while (this.actions.length > actionIndex)\n            this.actions.pop();\n        if (lookAhead)\n            stack.setLookAhead(lookAhead);\n        if (!main && stack.pos == this.stream.end) {\n            main = new CachedToken;\n            main.value = stack.p.parser.eofTerm;\n            main.start = main.end = stack.pos;\n            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);\n        }\n        this.mainToken = main;\n        return this.actions;\n    }\n    getMainToken(stack) {\n        if (this.mainToken)\n            return this.mainToken;\n        let main = new CachedToken, { pos, p } = stack;\n        main.start = pos;\n        main.end = Math.min(pos + 1, p.stream.end);\n        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Term.Err */;\n        return main;\n    }\n    updateCachedToken(token, tokenizer, stack) {\n        let start = this.stream.clipPos(stack.pos);\n        tokenizer.token(this.stream.reset(start, token), stack);\n        if (token.value > -1) {\n            let { parser } = stack.p;\n            for (let i = 0; i < parser.specialized.length; i++)\n                if (parser.specialized[i] == token.value) {\n                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);\n                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n                        if ((result & 1) == 0 /* Specialize.Specialize */)\n                            token.value = result >> 1;\n                        else\n                            token.extended = result >> 1;\n                        break;\n                    }\n                }\n        }\n        else {\n            token.value = 0 /* Term.Err */;\n            token.end = this.stream.clipPos(start + 1);\n        }\n    }\n    putAction(action, token, end, index) {\n        // Don't add duplicate actions\n        for (let i = 0; i < index; i += 3)\n            if (this.actions[i] == action)\n                return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    }\n    addActions(stack, token, end, index) {\n        let { state } = stack, { parser } = stack.p, { data } = parser;\n        for (let set = 0; set < 2; set++) {\n            for (let i = parser.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */);; i += 3) {\n                if (data[i] == 65535 /* Seq.End */) {\n                    if (data[i + 1] == 1 /* Seq.Next */) {\n                        i = pair(data, i + 2);\n                    }\n                    else {\n                        if (index == 0 && data[i + 1] == 2 /* Seq.Other */)\n                            index = this.putAction(pair(data, i + 2), token, end, index);\n                        break;\n                    }\n                }\n                if (data[i] == token)\n                    index = this.putAction(pair(data, i + 1), token, end, index);\n            }\n        }\n        return index;\n    }\n}\nvar Rec;\n(function (Rec) {\n    Rec[Rec[\"Distance\"] = 5] = \"Distance\";\n    Rec[Rec[\"MaxRemainingPerStep\"] = 3] = \"MaxRemainingPerStep\";\n    // When two stacks have been running independently long enough to\n    // add this many elements to their buffers, prune one.\n    Rec[Rec[\"MinBufferLengthPrune\"] = 500] = \"MinBufferLengthPrune\";\n    Rec[Rec[\"ForceReduceLimit\"] = 10] = \"ForceReduceLimit\";\n    // Once a stack reaches this depth (in .stack.length) force-reduce\n    // it back to CutTo to avoid creating trees that overflow the stack\n    // on recursive traversal.\n    Rec[Rec[\"CutDepth\"] = 15000] = \"CutDepth\";\n    Rec[Rec[\"CutTo\"] = 9000] = \"CutTo\";\n    Rec[Rec[\"MaxLeftAssociativeReductionCount\"] = 300] = \"MaxLeftAssociativeReductionCount\";\n    // The maximum number of non-recovering stacks to explore (to avoid\n    // getting bogged down with exponentially multiplying stacks in\n    // ambiguous content)\n    Rec[Rec[\"MaxStackCount\"] = 12] = \"MaxStackCount\";\n})(Rec || (Rec = {}));\nclass Parse {\n    constructor(parser, input, fragments, ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.recovering = 0;\n        this.nextStackID = 0x2654; // â™”, â™•, â™–, â™—, â™˜, â™™, â™ , â™¡, â™¢, â™£, â™¤, â™¥, â™¦, â™§\n        this.minStackPos = 0;\n        this.reused = [];\n        this.stoppedAt = null;\n        this.lastBigReductionStart = -1;\n        this.lastBigReductionSize = 0;\n        this.bigReductionCount = 0;\n        this.stream = new InputStream(input, ranges);\n        this.tokens = new TokenCache(parser, this.stream);\n        this.topTerm = parser.top[1];\n        let { from } = ranges[0];\n        this.stacks = [Stack.start(this, parser.top[0], from)];\n        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4\n            ? new FragmentCursor(fragments, parser.nodeSet) : null;\n    }\n    get parsedPos() {\n        return this.minStackPos;\n    }\n    // Move the parser forward. This will process all parse stacks at\n    // `this.pos` and try to advance them to a further position. If no\n    // stack for such a position is found, it'll start error-recovery.\n    //\n    // When the parse is finished, this will return a syntax tree. When\n    // not, it returns `null`.\n    advance() {\n        let stacks = this.stacks, pos = this.minStackPos;\n        // This will hold stacks beyond `pos`.\n        let newStacks = this.stacks = [];\n        let stopped, stoppedTokens;\n        // If a large amount of reductions happened with the same start\n        // position, force the stack out of that production in order to\n        // avoid creating a tree too deep to recurse through.\n        // (This is an ugly kludge, because unfortunately there is no\n        // straightforward, cheap way to check for this happening, due to\n        // the history of reductions only being available in an\n        // expensive-to-access format in the stack buffers.)\n        if (this.bigReductionCount > 300 /* Rec.MaxLeftAssociativeReductionCount */ && stacks.length == 1) {\n            let [s] = stacks;\n            while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) { }\n            this.bigReductionCount = this.lastBigReductionSize = 0;\n        }\n        // Keep advancing any stacks at `pos` until they either move\n        // forward or can't be advanced. Gather stacks that can't be\n        // advanced further in `stopped`.\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i];\n            for (;;) {\n                this.tokens.mainToken = null;\n                if (stack.pos > pos) {\n                    newStacks.push(stack);\n                }\n                else if (this.advanceStack(stack, newStacks, stacks)) {\n                    continue;\n                }\n                else {\n                    if (!stopped) {\n                        stopped = [];\n                        stoppedTokens = [];\n                    }\n                    stopped.push(stack);\n                    let tok = this.tokens.getMainToken(stack);\n                    stoppedTokens.push(tok.value, tok.end);\n                }\n                break;\n            }\n        }\n        if (!newStacks.length) {\n            let finished = stopped && findFinished(stopped);\n            if (finished)\n                return this.stackToTree(finished);\n            if (this.parser.strict) {\n                if (verbose && stopped)\n                    console.log(\"Stuck with token \" + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : \"none\"));\n                throw new SyntaxError(\"No parse at \" + pos);\n            }\n            if (!this.recovering)\n                this.recovering = 5 /* Rec.Distance */;\n        }\n        if (this.recovering && stopped) {\n            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0]\n                : this.runRecovery(stopped, stoppedTokens, newStacks);\n            if (finished)\n                return this.stackToTree(finished.forceAll());\n        }\n        if (this.recovering) {\n            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* Rec.MaxRemainingPerStep */;\n            if (newStacks.length > maxRemaining) {\n                newStacks.sort((a, b) => b.score - a.score);\n                while (newStacks.length > maxRemaining)\n                    newStacks.pop();\n            }\n            if (newStacks.some(s => s.reducePos > pos))\n                this.recovering--;\n        }\n        else if (newStacks.length > 1) {\n            // Prune stacks that are in the same state, or that have been\n            // running without splitting for a while, to avoid getting stuck\n            // with multiple successful stacks running endlessly on.\n            outer: for (let i = 0; i < newStacks.length - 1; i++) {\n                let stack = newStacks[i];\n                for (let j = i + 1; j < newStacks.length; j++) {\n                    let other = newStacks[j];\n                    if (stack.sameState(other) ||\n                        stack.buffer.length > 500 /* Rec.MinBufferLengthPrune */ && other.buffer.length > 500 /* Rec.MinBufferLengthPrune */) {\n                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {\n                            newStacks.splice(j--, 1);\n                        }\n                        else {\n                            newStacks.splice(i--, 1);\n                            continue outer;\n                        }\n                    }\n                }\n            }\n            if (newStacks.length > 12 /* Rec.MaxStackCount */)\n                newStacks.splice(12 /* Rec.MaxStackCount */, newStacks.length - 12 /* Rec.MaxStackCount */);\n        }\n        this.minStackPos = newStacks[0].pos;\n        for (let i = 1; i < newStacks.length; i++)\n            if (newStacks[i].pos < this.minStackPos)\n                this.minStackPos = newStacks[i].pos;\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    // Returns an updated version of the given stack, or null if the\n    // stack can't advance normally. When `split` and `stacks` are\n    // given, stacks split off by ambiguous operations will be pushed to\n    // `split`, or added to `stacks` if they move `pos` forward.\n    advanceStack(stack, stacks, split) {\n        let start = stack.pos, { parser } = this;\n        let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n        if (this.stoppedAt != null && start > this.stoppedAt)\n            return stack.forceReduce() ? stack : null;\n        if (this.fragments) {\n            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;\n            for (let cached = this.fragments.nodeAt(start); cached;) {\n                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n                if (match > -1 && cached.length && (!strictCx || (cached.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.contextHash) || 0) == cxHash)) {\n                    stack.useNode(cached, match);\n                    if (verbose)\n                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n                    return true;\n                }\n                if (!(cached instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) || cached.children.length == 0 || cached.positions[0] > 0)\n                    break;\n                let inner = cached.children[0];\n                if (inner instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && cached.positions[0] == 0)\n                    cached = inner;\n                else\n                    break;\n            }\n        }\n        let defaultReduce = parser.stateSlot(stack.state, 4 /* ParseState.DefaultReduce */);\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            if (verbose)\n                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* Action.ValueMask */)})`);\n            return true;\n        }\n        if (stack.stack.length >= 15000 /* Rec.CutDepth */) {\n            while (stack.stack.length > 9000 /* Rec.CutTo */ && stack.forceReduce()) { }\n        }\n        let actions = this.tokens.getActions(stack);\n        for (let i = 0; i < actions.length;) {\n            let action = actions[i++], term = actions[i++], end = actions[i++];\n            let last = i == actions.length || !split;\n            let localStack = last ? stack : stack.split();\n            localStack.apply(action, term, end);\n            if (verbose)\n                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* Action.ReduceFlag */) == 0 ? \"shift\"\n                    : `reduce of ${parser.getName(action & 65535 /* Action.ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n            if (last)\n                return true;\n            else if (localStack.pos > start)\n                stacks.push(localStack);\n            else\n                split.push(localStack);\n        }\n        return false;\n    }\n    // Advance a given stack forward as far as it will go. Returns the\n    // (possibly updated) stack if it got stuck, or null if it moved\n    // forward and was given to `pushStackDedup`.\n    advanceFully(stack, newStacks) {\n        let pos = stack.pos;\n        for (;;) {\n            if (!this.advanceStack(stack, null, null))\n                return false;\n            if (stack.pos > pos) {\n                pushStackDedup(stack, newStacks);\n                return true;\n            }\n        }\n    }\n    runRecovery(stacks, tokens, newStacks) {\n        let finished = null, restarted = false;\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n            let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n            if (stack.deadEnd) {\n                if (restarted)\n                    continue;\n                restarted = true;\n                stack.restart();\n                if (verbose)\n                    console.log(base + this.stackID(stack) + \" (restarted)\");\n                let done = this.advanceFully(stack, newStacks);\n                if (done)\n                    continue;\n            }\n            let force = stack.split(), forceBase = base;\n            for (let j = 0; force.forceReduce() && j < 10 /* Rec.ForceReduceLimit */; j++) {\n                if (verbose)\n                    console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n                let done = this.advanceFully(force, newStacks);\n                if (done)\n                    break;\n                if (verbose)\n                    forceBase = this.stackID(force) + \" -> \";\n            }\n            for (let insert of stack.recoverByInsert(token)) {\n                if (verbose)\n                    console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n                this.advanceFully(insert, newStacks);\n            }\n            if (this.stream.end > stack.pos) {\n                if (tokenEnd == stack.pos) {\n                    tokenEnd++;\n                    token = 0 /* Term.Err */;\n                }\n                stack.recoverByDelete(token, tokenEnd);\n                if (verbose)\n                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n                pushStackDedup(stack, newStacks);\n            }\n            else if (!finished || finished.score < stack.score) {\n                finished = stack;\n            }\n        }\n        return finished;\n    }\n    // Convert the stack's buffer to a syntax tree.\n    stackToTree(stack) {\n        stack.close();\n        return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({ buffer: StackBufferCursor.create(stack),\n            nodeSet: this.parser.nodeSet,\n            topID: this.topTerm,\n            maxBufferLength: this.parser.bufferLength,\n            reused: this.reused,\n            start: this.ranges[0].from,\n            length: stack.pos - this.ranges[0].from,\n            minRepeatType: this.parser.minRepeatTerm });\n    }\n    stackID(stack) {\n        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);\n        if (!id)\n            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n        return id + stack;\n    }\n}\nfunction pushStackDedup(stack, newStacks) {\n    for (let i = 0; i < newStacks.length; i++) {\n        let other = newStacks[i];\n        if (other.pos == stack.pos && other.sameState(stack)) {\n            if (newStacks[i].score < stack.score)\n                newStacks[i] = stack;\n            return;\n        }\n    }\n    newStacks.push(stack);\n}\nclass Dialect {\n    constructor(source, flags, disabled) {\n        this.source = source;\n        this.flags = flags;\n        this.disabled = disabled;\n    }\n    allows(term) { return !this.disabled || this.disabled[term] == 0; }\n}\nconst id = x => x;\n/// Context trackers are used to track stateful context (such as\n/// indentation in the Python grammar, or parent elements in the XML\n/// grammar) needed by external tokenizers. You declare them in a\n/// grammar file as `@context exportName from \"module\"`.\n///\n/// Context values should be immutable, and can be updated (replaced)\n/// on shift or reduce actions.\n///\n/// The export used in a `@context` declaration should be of this\n/// type.\nclass ContextTracker {\n    /// Define a context tracker.\n    constructor(spec) {\n        this.start = spec.start;\n        this.shift = spec.shift || id;\n        this.reduce = spec.reduce || id;\n        this.reuse = spec.reuse || id;\n        this.hash = spec.hash || (() => 0);\n        this.strict = spec.strict !== false;\n    }\n}\n/// Holds the parse tables for a given grammar, as generated by\n/// `lezer-generator`, and provides [methods](#common.Parser) to parse\n/// content with.\nclass LRParser extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n    /// @internal\n    constructor(spec) {\n        super();\n        /// @internal\n        this.wrappers = [];\n        if (spec.version != 14 /* File.Version */)\n            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14 /* File.Version */})`);\n        let nodeNames = spec.nodeNames.split(\" \");\n        this.minRepeatTerm = nodeNames.length;\n        for (let i = 0; i < spec.repeatNodeCount; i++)\n            nodeNames.push(\"\");\n        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);\n        let nodeProps = [];\n        for (let i = 0; i < nodeNames.length; i++)\n            nodeProps.push([]);\n        function setProp(nodeID, prop, value) {\n            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);\n        }\n        if (spec.nodeProps)\n            for (let propSpec of spec.nodeProps) {\n                let prop = propSpec[0];\n                if (typeof prop == \"string\")\n                    prop = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp[prop];\n                for (let i = 1; i < propSpec.length;) {\n                    let next = propSpec[i++];\n                    if (next >= 0) {\n                        setProp(next, prop, propSpec[i++]);\n                    }\n                    else {\n                        let value = propSpec[i + -next];\n                        for (let j = -next; j > 0; j--)\n                            setProp(propSpec[i++], prop, value);\n                        i++;\n                    }\n                }\n            }\n        this.nodeSet = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(nodeNames.map((name, i) => _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n            name: i >= this.minRepeatTerm ? undefined : name,\n            id: i,\n            props: nodeProps[i],\n            top: topTerms.indexOf(i) > -1,\n            error: i == 0,\n            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n        })));\n        if (spec.propSources)\n            this.nodeSet = this.nodeSet.extend(...spec.propSources);\n        this.strict = false;\n        this.bufferLength = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.DefaultBufferLength;\n        let tokenArray = decodeArray(spec.tokenData);\n        this.context = spec.context;\n        this.specializerSpecs = spec.specialized || [];\n        this.specialized = new Uint16Array(this.specializerSpecs.length);\n        for (let i = 0; i < this.specializerSpecs.length; i++)\n            this.specialized[i] = this.specializerSpecs[i].term;\n        this.specializers = this.specializerSpecs.map(getSpecializer);\n        this.states = decodeArray(spec.states, Uint32Array);\n        this.data = decodeArray(spec.stateData);\n        this.goto = decodeArray(spec.goto);\n        this.maxTerm = spec.maxTerm;\n        this.tokenizers = spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n        this.topRules = spec.topRules;\n        this.dialects = spec.dialects || {};\n        this.dynamicPrecedences = spec.dynamicPrecedences || null;\n        this.tokenPrecTable = spec.tokenPrec;\n        this.termNames = spec.termNames || null;\n        this.maxNode = this.nodeSet.types.length - 1;\n        this.dialect = this.parseDialect();\n        this.top = this.topRules[Object.keys(this.topRules)[0]];\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new Parse(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /// Get a goto table entry @internal\n    getGoto(state, term, loose = false) {\n        let table = this.goto;\n        if (term >= table[0])\n            return -1;\n        for (let pos = table[term + 1];;) {\n            let groupTag = table[pos++], last = groupTag & 1;\n            let target = table[pos++];\n            if (last && loose)\n                return target;\n            for (let end = pos + (groupTag >> 1); pos < end; pos++)\n                if (table[pos] == state)\n                    return target;\n            if (last)\n                return -1;\n        }\n    }\n    /// Check if this state has an action for a given terminal @internal\n    hasAction(state, terminal) {\n        let data = this.data;\n        for (let set = 0; set < 2; set++) {\n            for (let i = this.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */), next;; i += 3) {\n                if ((next = data[i]) == 65535 /* Seq.End */) {\n                    if (data[i + 1] == 1 /* Seq.Next */)\n                        next = data[i = pair(data, i + 2)];\n                    else if (data[i + 1] == 2 /* Seq.Other */)\n                        return pair(data, i + 2);\n                    else\n                        break;\n                }\n                if (next == terminal || next == 0 /* Term.Err */)\n                    return pair(data, i + 1);\n            }\n        }\n        return 0;\n    }\n    /// @internal\n    stateSlot(state, slot) {\n        return this.states[(state * 6 /* ParseState.Size */) + slot];\n    }\n    /// @internal\n    stateFlag(state, flag) {\n        return (this.stateSlot(state, 0 /* ParseState.Flags */) & flag) > 0;\n    }\n    /// @internal\n    validAction(state, action) {\n        return !!this.allActions(state, a => a == action ? true : null);\n    }\n    /// @internal\n    allActions(state, action) {\n        let deflt = this.stateSlot(state, 4 /* ParseState.DefaultReduce */);\n        let result = deflt ? action(deflt) : undefined;\n        for (let i = this.stateSlot(state, 1 /* ParseState.Actions */); result == null; i += 3) {\n            if (this.data[i] == 65535 /* Seq.End */) {\n                if (this.data[i + 1] == 1 /* Seq.Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            result = action(pair(this.data, i + 1));\n        }\n        return result;\n    }\n    /// Get the states that can follow this one through shift actions or\n    /// goto jumps. @internal\n    nextStates(state) {\n        let result = [];\n        for (let i = this.stateSlot(state, 1 /* ParseState.Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* Seq.End */) {\n                if (this.data[i + 1] == 1 /* Seq.Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            if ((this.data[i + 2] & (65536 /* Action.ReduceFlag */ >> 16)) == 0) {\n                let value = this.data[i + 1];\n                if (!result.some((v, i) => (i & 1) && v == value))\n                    result.push(this.data[i], value);\n            }\n        }\n        return result;\n    }\n    /// Configure the parser. Returns a new parser instance that has the\n    /// given settings modified. Settings not provided in `config` are\n    /// kept from the original parser.\n    configure(config) {\n        // Hideous reflection-based kludge to make it easy to create a\n        // slightly modified copy of a parser.\n        let copy = Object.assign(Object.create(LRParser.prototype), this);\n        if (config.props)\n            copy.nodeSet = this.nodeSet.extend(...config.props);\n        if (config.top) {\n            let info = this.topRules[config.top];\n            if (!info)\n                throw new RangeError(`Invalid top rule name ${config.top}`);\n            copy.top = info;\n        }\n        if (config.tokenizers)\n            copy.tokenizers = this.tokenizers.map(t => {\n                let found = config.tokenizers.find(r => r.from == t);\n                return found ? found.to : t;\n            });\n        if (config.specializers) {\n            copy.specializers = this.specializers.slice();\n            copy.specializerSpecs = this.specializerSpecs.map((s, i) => {\n                let found = config.specializers.find(r => r.from == s.external);\n                if (!found)\n                    return s;\n                let spec = Object.assign(Object.assign({}, s), { external: found.to });\n                copy.specializers[i] = getSpecializer(spec);\n                return spec;\n            });\n        }\n        if (config.contextTracker)\n            copy.context = config.contextTracker;\n        if (config.dialect)\n            copy.dialect = this.parseDialect(config.dialect);\n        if (config.strict != null)\n            copy.strict = config.strict;\n        if (config.wrap)\n            copy.wrappers = copy.wrappers.concat(config.wrap);\n        if (config.bufferLength != null)\n            copy.bufferLength = config.bufferLength;\n        return copy;\n    }\n    /// Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)\n    /// are registered for this parser.\n    hasWrappers() {\n        return this.wrappers.length > 0;\n    }\n    /// Returns the name associated with a given term. This will only\n    /// work for all terms when the parser was generated with the\n    /// `--names` option. By default, only the names of tagged terms are\n    /// stored.\n    getName(term) {\n        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n    }\n    /// The eof term id is always allocated directly after the node\n    /// types. @internal\n    get eofTerm() { return this.maxNode + 1; }\n    /// The type of top node produced by the parser.\n    get topNode() { return this.nodeSet.types[this.top[1]]; }\n    /// @internal\n    dynamicPrecedence(term) {\n        let prec = this.dynamicPrecedences;\n        return prec == null ? 0 : prec[term] || 0;\n    }\n    /// @internal\n    parseDialect(dialect) {\n        let values = Object.keys(this.dialects), flags = values.map(() => false);\n        if (dialect)\n            for (let part of dialect.split(\" \")) {\n                let id = values.indexOf(part);\n                if (id >= 0)\n                    flags[id] = true;\n            }\n        let disabled = null;\n        for (let i = 0; i < values.length; i++)\n            if (!flags[i]) {\n                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* Seq.End */;)\n                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n            }\n        return new Dialect(dialect, flags, disabled);\n    }\n    /// Used by the output of the parser generator. Not available to\n    /// user code. @hide\n    static deserialize(spec) {\n        return new LRParser(spec);\n    }\n}\nfunction pair(data, off) { return data[off] | (data[off + 1] << 16); }\nfunction findFinished(stacks) {\n    let best = null;\n    for (let stack of stacks) {\n        let stopped = stack.p.stoppedAt;\n        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&\n            stack.p.parser.stateFlag(stack.state, 2 /* StateFlag.Accepting */) &&\n            (!best || best.score < stack.score))\n            best = stack;\n    }\n    return best;\n}\nfunction getSpecializer(spec) {\n    if (spec.external) {\n        let mask = spec.extend ? 1 /* Specialize.Extend */ : 0 /* Specialize.Specialize */;\n        return (value, stack) => (spec.external(value, stack) << 1) | mask;\n    }\n    return spec.get;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2xyL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF5Rzs7QUFFekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyREFBMkQsSUFBSSxTQUFTLEVBQUUsbUNBQW1DO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFFQUFxRTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrRUFBa0U7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQkFBa0I7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQkFBMEI7QUFDN0Q7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbGl2ZWJsb2Nrcy1leGFtcGxlcy9uZXh0anMteWpzLWNvZGVtaXJyb3IvLi9ub2RlX21vZHVsZXMvQGxlemVyL2xyL2Rpc3QvaW5kZXguanM/ZDcyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYXJzZXIsIE5vZGVQcm9wLCBOb2RlU2V0LCBOb2RlVHlwZSwgRGVmYXVsdEJ1ZmZlckxlbmd0aCwgVHJlZSwgSXRlck1vZGUgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxuLy8vIEEgcGFyc2Ugc3RhY2suIFRoZXNlIGFyZSB1c2VkIGludGVybmFsbHkgYnkgdGhlIHBhcnNlciB0byB0cmFja1xuLy8vIHBhcnNpbmcgcHJvZ3Jlc3MuIFRoZXkgYWxzbyBwcm92aWRlIHNvbWUgcHJvcGVydGllcyBhbmQgbWV0aG9kc1xuLy8vIHRoYXQgZXh0ZXJuYWwgY29kZSBzdWNoIGFzIGEgdG9rZW5pemVyIGNhbiB1c2UgdG8gZ2V0IGluZm9ybWF0aW9uXG4vLy8gYWJvdXQgdGhlIHBhcnNlIHN0YXRlLlxuY2xhc3MgU3RhY2sge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHBhcnNlIHRoYXQgdGhpcyBzdGFjayBpcyBwYXJ0IG9mIEBpbnRlcm5hbFxuICAgIHAsIFxuICAgIC8vLyBIb2xkcyBzdGF0ZSwgaW5wdXQgcG9zLCBidWZmZXIgaW5kZXggdHJpcGxldHMgZm9yIGFsbCBidXQgdGhlXG4gICAgLy8vIHRvcCBzdGF0ZSBAaW50ZXJuYWxcbiAgICBzdGFjaywgXG4gICAgLy8vIFRoZSBjdXJyZW50IHBhcnNlIHN0YXRlIEBpbnRlcm5hbFxuICAgIHN0YXRlLCBcbiAgICAvLyBUaGUgcG9zaXRpb24gYXQgd2hpY2ggdGhlIG5leHQgcmVkdWNlIHNob3VsZCB0YWtlIHBsYWNlLiBUaGlzXG4gICAgLy8gY2FuIGJlIGxlc3MgdGhhbiBgdGhpcy5wb3NgIHdoZW4gc2tpcHBlZCBleHByZXNzaW9ucyBoYXZlIGJlZW5cbiAgICAvLyBhZGRlZCB0byB0aGUgc3RhY2sgKHdoaWNoIHNob3VsZCBiZSBtb3ZlZCBvdXRzaWRlIG9mIHRoZSBuZXh0XG4gICAgLy8gcmVkdWN0aW9uKVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWR1Y2VQb3MsIFxuICAgIC8vLyBUaGUgaW5wdXQgcG9zaXRpb24gdXAgdG8gd2hpY2ggdGhpcyBzdGFjayBoYXMgcGFyc2VkLlxuICAgIHBvcywgXG4gICAgLy8vIFRoZSBkeW5hbWljIHNjb3JlIG9mIHRoZSBzdGFjaywgaW5jbHVkaW5nIGR5bmFtaWMgcHJlY2VkZW5jZVxuICAgIC8vLyBhbmQgZXJyb3ItcmVjb3ZlcnkgcGVuYWx0aWVzXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNjb3JlLCBcbiAgICAvLyBUaGUgb3V0cHV0IGJ1ZmZlci4gSG9sZHMgKHR5cGUsIHN0YXJ0LCBlbmQsIHNpemUpIHF1YWRzXG4gICAgLy8gcmVwcmVzZW50aW5nIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIHBhcnNlciwgd2hlcmUgYHNpemVgIGlzXG4gICAgLy8gYW1vdW50IG9mIGJ1ZmZlciBhcnJheSBlbnRyaWVzIGNvdmVyZWQgYnkgdGhpcyBub2RlLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBidWZmZXIsIFxuICAgIC8vIFRoZSBiYXNlIG9mZnNldCBvZiB0aGUgYnVmZmVyLiBXaGVuIHN0YWNrcyBhcmUgc3BsaXQsIHRoZSBzcGxpdFxuICAgIC8vIGluc3RhbmNlIHNoYXJlZCB0aGUgYnVmZmVyIGhpc3Rvcnkgd2l0aCBpdHMgcGFyZW50IHVwIHRvXG4gICAgLy8gYGJ1ZmZlckJhc2VgLCB3aGljaCBpcyB0aGUgYWJzb2x1dGUgb2Zmc2V0IChpbmNsdWRpbmcgdGhlXG4gICAgLy8gb2Zmc2V0IG9mIHByZXZpb3VzIHNwbGl0cykgaW50byB0aGUgYnVmZmVyIGF0IHdoaWNoIHRoaXMgc3RhY2tcbiAgICAvLyBzdGFydHMgd3JpdGluZy5cbiAgICAvLy8gQGludGVybmFsXG4gICAgYnVmZmVyQmFzZSwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGN1ckNvbnRleHQsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBsb29rQWhlYWQgPSAwLCBcbiAgICAvLyBBIHBhcmVudCBzdGFjayBmcm9tIHdoaWNoIHRoaXMgd2FzIHNwbGl0IG9mZiwgaWYgYW55LiBUaGlzIGlzXG4gICAgLy8gc2V0IHVwIHNvIHRoYXQgaXQgYWx3YXlzIHBvaW50cyB0byBhIHN0YWNrIHRoYXQgaGFzIHNvbWVcbiAgICAvLyBhZGRpdGlvbmFsIGJ1ZmZlciBjb250ZW50LCBuZXZlciB0byBhIHN0YWNrIHdpdGggYW4gZXF1YWxcbiAgICAvLyBgYnVmZmVyQmFzZWAuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHBhcmVudCkge1xuICAgICAgICB0aGlzLnAgPSBwO1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSByZWR1Y2VQb3M7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLnNjb3JlID0gc2NvcmU7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmJ1ZmZlckJhc2UgPSBidWZmZXJCYXNlO1xuICAgICAgICB0aGlzLmN1ckNvbnRleHQgPSBjdXJDb250ZXh0O1xuICAgICAgICB0aGlzLmxvb2tBaGVhZCA9IGxvb2tBaGVhZDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBbJHt0aGlzLnN0YWNrLmZpbHRlcigoXywgaSkgPT4gaSAlIDMgPT0gMCkuY29uY2F0KHRoaXMuc3RhdGUpfV1AJHt0aGlzLnBvc30ke3RoaXMuc2NvcmUgPyBcIiFcIiArIHRoaXMuc2NvcmUgOiBcIlwifWA7XG4gICAgfVxuICAgIC8vIFN0YXJ0IGFuIGVtcHR5IHN0YWNrXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0YXRpYyBzdGFydChwLCBzdGF0ZSwgcG9zID0gMCkge1xuICAgICAgICBsZXQgY3ggPSBwLnBhcnNlci5jb250ZXh0O1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrKHAsIFtdLCBzdGF0ZSwgcG9zLCBwb3MsIDAsIFtdLCAwLCBjeCA/IG5ldyBTdGFja0NvbnRleHQoY3gsIGN4LnN0YXJ0KSA6IG51bGwsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvLy8gVGhlIHN0YWNrJ3MgY3VycmVudCBbY29udGV4dF0oI2xyLkNvbnRleHRUcmFja2VyKSB2YWx1ZSwgaWZcbiAgICAvLy8gYW55LiBJdHMgdHlwZSB3aWxsIGRlcGVuZCBvbiB0aGUgY29udGV4dCB0cmFja2VyJ3MgdHlwZVxuICAgIC8vLyBwYXJhbWV0ZXIsIG9yIGl0IHdpbGwgYmUgYG51bGxgIGlmIHRoZXJlIGlzIG5vIGNvbnRleHRcbiAgICAvLy8gdHJhY2tlci5cbiAgICBnZXQgY29udGV4dCgpIHsgcmV0dXJuIHRoaXMuY3VyQ29udGV4dCA/IHRoaXMuY3VyQ29udGV4dC5jb250ZXh0IDogbnVsbDsgfVxuICAgIC8vIFB1c2ggYSBzdGF0ZSBvbnRvIHRoZSBzdGFjaywgdHJhY2tpbmcgaXRzIHN0YXJ0IHBvc2l0aW9uIGFzIHdlbGxcbiAgICAvLyBhcyB0aGUgYnVmZmVyIGJhc2UgYXQgdGhhdCBwb2ludC5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcHVzaFN0YXRlKHN0YXRlLCBzdGFydCkge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZSwgc3RhcnQsIHRoaXMuYnVmZmVyQmFzZSArIHRoaXMuYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gICAgLy8gQXBwbHkgYSByZWR1Y2UgYWN0aW9uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlZHVjZShhY3Rpb24pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgZGVwdGggPSBhY3Rpb24gPj4gMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi8sIHR5cGUgPSBhY3Rpb24gJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgbGV0IGRQcmVjID0gcGFyc2VyLmR5bmFtaWNQcmVjZWRlbmNlKHR5cGUpO1xuICAgICAgICBpZiAoZFByZWMpXG4gICAgICAgICAgICB0aGlzLnNjb3JlICs9IGRQcmVjO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUocGFyc2VyLmdldEdvdG8odGhpcy5zdGF0ZSwgdHlwZSwgdHJ1ZSksIHRoaXMucmVkdWNlUG9zKTtcbiAgICAgICAgICAgIC8vIFplcm8tZGVwdGggcmVkdWN0aW9ucyBhcmUgYSBzcGVjaWFsIGNhc2XigJR0aGV5IGFkZCBzdHVmZiB0b1xuICAgICAgICAgICAgLy8gdGhlIHN0YWNrIHdpdGhvdXQgcG9wcGluZyBhbnl0aGluZyBvZmYuXG4gICAgICAgICAgICBpZiAodHlwZSA8IHBhcnNlci5taW5SZXBlYXRUZXJtKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKHR5cGUsIHRoaXMucmVkdWNlUG9zLCB0aGlzLnJlZHVjZVBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnJlZHVjZUNvbnRleHQodHlwZSwgdGhpcy5yZWR1Y2VQb3MpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgdGhlIGJhc2UgaW5kZXggaW50byBgdGhpcy5zdGFja2AsIGNvbnRlbnQgYWZ0ZXIgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBkcm9wcGVkLiBOb3RlIHRoYXQgd2l0aCBgU3RheUZsYWdgIHJlZHVjdGlvbnMgd2UgbmVlZCB0b1xuICAgICAgICAvLyBjb25zdW1lIHR3byBleHRyYSBmcmFtZXMgKHRoZSBkdW1teSBwYXJlbnQgbm9kZSBmb3IgdGhlIHNraXBwZWRcbiAgICAgICAgLy8gZXhwcmVzc2lvbiBhbmQgdGhlIHN0YXRlIHRoYXQgd2UnbGwgYmUgc3RheWluZyBpbiwgd2hpY2ggc2hvdWxkXG4gICAgICAgIC8vIGJlIG1vdmVkIHRvIGB0aGlzLnN0YXRlYCkuXG4gICAgICAgIGxldCBiYXNlID0gdGhpcy5zdGFjay5sZW5ndGggLSAoKGRlcHRoIC0gMSkgKiAzKSAtIChhY3Rpb24gJiAyNjIxNDQgLyogQWN0aW9uLlN0YXlGbGFnICovID8gNiA6IDApO1xuICAgICAgICBsZXQgc3RhcnQgPSBiYXNlID8gdGhpcy5zdGFja1tiYXNlIC0gMl0gOiB0aGlzLnAucmFuZ2VzWzBdLmZyb20sIHNpemUgPSB0aGlzLnJlZHVjZVBvcyAtIHN0YXJ0O1xuICAgICAgICAvLyBUaGlzIGlzIGEga2x1ZGdlIHRvIHRyeSBhbmQgZGV0ZWN0IG92ZXJseSBkZWVwIGxlZnQtYXNzb2NpYXRpdmVcbiAgICAgICAgLy8gdHJlZXMsIHdoaWNoIHdpbGwgbm90IGluY3JlYXNlIHRoZSBwYXJzZSBzdGFjayBkZXB0aCBhbmQgdGh1c1xuICAgICAgICAvLyB3b24ndCBiZSBjYXVnaHQgYnkgdGhlIHJlZ3VsYXIgc3RhY2stZGVwdGggbGltaXQgY2hlY2suXG4gICAgICAgIGlmIChzaXplID49IDIwMDAgLyogUmVjb3Zlci5NaW5CaWdSZWR1Y3Rpb24gKi8gJiYgISgoX2EgPSB0aGlzLnAucGFyc2VyLm5vZGVTZXQudHlwZXNbdHlwZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0Fub255bW91cykpIHtcbiAgICAgICAgICAgIGlmIChzdGFydCA9PSB0aGlzLnAubGFzdEJpZ1JlZHVjdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wLmJpZ1JlZHVjdGlvbkNvdW50Kys7XG4gICAgICAgICAgICAgICAgdGhpcy5wLmxhc3RCaWdSZWR1Y3Rpb25TaXplID0gc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucC5sYXN0QmlnUmVkdWN0aW9uU2l6ZSA8IHNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnAuYmlnUmVkdWN0aW9uQ291bnQgPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMucC5sYXN0QmlnUmVkdWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICB0aGlzLnAubGFzdEJpZ1JlZHVjdGlvblNpemUgPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBidWZmZXJCYXNlID0gYmFzZSA/IHRoaXMuc3RhY2tbYmFzZSAtIDFdIDogMCwgY291bnQgPSB0aGlzLmJ1ZmZlckJhc2UgKyB0aGlzLmJ1ZmZlci5sZW5ndGggLSBidWZmZXJCYXNlO1xuICAgICAgICAvLyBTdG9yZSBub3JtYWwgdGVybXMgb3IgYFIgLT4gUiBSYCByZXBlYXQgcmVkdWN0aW9uc1xuICAgICAgICBpZiAodHlwZSA8IHBhcnNlci5taW5SZXBlYXRUZXJtIHx8IChhY3Rpb24gJiAxMzEwNzIgLyogQWN0aW9uLlJlcGVhdEZsYWcgKi8pKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gcGFyc2VyLnN0YXRlRmxhZyh0aGlzLnN0YXRlLCAxIC8qIFN0YXRlRmxhZy5Ta2lwcGVkICovKSA/IHRoaXMucG9zIDogdGhpcy5yZWR1Y2VQb3M7XG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSh0eXBlLCBzdGFydCwgcG9zLCBjb3VudCArIDQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3Rpb24gJiAyNjIxNDQgLyogQWN0aW9uLlN0YXlGbGFnICovKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGFja1tiYXNlXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBiYXNlU3RhdGVJRCA9IHRoaXMuc3RhY2tbYmFzZSAtIDNdO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHBhcnNlci5nZXRHb3RvKGJhc2VTdGF0ZUlELCB0eXBlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5zdGFjay5sZW5ndGggPiBiYXNlKVxuICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgdGhpcy5yZWR1Y2VDb250ZXh0KHR5cGUsIHN0YXJ0KTtcbiAgICB9XG4gICAgLy8gU2hpZnQgYSB2YWx1ZSBpbnRvIHRoZSBidWZmZXJcbiAgICAvLy8gQGludGVybmFsXG4gICAgc3RvcmVOb2RlKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUgPSA0LCBpc1JlZHVjZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0ZXJtID09IDAgLyogVGVybS5FcnIgKi8gJiZcbiAgICAgICAgICAgICghdGhpcy5zdGFjay5sZW5ndGggfHwgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdIDwgdGhpcy5idWZmZXIubGVuZ3RoICsgdGhpcy5idWZmZXJCYXNlKSkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIG9taXQvbWVyZ2UgYWRqYWNlbnQgZXJyb3Igbm9kZXNcbiAgICAgICAgICAgIGxldCBjdXIgPSB0aGlzLCB0b3AgPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodG9wID09IDAgJiYgY3VyLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRvcCA9IGN1ci5idWZmZXJCYXNlIC0gY3VyLnBhcmVudC5idWZmZXJCYXNlO1xuICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9wID4gMCAmJiBjdXIuYnVmZmVyW3RvcCAtIDRdID09IDAgLyogVGVybS5FcnIgKi8gJiYgY3VyLmJ1ZmZlclt0b3AgLSAxXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGVuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChjdXIuYnVmZmVyW3RvcCAtIDJdID49IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ci5idWZmZXJbdG9wIC0gMl0gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1JlZHVjZSB8fCB0aGlzLnBvcyA9PSBlbmQpIHsgLy8gU2ltcGxlIGNhc2UsIGp1c3QgYXBwZW5kXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBUaGVyZSBtYXkgYmUgc2tpcHBlZCBub2RlcyB0aGF0IGhhdmUgdG8gYmUgbW92ZWQgZm9yd2FyZFxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCAmJiB0aGlzLmJ1ZmZlcltpbmRleCAtIDRdICE9IDAgLyogVGVybS5FcnIgKi8pXG4gICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4ID4gMCAmJiB0aGlzLmJ1ZmZlcltpbmRleCAtIDJdID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhpcyByZWNvcmQgZm9yd2FyZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleF0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDRdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDFdID0gdGhpcy5idWZmZXJbaW5kZXggLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAyXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gMl07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgM10gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCAtPSA0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IDQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplIC09IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXhdID0gdGVybTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMV0gPSBzdGFydDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMl0gPSBlbmQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDNdID0gc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSBhIHNoaWZ0IGFjdGlvblxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzaGlmdChhY3Rpb24sIG5leHQsIG5leHRFbmQpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIGlmIChhY3Rpb24gJiAxMzEwNzIgLyogQWN0aW9uLkdvdG9GbGFnICovKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShhY3Rpb24gJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovLCB0aGlzLnBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGFjdGlvbiAmIDI2MjE0NCAvKiBBY3Rpb24uU3RheUZsYWcgKi8pID09IDApIHsgLy8gUmVndWxhciBzaGlmdFxuICAgICAgICAgICAgbGV0IG5leHRTdGF0ZSA9IGFjdGlvbiwgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgICAgIGlmIChuZXh0RW5kID4gdGhpcy5wb3MgfHwgbmV4dCA8PSBwYXJzZXIubWF4Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gbmV4dEVuZDtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlci5zdGF0ZUZsYWcobmV4dFN0YXRlLCAxIC8qIFN0YXRlRmxhZy5Ta2lwcGVkICovKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSBuZXh0RW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUobmV4dFN0YXRlLCBzdGFydCk7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0Q29udGV4dChuZXh0LCBzdGFydCk7XG4gICAgICAgICAgICBpZiAobmV4dCA8PSBwYXJzZXIubWF4Tm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKG5leHQsIHN0YXJ0LCBuZXh0RW5kLCA0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gU2hpZnQtYW5kLXN0YXksIHdoaWNoIG1lYW5zIHRoaXMgaXMgYSBza2lwcGVkIHRva2VuXG4gICAgICAgICAgICB0aGlzLnBvcyA9IG5leHRFbmQ7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0Q29udGV4dChuZXh0LCBzdGFydCk7XG4gICAgICAgICAgICBpZiAobmV4dCA8PSB0aGlzLnAucGFyc2VyLm1heE5vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChuZXh0LCBzdGFydCwgbmV4dEVuZCwgNCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYW4gYWN0aW9uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGFwcGx5KGFjdGlvbiwgbmV4dCwgbmV4dEVuZCkge1xuICAgICAgICBpZiAoYWN0aW9uICYgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8pXG4gICAgICAgICAgICB0aGlzLnJlZHVjZShhY3Rpb24pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnNoaWZ0KGFjdGlvbiwgbmV4dCwgbmV4dEVuZCk7XG4gICAgfVxuICAgIC8vIEFkZCBhIHByZWJ1aWx0IChyZXVzZWQpIG5vZGUgaW50byB0aGUgYnVmZmVyLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB1c2VOb2RlKHZhbHVlLCBuZXh0KSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMucC5yZXVzZWQubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCB0aGlzLnAucmV1c2VkW2luZGV4XSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5wLnJldXNlZC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucmVkdWNlUG9zID0gdGhpcy5wb3MgPSBzdGFydCArIHZhbHVlLmxlbmd0aDtcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUobmV4dCwgc3RhcnQpO1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKGluZGV4LCBzdGFydCwgdGhpcy5yZWR1Y2VQb3MsIC0xIC8qIHNpemUgPT0gLTEgbWVhbnMgdGhpcyBpcyBhIHJldXNlZCB2YWx1ZSAqLyk7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIucmV1c2UodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHZhbHVlLCB0aGlzLCB0aGlzLnAuc3RyZWFtLnJlc2V0KHRoaXMucG9zIC0gdmFsdWUubGVuZ3RoKSkpO1xuICAgIH1cbiAgICAvLyBTcGxpdCB0aGUgc3RhY2suIER1ZSB0byB0aGUgYnVmZmVyIHNoYXJpbmcgYW5kIHRoZSBmYWN0XG4gICAgLy8gdGhhdCBgdGhpcy5zdGFja2AgdGVuZHMgdG8gc3RheSBxdWl0ZSBzaGFsbG93LCB0aGlzIGlzbid0IHZlcnlcbiAgICAvLyBleHBlbnNpdmUuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNwbGl0KCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcztcbiAgICAgICAgbGV0IG9mZiA9IHBhcmVudC5idWZmZXIubGVuZ3RoO1xuICAgICAgICAvLyBCZWNhdXNlIHRoZSB0b3Agb2YgdGhlIGJ1ZmZlciAoYWZ0ZXIgdGhpcy5wb3MpIG1heSBiZSBtdXRhdGVkXG4gICAgICAgIC8vIHRvIHJlb3JkZXIgcmVkdWN0aW9ucyBhbmQgc2tpcHBlZCB0b2tlbnMsIGFuZCBzaGFyZWQgYnVmZmVyc1xuICAgICAgICAvLyBzaG91bGQgYmUgaW1tdXRhYmxlLCB0aGlzIGNvcGllcyBhbnkgb3V0c3RhbmRpbmcgc2tpcHBlZCB0b2tlbnNcbiAgICAgICAgLy8gdG8gdGhlIG5ldyBidWZmZXIsIGFuZCBwdXRzIHRoZSBiYXNlIHBvaW50ZXIgYmVmb3JlIHRoZW0uXG4gICAgICAgIHdoaWxlIChvZmYgPiAwICYmIHBhcmVudC5idWZmZXJbb2ZmIC0gMl0gPiBwYXJlbnQucmVkdWNlUG9zKVxuICAgICAgICAgICAgb2ZmIC09IDQ7XG4gICAgICAgIGxldCBidWZmZXIgPSBwYXJlbnQuYnVmZmVyLnNsaWNlKG9mZiksIGJhc2UgPSBwYXJlbnQuYnVmZmVyQmFzZSArIG9mZjtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHBhcmVudCBwb2ludHMgdG8gYW4gYWN0dWFsIHBhcmVudCB3aXRoIGNvbnRlbnQsIGlmIHRoZXJlIGlzIHN1Y2ggYSBwYXJlbnQuXG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgYmFzZSA9PSBwYXJlbnQuYnVmZmVyQmFzZSlcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2sodGhpcy5wLCB0aGlzLnN0YWNrLnNsaWNlKCksIHRoaXMuc3RhdGUsIHRoaXMucmVkdWNlUG9zLCB0aGlzLnBvcywgdGhpcy5zY29yZSwgYnVmZmVyLCBiYXNlLCB0aGlzLmN1ckNvbnRleHQsIHRoaXMubG9va0FoZWFkLCBwYXJlbnQpO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gcmVjb3ZlciBmcm9tIGFuIGVycm9yIGJ5ICdkZWxldGluZycgKGlnbm9yaW5nKSBvbmUgdG9rZW4uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlY292ZXJCeURlbGV0ZShuZXh0LCBuZXh0RW5kKSB7XG4gICAgICAgIGxldCBpc05vZGUgPSBuZXh0IDw9IHRoaXMucC5wYXJzZXIubWF4Tm9kZTtcbiAgICAgICAgaWYgKGlzTm9kZSlcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKG5leHQsIHRoaXMucG9zLCBuZXh0RW5kLCA0KTtcbiAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBUZXJtLkVyciAqLywgdGhpcy5wb3MsIG5leHRFbmQsIGlzTm9kZSA/IDggOiA0KTtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnJlZHVjZVBvcyA9IG5leHRFbmQ7XG4gICAgICAgIHRoaXMuc2NvcmUgLT0gMTkwIC8qIFJlY292ZXIuRGVsZXRlICovO1xuICAgIH1cbiAgICAvLy8gQ2hlY2sgaWYgdGhlIGdpdmVuIHRlcm0gd291bGQgYmUgYWJsZSB0byBiZSBzaGlmdGVkIChvcHRpb25hbGx5XG4gICAgLy8vIGFmdGVyIHNvbWUgcmVkdWN0aW9ucykgb24gdGhpcyBzdGFjay4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvclxuICAgIC8vLyBleHRlcm5hbCB0b2tlbml6ZXJzIHRoYXQgd2FudCB0byBtYWtlIHN1cmUgdGhleSBvbmx5IHByb3ZpZGUgYVxuICAgIC8vLyBnaXZlbiB0b2tlbiB3aGVuIGl0IGFwcGxpZXMuXG4gICAgY2FuU2hpZnQodGVybSkge1xuICAgICAgICBmb3IgKGxldCBzaW0gPSBuZXcgU2ltdWxhdGVkU3RhY2sodGhpcyk7Oykge1xuICAgICAgICAgICAgbGV0IGFjdGlvbiA9IHRoaXMucC5wYXJzZXIuc3RhdGVTbG90KHNpbS5zdGF0ZSwgNCAvKiBQYXJzZVN0YXRlLkRlZmF1bHRSZWR1Y2UgKi8pIHx8IHRoaXMucC5wYXJzZXIuaGFzQWN0aW9uKHNpbS5zdGF0ZSwgdGVybSk7XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKChhY3Rpb24gJiA2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLykgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHNpbS5yZWR1Y2UoYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSB1cCB0byBSZWNvdmVyLk1heE5leHQgcmVjb3ZlcnkgYWN0aW9ucyB0aGF0IGNvbmNlcHR1YWxseVxuICAgIC8vIGluc2VydHMgc29tZSBtaXNzaW5nIHRva2VuIG9yIHJ1bGUuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlY292ZXJCeUluc2VydChuZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA+PSAzMDAgLyogUmVjb3Zlci5NYXhJbnNlcnRTdGFja0RlcHRoICovKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBsZXQgbmV4dFN0YXRlcyA9IHRoaXMucC5wYXJzZXIubmV4dFN0YXRlcyh0aGlzLnN0YXRlKTtcbiAgICAgICAgaWYgKG5leHRTdGF0ZXMubGVuZ3RoID4gNCAvKiBSZWNvdmVyLk1heE5leHQgKi8gPDwgMSB8fCB0aGlzLnN0YWNrLmxlbmd0aCA+PSAxMjAgLyogUmVjb3Zlci5EYW1wZW5JbnNlcnRTdGFja0RlcHRoICovKSB7XG4gICAgICAgICAgICBsZXQgYmVzdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHM7IGkgPCBuZXh0U3RhdGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKChzID0gbmV4dFN0YXRlc1tpICsgMV0pICE9IHRoaXMuc3RhdGUgJiYgdGhpcy5wLnBhcnNlci5oYXNBY3Rpb24ocywgbmV4dCkpXG4gICAgICAgICAgICAgICAgICAgIGJlc3QucHVzaChuZXh0U3RhdGVzW2ldLCBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEyMCAvKiBSZWNvdmVyLkRhbXBlbkluc2VydFN0YWNrRGVwdGggKi8pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGJlc3QubGVuZ3RoIDwgNCAvKiBSZWNvdmVyLk1heE5leHQgKi8gPDwgMSAmJiBpIDwgbmV4dFN0YXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IG5leHRTdGF0ZXNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJlc3Quc29tZSgodiwgaSkgPT4gKGkgJiAxKSAmJiB2ID09IHMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdC5wdXNoKG5leHRTdGF0ZXNbaV0sIHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRTdGF0ZXMgPSBiZXN0O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0U3RhdGVzLmxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgNCAvKiBSZWNvdmVyLk1heE5leHQgKi87IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IHMgPSBuZXh0U3RhdGVzW2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChzID09IHRoaXMuc3RhdGUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSB0aGlzLnNwbGl0KCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoU3RhdGUocywgdGhpcy5wb3MpO1xuICAgICAgICAgICAgc3RhY2suc3RvcmVOb2RlKDAgLyogVGVybS5FcnIgKi8sIHN0YWNrLnBvcywgc3RhY2sucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHN0YWNrLnNoaWZ0Q29udGV4dChuZXh0U3RhdGVzW2ldLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICBzdGFjay5zY29yZSAtPSAyMDAgLyogUmVjb3Zlci5JbnNlcnQgKi87XG4gICAgICAgICAgICByZXN1bHQucHVzaChzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRm9yY2UgYSByZWR1Y2UsIGlmIHBvc3NpYmxlLiBSZXR1cm4gZmFsc2UgaWYgdGhhdCBjYW4ndFxuICAgIC8vIGJlIGRvbmUuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZvcmNlUmVkdWNlKCkge1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgbGV0IHJlZHVjZSA9IHBhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgNSAvKiBQYXJzZVN0YXRlLkZvcmNlZFJlZHVjZSAqLyk7XG4gICAgICAgIGlmICgocmVkdWNlICYgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8pID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghcGFyc2VyLnZhbGlkQWN0aW9uKHRoaXMuc3RhdGUsIHJlZHVjZSkpIHtcbiAgICAgICAgICAgIGxldCBkZXB0aCA9IHJlZHVjZSA+PiAxOSAvKiBBY3Rpb24uUmVkdWNlRGVwdGhTaGlmdCAqLywgdGVybSA9IHJlZHVjZSAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi87XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5zdGFjay5sZW5ndGggLSBkZXB0aCAqIDM7XG4gICAgICAgICAgICBpZiAodGFyZ2V0IDwgMCB8fCBwYXJzZXIuZ2V0R290byh0aGlzLnN0YWNrW3RhcmdldF0sIHRlcm0sIGZhbHNlKSA8IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgYmFja3VwID0gdGhpcy5maW5kRm9yY2VkUmVkdWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGJhY2t1cCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVkdWNlID0gYmFja3VwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBUZXJtLkVyciAqLywgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgLT0gMTAwIC8qIFJlY292ZXIuUmVkdWNlICovO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVkdWNlUG9zID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucmVkdWNlKHJlZHVjZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLy8gVHJ5IHRvIHNjYW4gdGhyb3VnaCB0aGUgYXV0b21hdG9uIHRvIGZpbmQgc29tZSBraW5kIG9mIHJlZHVjdGlvblxuICAgIC8vLyB0aGF0IGNhbiBiZSBhcHBsaWVkLiBVc2VkIHdoZW4gdGhlIHJlZ3VsYXIgRm9yY2VkUmVkdWNlIGZpZWxkXG4gICAgLy8vIGlzbid0IGEgdmFsaWQgYWN0aW9uLiBAaW50ZXJuYWxcbiAgICBmaW5kRm9yY2VkUmVkdWN0aW9uKCkge1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucCwgc2VlbiA9IFtdO1xuICAgICAgICBsZXQgZXhwbG9yZSA9IChzdGF0ZSwgZGVwdGgpID0+IHtcbiAgICAgICAgICAgIGlmIChzZWVuLmluY2x1ZGVzKHN0YXRlKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZWVuLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlci5hbGxBY3Rpb25zKHN0YXRlLCAoYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAmICgyNjIxNDQgLyogQWN0aW9uLlN0YXlGbGFnICovIHwgMTMxMDcyIC8qIEFjdGlvbi5Hb3RvRmxhZyAqLykpIDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhY3Rpb24gJiA2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgckRlcHRoID0gKGFjdGlvbiA+PiAxOSAvKiBBY3Rpb24uUmVkdWNlRGVwdGhTaGlmdCAqLykgLSBkZXB0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJEZXB0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXJtID0gYWN0aW9uICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLywgdGFyZ2V0ID0gdGhpcy5zdGFjay5sZW5ndGggLSByRGVwdGggKiAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCA+PSAwICYmIHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGFyZ2V0XSwgdGVybSwgZmFsc2UpID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChyRGVwdGggPDwgMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi8pIHwgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8gfCB0ZXJtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBleHBsb3JlKGFjdGlvbiwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBleHBsb3JlKHRoaXMuc3RhdGUsIDApO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZm9yY2VBbGwoKSB7XG4gICAgICAgIHdoaWxlICghdGhpcy5wLnBhcnNlci5zdGF0ZUZsYWcodGhpcy5zdGF0ZSwgMiAvKiBTdGF0ZUZsYWcuQWNjZXB0aW5nICovKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZvcmNlUmVkdWNlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIFRlcm0uRXJyICovLCB0aGlzLnBvcywgdGhpcy5wb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLy8gQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGhhcyBubyBmdXJ0aGVyIGFjdGlvbnMgKGFzc3VtZWQgdG8gYmUgYSBkaXJlY3QgZGVzY2VuZGFudCBvZiB0aGVcbiAgICAvLy8gdG9wIHN0YXRlLCBzaW5jZSBhbnkgb3RoZXIgc3RhdGVzIG11c3QgYmUgYWJsZSB0byBjb250aW51ZVxuICAgIC8vLyBzb21laG93KS4gQGludGVybmFsXG4gICAgZ2V0IGRlYWRFbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCAhPSAzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5kYXRhW3BhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovICYmXG4gICAgICAgICAgICAhcGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCA0IC8qIFBhcnNlU3RhdGUuRGVmYXVsdFJlZHVjZSAqLyk7XG4gICAgfVxuICAgIC8vLyBSZXN0YXJ0IHRoZSBzdGFjayAocHV0IGl0IGJhY2sgaW4gaXRzIHN0YXJ0IHN0YXRlKS4gT25seSBzYWZlXG4gICAgLy8vIHdoZW4gdGhpcy5zdGFjay5sZW5ndGggPT0gMyAoc3RhdGUgaXMgZGlyZWN0bHkgYmVsb3cgdGhlIHRvcFxuICAgIC8vLyBzdGF0ZSkuIEBpbnRlcm5hbFxuICAgIHJlc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YWNrWzBdO1xuICAgICAgICB0aGlzLnN0YWNrLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzYW1lU3RhdGUob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT0gb3RoZXIuc3RhdGUgfHwgdGhpcy5zdGFjay5sZW5ndGggIT0gb3RoZXIuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhY2subGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFja1tpXSAhPSBvdGhlci5zdGFja1tpXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBwYXJzZXIgdXNlZCBieSB0aGlzIHN0YWNrLlxuICAgIGdldCBwYXJzZXIoKSB7IHJldHVybiB0aGlzLnAucGFyc2VyOyB9XG4gICAgLy8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGRpYWxlY3QgKGJ5IG51bWVyaWMgSUQsIGFzIGV4cG9ydGVkIGZyb21cbiAgICAvLy8gdGhlIHRlcm1zIGZpbGUpIGlzIGVuYWJsZWQuXG4gICAgZGlhbGVjdEVuYWJsZWQoZGlhbGVjdElEKSB7IHJldHVybiB0aGlzLnAucGFyc2VyLmRpYWxlY3QuZmxhZ3NbZGlhbGVjdElEXTsgfVxuICAgIHNoaWZ0Q29udGV4dCh0ZXJtLCBzdGFydCkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0KVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnNoaWZ0KHRoaXMuY3VyQ29udGV4dC5jb250ZXh0LCB0ZXJtLCB0aGlzLCB0aGlzLnAuc3RyZWFtLnJlc2V0KHN0YXJ0KSkpO1xuICAgIH1cbiAgICByZWR1Y2VDb250ZXh0KHRlcm0sIHN0YXJ0KSB7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIucmVkdWNlKHRoaXMuY3VyQ29udGV4dC5jb250ZXh0LCB0ZXJtLCB0aGlzLCB0aGlzLnAuc3RyZWFtLnJlc2V0KHN0YXJ0KSkpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZW1pdENvbnRleHQoKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5idWZmZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPCAwIHx8IHRoaXMuYnVmZmVyW2xhc3RdICE9IC0zKVxuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0aGlzLmN1ckNvbnRleHQuaGFzaCwgdGhpcy5wb3MsIHRoaXMucG9zLCAtMyk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBlbWl0TG9va0FoZWFkKCkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuYnVmZmVyLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0IDwgMCB8fCB0aGlzLmJ1ZmZlcltsYXN0XSAhPSAtNClcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godGhpcy5sb29rQWhlYWQsIHRoaXMucG9zLCB0aGlzLnBvcywgLTQpO1xuICAgIH1cbiAgICB1cGRhdGVDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgIT0gdGhpcy5jdXJDb250ZXh0LmNvbnRleHQpIHtcbiAgICAgICAgICAgIGxldCBuZXdDeCA9IG5ldyBTdGFja0NvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKG5ld0N4Lmhhc2ggIT0gdGhpcy5jdXJDb250ZXh0Lmhhc2gpXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0Q29udGV4dCgpO1xuICAgICAgICAgICAgdGhpcy5jdXJDb250ZXh0ID0gbmV3Q3g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNldExvb2tBaGVhZChsb29rQWhlYWQpIHtcbiAgICAgICAgaWYgKGxvb2tBaGVhZCA+IHRoaXMubG9va0FoZWFkKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRMb29rQWhlYWQoKTtcbiAgICAgICAgICAgIHRoaXMubG9va0FoZWFkID0gbG9va0FoZWFkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dCAmJiB0aGlzLmN1ckNvbnRleHQudHJhY2tlci5zdHJpY3QpXG4gICAgICAgICAgICB0aGlzLmVtaXRDb250ZXh0KCk7XG4gICAgICAgIGlmICh0aGlzLmxvb2tBaGVhZCA+IDApXG4gICAgICAgICAgICB0aGlzLmVtaXRMb29rQWhlYWQoKTtcbiAgICB9XG59XG5jbGFzcyBTdGFja0NvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHRyYWNrZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy50cmFja2VyID0gdHJhY2tlcjtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5oYXNoID0gdHJhY2tlci5zdHJpY3QgPyB0cmFja2VyLmhhc2goY29udGV4dCkgOiAwO1xuICAgIH1cbn1cbnZhciBSZWNvdmVyO1xuKGZ1bmN0aW9uIChSZWNvdmVyKSB7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiSW5zZXJ0XCJdID0gMjAwXSA9IFwiSW5zZXJ0XCI7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiRGVsZXRlXCJdID0gMTkwXSA9IFwiRGVsZXRlXCI7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiUmVkdWNlXCJdID0gMTAwXSA9IFwiUmVkdWNlXCI7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiTWF4TmV4dFwiXSA9IDRdID0gXCJNYXhOZXh0XCI7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiTWF4SW5zZXJ0U3RhY2tEZXB0aFwiXSA9IDMwMF0gPSBcIk1heEluc2VydFN0YWNrRGVwdGhcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJEYW1wZW5JbnNlcnRTdGFja0RlcHRoXCJdID0gMTIwXSA9IFwiRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aFwiO1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIk1pbkJpZ1JlZHVjdGlvblwiXSA9IDIwMDBdID0gXCJNaW5CaWdSZWR1Y3Rpb25cIjtcbn0pKFJlY292ZXIgfHwgKFJlY292ZXIgPSB7fSkpO1xuLy8gVXNlZCB0byBjaGVhcGx5IHJ1biBzb21lIHJlZHVjdGlvbnMgdG8gc2NhbiBhaGVhZCB3aXRob3V0IG11dGF0aW5nXG4vLyBhbiBlbnRpcmUgc3RhY2tcbmNsYXNzIFNpbXVsYXRlZFN0YWNrIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGFydC5zdGF0ZTtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YXJ0LnN0YWNrO1xuICAgICAgICB0aGlzLmJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgICB9XG4gICAgcmVkdWNlKGFjdGlvbikge1xuICAgICAgICBsZXQgdGVybSA9IGFjdGlvbiAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi8sIGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIEFjdGlvbi5SZWR1Y2VEZXB0aFNoaWZ0ICovO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2sgPT0gdGhpcy5zdGFydC5zdGFjaylcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gdGhpcy5zdGFjay5zbGljZSgpO1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuc3RhdGUsIDAsIDApO1xuICAgICAgICAgICAgdGhpcy5iYXNlICs9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgLT0gKGRlcHRoIC0gMSkgKiAzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBnb3RvID0gdGhpcy5zdGFydC5wLnBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGhpcy5iYXNlIC0gM10sIHRlcm0sIHRydWUpO1xuICAgICAgICB0aGlzLnN0YXRlID0gZ290bztcbiAgICB9XG59XG4vLyBUaGlzIGlzIGdpdmVuIHRvIGBUcmVlLmJ1aWxkYCB0byBidWlsZCBhIGJ1ZmZlciwgYW5kIGVuY2Fwc3VsYXRlc1xuLy8gdGhlIHBhcmVudC1zdGFjay13YWxraW5nIG5lY2Vzc2FyeSB0byByZWFkIHRoZSBub2Rlcy5cbmNsYXNzIFN0YWNrQnVmZmVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFjaywgcG9zLCBpbmRleCkge1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gc3RhY2suYnVmZmVyO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5tYXliZU5leHQoKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShzdGFjaywgcG9zID0gc3RhY2suYnVmZmVyQmFzZSArIHN0YWNrLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0J1ZmZlckN1cnNvcihzdGFjaywgcG9zLCBwb3MgLSBzdGFjay5idWZmZXJCYXNlKTtcbiAgICB9XG4gICAgbWF5YmVOZXh0KCkge1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMuc3RhY2sucGFyZW50O1xuICAgICAgICBpZiAobmV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5zdGFjay5idWZmZXJCYXNlIC0gbmV4dC5idWZmZXJCYXNlO1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IG5leHQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5leHQuYnVmZmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSA0XTsgfVxuICAgIGdldCBzdGFydCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAzXTsgfVxuICAgIGdldCBlbmQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMl07IH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAxXTsgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMuaW5kZXggLT0gNDtcbiAgICAgICAgdGhpcy5wb3MgLT0gNDtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gMClcbiAgICAgICAgICAgIHRoaXMubWF5YmVOZXh0KCk7XG4gICAgfVxuICAgIGZvcmsoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tCdWZmZXJDdXJzb3IodGhpcy5zdGFjaywgdGhpcy5wb3MsIHRoaXMuaW5kZXgpO1xuICAgIH1cbn1cblxuLy8gU2VlIGxlemVyLWdlbmVyYXRvci9zcmMvZW5jb2RlLnRzIGZvciBjb21tZW50cyBhYm91dCB0aGUgZW5jb2Rpbmdcbi8vIHVzZWQgaGVyZVxuZnVuY3Rpb24gZGVjb2RlQXJyYXkoaW5wdXQsIFR5cGUgPSBVaW50MTZBcnJheSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIGxldCBhcnJheSA9IG51bGw7XG4gICAgZm9yIChsZXQgcG9zID0gMCwgb3V0ID0gMDsgcG9zIDwgaW5wdXQubGVuZ3RoOykge1xuICAgICAgICBsZXQgdmFsdWUgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQocG9zKyspLCBzdG9wID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobmV4dCA9PSAxMjYgLyogRW5jb2RlLkJpZ1ZhbENvZGUgKi8pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDY1NTM1IC8qIEVuY29kZS5CaWdWYWwgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCA+PSA5MiAvKiBFbmNvZGUuR2FwMiAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBpZiAobmV4dCA+PSAzNCAvKiBFbmNvZGUuR2FwMSAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBsZXQgZGlnaXQgPSBuZXh0IC0gMzIgLyogRW5jb2RlLlN0YXJ0ICovO1xuICAgICAgICAgICAgaWYgKGRpZ2l0ID49IDQ2IC8qIEVuY29kZS5CYXNlICovKSB7XG4gICAgICAgICAgICAgICAgZGlnaXQgLT0gNDYgLyogRW5jb2RlLkJhc2UgKi87XG4gICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSArPSBkaWdpdDtcbiAgICAgICAgICAgIGlmIChzdG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmFsdWUgKj0gNDYgLyogRW5jb2RlLkJhc2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFycmF5KVxuICAgICAgICAgICAgYXJyYXlbb3V0KytdID0gdmFsdWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGFycmF5ID0gbmV3IFR5cGUodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbmNsYXNzIENhY2hlZFRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IC0xO1xuICAgICAgICB0aGlzLnZhbHVlID0gLTE7XG4gICAgICAgIHRoaXMuZW5kID0gLTE7XG4gICAgICAgIHRoaXMuZXh0ZW5kZWQgPSAtMTtcbiAgICAgICAgdGhpcy5sb29rQWhlYWQgPSAwO1xuICAgICAgICB0aGlzLm1hc2sgPSAwO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSAwO1xuICAgIH1cbn1cbmNvbnN0IG51bGxUb2tlbiA9IG5ldyBDYWNoZWRUb2tlbjtcbi8vLyBbVG9rZW5pemVyc10oI2xyLkV4dGVybmFsVG9rZW5pemVyKSBpbnRlcmFjdCB3aXRoIHRoZSBpbnB1dFxuLy8vIHRocm91Z2ggdGhpcyBpbnRlcmZhY2UuIEl0IHByZXNlbnRzIHRoZSBpbnB1dCBhcyBhIHN0cmVhbSBvZlxuLy8vIGNoYXJhY3RlcnMsIHRyYWNraW5nIGxvb2thaGVhZCBhbmQgaGlkaW5nIHRoZSBjb21wbGV4aXR5IG9mXG4vLy8gW3Jhbmdlc10oI2NvbW1vbi5QYXJzZXIucGFyc2VecmFuZ2VzKSBmcm9tIHRva2VuaXplciBjb2RlLlxuY2xhc3MgSW5wdXRTdHJlYW0ge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gQGludGVybmFsXG4gICAgaW5wdXQsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLmNodW5rID0gXCJcIjtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLmNodW5rT2ZmID0gMDtcbiAgICAgICAgLy8vIEJhY2t1cCBjaHVua1xuICAgICAgICB0aGlzLmNodW5rMiA9IFwiXCI7XG4gICAgICAgIHRoaXMuY2h1bmsyUG9zID0gMDtcbiAgICAgICAgLy8vIFRoZSBjaGFyYWN0ZXIgY29kZSBvZiB0aGUgbmV4dCBjb2RlIHVuaXQgaW4gdGhlIGlucHV0LCBvciAtMVxuICAgICAgICAvLy8gd2hlbiB0aGUgc3RyZWFtIGlzIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0LlxuICAgICAgICB0aGlzLm5leHQgPSAtMTtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLnRva2VuID0gbnVsbFRva2VuO1xuICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IHRoaXMuY2h1bmtQb3MgPSByYW5nZXNbMF0uZnJvbTtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlc1swXTtcbiAgICAgICAgdGhpcy5lbmQgPSByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgICAgICB0aGlzLnJlYWROZXh0KCk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZXNvbHZlT2Zmc2V0KG9mZnNldCwgYXNzb2MpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5yYW5nZSwgaW5kZXggPSB0aGlzLnJhbmdlSW5kZXg7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnBvcyArIG9mZnNldDtcbiAgICAgICAgd2hpbGUgKHBvcyA8IHJhbmdlLmZyb20pIHtcbiAgICAgICAgICAgIGlmICghaW5kZXgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucmFuZ2VzWy0taW5kZXhdO1xuICAgICAgICAgICAgcG9zIC09IHJhbmdlLmZyb20gLSBuZXh0LnRvO1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhc3NvYyA8IDAgPyBwb3MgPiByYW5nZS50byA6IHBvcyA+PSByYW5nZS50bykge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucmFuZ2VzWysraW5kZXhdO1xuICAgICAgICAgICAgcG9zICs9IG5leHQuZnJvbSAtIHJhbmdlLnRvO1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjbGlwUG9zKHBvcykge1xuICAgICAgICBpZiAocG9zID49IHRoaXMucmFuZ2UuZnJvbSAmJiBwb3MgPCB0aGlzLnJhbmdlLnRvKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgZm9yIChsZXQgcmFuZ2Ugb2YgdGhpcy5yYW5nZXMpXG4gICAgICAgICAgICBpZiAocmFuZ2UudG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHBvcywgcmFuZ2UuZnJvbSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZDtcbiAgICB9XG4gICAgLy8vIExvb2sgYXQgYSBjb2RlIHVuaXQgbmVhciB0aGUgc3RyZWFtIHBvc2l0aW9uLiBgLnBlZWsoMClgIGVxdWFsc1xuICAgIC8vLyBgLm5leHRgLCBgLnBlZWsoLTEpYCBnaXZlcyB5b3UgdGhlIHByZXZpb3VzIGNoYXJhY3RlciwgYW5kIHNvXG4gICAgLy8vIG9uLlxuICAgIC8vL1xuICAgIC8vLyBOb3RlIHRoYXQgbG9va2luZyBhcm91bmQgZHVyaW5nIHRva2VuaXppbmcgY3JlYXRlcyBkZXBlbmRlbmNpZXNcbiAgICAvLy8gb24gcG90ZW50aWFsbHkgZmFyLWF3YXkgY29udGVudCwgd2hpY2ggbWF5IHJlZHVjZSB0aGVcbiAgICAvLy8gZWZmZWN0aXZlbmVzcyBpbmNyZW1lbnRhbCBwYXJzaW5n4oCUd2hlbiBsb29raW5nIGZvcndhcmTigJRvciBldmVuXG4gICAgLy8vIGNhdXNlIGludmFsaWQgcmVwYXJzZXMgd2hlbiBsb29raW5nIGJhY2t3YXJkIG1vcmUgdGhhbiAyNSBjb2RlXG4gICAgLy8vIHVuaXRzLCBzaW5jZSB0aGUgbGlicmFyeSBkb2VzIG5vdCB0cmFjayBsb29rYmVoaW5kLlxuICAgIHBlZWsob2Zmc2V0KSB7XG4gICAgICAgIGxldCBpZHggPSB0aGlzLmNodW5rT2ZmICsgb2Zmc2V0LCBwb3MsIHJlc3VsdDtcbiAgICAgICAgaWYgKGlkeCA+PSAwICYmIGlkeCA8IHRoaXMuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLnBvcyArIG9mZnNldDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2h1bmsuY2hhckNvZGVBdChpZHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkID0gdGhpcy5yZXNvbHZlT2Zmc2V0KG9mZnNldCwgMSk7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBwb3MgPSByZXNvbHZlZDtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdGhpcy5jaHVuazJQb3MgJiYgcG9zIDwgdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rMi5jaGFyQ29kZUF0KHBvcyAtIHRoaXMuY2h1bmsyUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBpID0gdGhpcy5yYW5nZUluZGV4LCByYW5nZSA9IHRoaXMucmFuZ2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJhbmdlLnRvIDw9IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLnJhbmdlc1srK2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gdGhpcy5pbnB1dC5jaHVuayh0aGlzLmNodW5rMlBvcyA9IHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aCA+IHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuY2h1bmsyLnNsaWNlKDAsIHJhbmdlLnRvIC0gcG9zKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rMi5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPj0gdGhpcy50b2tlbi5sb29rQWhlYWQpXG4gICAgICAgICAgICB0aGlzLnRva2VuLmxvb2tBaGVhZCA9IHBvcyArIDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vLyBBY2NlcHQgYSB0b2tlbi4gQnkgZGVmYXVsdCwgdGhlIGVuZCBvZiB0aGUgdG9rZW4gaXMgc2V0IHRvIHRoZVxuICAgIC8vLyBjdXJyZW50IHN0cmVhbSBwb3NpdGlvbiwgYnV0IHlvdSBjYW4gcGFzcyBhbiBvZmZzZXQgKHJlbGF0aXZlIHRvXG4gICAgLy8vIHRoZSBzdHJlYW0gcG9zaXRpb24pIHRvIGNoYW5nZSB0aGF0LlxuICAgIGFjY2VwdFRva2VuKHRva2VuLCBlbmRPZmZzZXQgPSAwKSB7XG4gICAgICAgIGxldCBlbmQgPSBlbmRPZmZzZXQgPyB0aGlzLnJlc29sdmVPZmZzZXQoZW5kT2Zmc2V0LCAtMSkgOiB0aGlzLnBvcztcbiAgICAgICAgaWYgKGVuZCA9PSBudWxsIHx8IGVuZCA8IHRoaXMudG9rZW4uc3RhcnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRva2VuIGVuZCBvdXQgb2YgYm91bmRzXCIpO1xuICAgICAgICB0aGlzLnRva2VuLnZhbHVlID0gdG9rZW47XG4gICAgICAgIHRoaXMudG9rZW4uZW5kID0gZW5kO1xuICAgIH1cbiAgICBnZXRDaHVuaygpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMuY2h1bmsyUG9zICYmIHRoaXMucG9zIDwgdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCB7IGNodW5rLCBjaHVua1BvcyB9ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmsgPSB0aGlzLmNodW5rMjtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtQb3MgPSB0aGlzLmNodW5rMlBvcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gY2h1bms7XG4gICAgICAgICAgICB0aGlzLmNodW5rMlBvcyA9IGNodW5rUG9zO1xuICAgICAgICAgICAgdGhpcy5jaHVua09mZiA9IHRoaXMucG9zIC0gdGhpcy5jaHVua1BvcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gdGhpcy5jaHVuaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmsyUG9zID0gdGhpcy5jaHVua1BvcztcbiAgICAgICAgICAgIGxldCBuZXh0Q2h1bmsgPSB0aGlzLmlucHV0LmNodW5rKHRoaXMucG9zKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSB0aGlzLnBvcyArIG5leHRDaHVuay5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmNodW5rID0gZW5kID4gdGhpcy5yYW5nZS50byA/IG5leHRDaHVuay5zbGljZSgwLCB0aGlzLnJhbmdlLnRvIC0gdGhpcy5wb3MpIDogbmV4dENodW5rO1xuICAgICAgICAgICAgdGhpcy5jaHVua1BvcyA9IHRoaXMucG9zO1xuICAgICAgICAgICAgdGhpcy5jaHVua09mZiA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZE5leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNodW5rT2ZmID49IHRoaXMuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmdldENodW5rKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jaHVua09mZiA9PSB0aGlzLmNodW5rLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCA9IHRoaXMuY2h1bmsuY2hhckNvZGVBdCh0aGlzLmNodW5rT2ZmKTtcbiAgICB9XG4gICAgLy8vIE1vdmUgdGhlIHN0cmVhbSBmb3J3YXJkIE4gKGRlZmF1bHRzIHRvIDEpIGNvZGUgdW5pdHMuIFJldHVybnNcbiAgICAvLy8gdGhlIG5ldyB2YWx1ZSBvZiBbYG5leHRgXSgjbHIuSW5wdXRTdHJlYW0ubmV4dCkuXG4gICAgYWR2YW5jZShuID0gMSkge1xuICAgICAgICB0aGlzLmNodW5rT2ZmICs9IG47XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyArIG4gPj0gdGhpcy5yYW5nZS50bykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmFuZ2VJbmRleCA9PSB0aGlzLnJhbmdlcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldERvbmUoKTtcbiAgICAgICAgICAgIG4gLT0gdGhpcy5yYW5nZS50byAtIHRoaXMucG9zO1xuICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzWysrdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5yYW5nZS5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zICs9IG47XG4gICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLnRva2VuLmxvb2tBaGVhZClcbiAgICAgICAgICAgIHRoaXMudG9rZW4ubG9va0FoZWFkID0gdGhpcy5wb3MgKyAxO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkTmV4dCgpO1xuICAgIH1cbiAgICBzZXREb25lKCkge1xuICAgICAgICB0aGlzLnBvcyA9IHRoaXMuY2h1bmtQb3MgPSB0aGlzLmVuZDtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzW3RoaXMucmFuZ2VJbmRleCA9IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLmNodW5rID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCA9IC0xO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVzZXQocG9zLCB0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIHRva2VuLnN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgdG9rZW4ubG9va0FoZWFkID0gcG9zICsgMTtcbiAgICAgICAgICAgIHRva2VuLnZhbHVlID0gdG9rZW4uZXh0ZW5kZWQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSBudWxsVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9zICE9IHBvcykge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgICAgICBpZiAocG9zID09IHRoaXMuZW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXREb25lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgdGhpcy5yYW5nZS5mcm9tKVxuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1stLXRoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICB3aGlsZSAocG9zID49IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzWysrdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdGhpcy5jaHVua1BvcyAmJiBwb3MgPCB0aGlzLmNodW5rUG9zICsgdGhpcy5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gcG9zIC0gdGhpcy5jaHVua1BvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkTmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVhZChmcm9tLCB0bykge1xuICAgICAgICBpZiAoZnJvbSA+PSB0aGlzLmNodW5rUG9zICYmIHRvIDw9IHRoaXMuY2h1bmtQb3MgKyB0aGlzLmNodW5rLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNodW5rLnNsaWNlKGZyb20gLSB0aGlzLmNodW5rUG9zLCB0byAtIHRoaXMuY2h1bmtQb3MpO1xuICAgICAgICBpZiAoZnJvbSA+PSB0aGlzLmNodW5rMlBvcyAmJiB0byA8PSB0aGlzLmNodW5rMlBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNodW5rMi5zbGljZShmcm9tIC0gdGhpcy5jaHVuazJQb3MsIHRvIC0gdGhpcy5jaHVuazJQb3MpO1xuICAgICAgICBpZiAoZnJvbSA+PSB0aGlzLnJhbmdlLmZyb20gJiYgdG8gPD0gdGhpcy5yYW5nZS50bylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlucHV0LnJlYWQoZnJvbSwgdG8pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgciBvZiB0aGlzLnJhbmdlcykge1xuICAgICAgICAgICAgaWYgKHIuZnJvbSA+PSB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChyLnRvID4gZnJvbSlcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5pbnB1dC5yZWFkKE1hdGgubWF4KHIuZnJvbSwgZnJvbSksIE1hdGgubWluKHIudG8sIHRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLy8gQGludGVybmFsXG5jbGFzcyBUb2tlbkdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBpZCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgfVxuICAgIHRva2VuKGlucHV0LCBzdGFjaykge1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHN0YWNrLnA7XG4gICAgICAgIHJlYWRUb2tlbih0aGlzLmRhdGEsIGlucHV0LCBzdGFjaywgdGhpcy5pZCwgcGFyc2VyLmRhdGEsIHBhcnNlci50b2tlblByZWNUYWJsZSk7XG4gICAgfVxufVxuVG9rZW5Hcm91cC5wcm90b3R5cGUuY29udGV4dHVhbCA9IFRva2VuR3JvdXAucHJvdG90eXBlLmZhbGxiYWNrID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZXh0ZW5kID0gZmFsc2U7XG4vLy8gQGhpZGVcbmNsYXNzIExvY2FsVG9rZW5Hcm91cCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgcHJlY1RhYmxlLCBlbHNlVG9rZW4pIHtcbiAgICAgICAgdGhpcy5wcmVjVGFibGUgPSBwcmVjVGFibGU7XG4gICAgICAgIHRoaXMuZWxzZVRva2VuID0gZWxzZVRva2VuO1xuICAgICAgICB0aGlzLmRhdGEgPSB0eXBlb2YgZGF0YSA9PSBcInN0cmluZ1wiID8gZGVjb2RlQXJyYXkoZGF0YSkgOiBkYXRhO1xuICAgIH1cbiAgICB0b2tlbihpbnB1dCwgc3RhY2spIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gaW5wdXQucG9zLCBza2lwcGVkID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBpbnB1dC5yZXNvbHZlT2Zmc2V0KDEsIC0xKTtcbiAgICAgICAgICAgIHJlYWRUb2tlbih0aGlzLmRhdGEsIGlucHV0LCBzdGFjaywgMCwgdGhpcy5kYXRhLCB0aGlzLnByZWNUYWJsZSk7XG4gICAgICAgICAgICBpZiAoaW5wdXQudG9rZW4udmFsdWUgPiAtMSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmICh0aGlzLmVsc2VUb2tlbiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChuZXh0UG9zID09IG51bGwpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpbnB1dC5yZXNldChuZXh0UG9zLCBpbnB1dC50b2tlbik7XG4gICAgICAgICAgICBza2lwcGVkKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXBwZWQpIHtcbiAgICAgICAgICAgIGlucHV0LnJlc2V0KHN0YXJ0LCBpbnB1dC50b2tlbik7XG4gICAgICAgICAgICBpbnB1dC5hY2NlcHRUb2tlbih0aGlzLmVsc2VUb2tlbiwgc2tpcHBlZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5Mb2NhbFRva2VuR3JvdXAucHJvdG90eXBlLmNvbnRleHR1YWwgPSBUb2tlbkdyb3VwLnByb3RvdHlwZS5mYWxsYmFjayA9IFRva2VuR3JvdXAucHJvdG90eXBlLmV4dGVuZCA9IGZhbHNlO1xuLy8vIGBAZXh0ZXJuYWwgdG9rZW5zYCBkZWNsYXJhdGlvbnMgaW4gdGhlIGdyYW1tYXIgc2hvdWxkIHJlc29sdmUgdG9cbi8vLyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuY2xhc3MgRXh0ZXJuYWxUb2tlbml6ZXIge1xuICAgIC8vLyBDcmVhdGUgYSB0b2tlbml6ZXIuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgZnVuY3Rpb24gdGhhdCxcbiAgICAvLy8gZ2l2ZW4gYW4gaW5wdXQgc3RyZWFtLCBzY2FucyBmb3IgdGhlIHR5cGVzIG9mIHRva2VucyBpdFxuICAgIC8vLyByZWNvZ25pemVzIGF0IHRoZSBzdHJlYW0ncyBwb3NpdGlvbiwgYW5kIGNhbGxzXG4gICAgLy8vIFtgYWNjZXB0VG9rZW5gXSgjbHIuSW5wdXRTdHJlYW0uYWNjZXB0VG9rZW4pIHdoZW4gaXQgZmluZHNcbiAgICAvLy8gb25lLlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b2tlbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5jb250ZXh0dWFsID0gISFvcHRpb25zLmNvbnRleHR1YWw7XG4gICAgICAgIHRoaXMuZmFsbGJhY2sgPSAhIW9wdGlvbnMuZmFsbGJhY2s7XG4gICAgICAgIHRoaXMuZXh0ZW5kID0gISFvcHRpb25zLmV4dGVuZDtcbiAgICB9XG59XG4vLyBUb2tlbml6ZXIgZGF0YSBpcyBzdG9yZWQgYSBiaWcgdWludDE2IGFycmF5IGNvbnRhaW5pbmcsIGZvciBlYWNoXG4vLyBzdGF0ZTpcbi8vXG4vLyAgLSBBIGdyb3VwIGJpdG1hc2ssIGluZGljYXRpbmcgd2hhdCB0b2tlbiBncm91cHMgYXJlIHJlYWNoYWJsZSBmcm9tXG4vLyAgICB0aGlzIHN0YXRlLCBzbyB0aGF0IHBhdGhzIHRoYXQgY2FuIG9ubHkgbGVhZCB0byB0b2tlbnMgbm90IGluXG4vLyAgICBhbnkgb2YgdGhlIGN1cnJlbnQgZ3JvdXBzIGNhbiBiZSBjdXQgb2ZmIGVhcmx5LlxuLy9cbi8vICAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgZW5kIG9mIHRoZSBzdGF0ZSdzIHNlcXVlbmNlIG9mIGFjY2VwdGluZ1xuLy8gICAgdG9rZW5zXG4vL1xuLy8gIC0gVGhlIG51bWJlciBvZiBvdXRnb2luZyBlZGdlcyBmb3IgdGhlIHN0YXRlXG4vL1xuLy8gIC0gVGhlIGFjY2VwdGluZyB0b2tlbnMsIGFzICh0b2tlbiBpZCwgZ3JvdXAgbWFzaykgcGFpcnNcbi8vXG4vLyAgLSBUaGUgb3V0Z29pbmcgZWRnZXMsIGFzIChzdGFydCBjaGFyYWN0ZXIsIGVuZCBjaGFyYWN0ZXIsIHN0YXRlXG4vLyAgICBpbmRleCkgdHJpcGxlcywgd2l0aCBlbmQgY2hhcmFjdGVyIGJlaW5nIGV4Y2x1c2l2ZVxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gaW50ZXJwcmV0cyB0aGF0IGRhdGEsIHJ1bm5pbmcgdGhyb3VnaCBhIHN0cmVhbSBhc1xuLy8gbG9uZyBhcyBuZXcgc3RhdGVzIHdpdGggdGhlIGEgbWF0Y2hpbmcgZ3JvdXAgbWFzayBjYW4gYmUgcmVhY2hlZCxcbi8vIGFuZCB1cGRhdGluZyBgaW5wdXQudG9rZW5gIHdoZW4gaXQgbWF0Y2hlcyBhIHRva2VuLlxuZnVuY3Rpb24gcmVhZFRva2VuKGRhdGEsIGlucHV0LCBzdGFjaywgZ3JvdXAsIHByZWNUYWJsZSwgcHJlY09mZnNldCkge1xuICAgIGxldCBzdGF0ZSA9IDAsIGdyb3VwTWFzayA9IDEgPDwgZ3JvdXAsIHsgZGlhbGVjdCB9ID0gc3RhY2sucC5wYXJzZXI7XG4gICAgc2NhbjogZm9yICg7Oykge1xuICAgICAgICBpZiAoKGdyb3VwTWFzayAmIGRhdGFbc3RhdGVdKSA9PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBhY2NFbmQgPSBkYXRhW3N0YXRlICsgMV07XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhpcyBzdGF0ZSBjYW4gbGVhZCB0byBhIHRva2VuIGluIHRoZSBjdXJyZW50IGdyb3VwXG4gICAgICAgIC8vIEFjY2VwdCB0b2tlbnMgaW4gdGhpcyBzdGF0ZSwgcG9zc2libHkgb3ZlcndyaXRpbmdcbiAgICAgICAgLy8gbG93ZXItcHJlY2VkZW5jZSAvIHNob3J0ZXIgdG9rZW5zXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGF0ZSArIDM7IGkgPCBhY2NFbmQ7IGkgKz0gMilcbiAgICAgICAgICAgIGlmICgoZGF0YVtpICsgMV0gJiBncm91cE1hc2spID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZXJtID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoZGlhbGVjdC5hbGxvd3ModGVybSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlucHV0LnRva2VuLnZhbHVlID09IC0xIHx8IGlucHV0LnRva2VuLnZhbHVlID09IHRlcm0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlcyh0ZXJtLCBpbnB1dC50b2tlbi52YWx1ZSwgcHJlY1RhYmxlLCBwcmVjT2Zmc2V0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQuYWNjZXB0VG9rZW4odGVybSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQgPSBpbnB1dC5uZXh0LCBsb3cgPSAwLCBoaWdoID0gZGF0YVtzdGF0ZSArIDJdO1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIEVPRlxuICAgICAgICBpZiAoaW5wdXQubmV4dCA8IDAgJiYgaGlnaCA+IGxvdyAmJiBkYXRhW2FjY0VuZCArIGhpZ2ggKiAzIC0gM10gPT0gNjU1MzUgLyogU2VxLkVuZCAqLyAmJiBkYXRhW2FjY0VuZCArIGhpZ2ggKiAzIC0gM10gPT0gNjU1MzUgLyogU2VxLkVuZCAqLykge1xuICAgICAgICAgICAgc3RhdGUgPSBkYXRhW2FjY0VuZCArIGhpZ2ggKiAzIC0gMV07XG4gICAgICAgICAgICBjb250aW51ZSBzY2FuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIGEgYmluYXJ5IHNlYXJjaCBvbiB0aGUgc3RhdGUncyBlZGdlc1xuICAgICAgICBmb3IgKDsgbG93IDwgaGlnaDspIHtcbiAgICAgICAgICAgIGxldCBtaWQgPSAobG93ICsgaGlnaCkgPj4gMTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGFjY0VuZCArIG1pZCArIChtaWQgPDwgMSk7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGRhdGFbaW5kZXhdLCB0byA9IGRhdGFbaW5kZXggKyAxXSB8fCAweDEwMDAwO1xuICAgICAgICAgICAgaWYgKG5leHQgPCBmcm9tKVxuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ID49IHRvKVxuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGRhdGFbaW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgY29udGludWUgc2NhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kT2Zmc2V0KGRhdGEsIHN0YXJ0LCB0ZXJtKSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0LCBuZXh0OyAobmV4dCA9IGRhdGFbaV0pICE9IDY1NTM1IC8qIFNlcS5FbmQgKi87IGkrKylcbiAgICAgICAgaWYgKG5leHQgPT0gdGVybSlcbiAgICAgICAgICAgIHJldHVybiBpIC0gc3RhcnQ7XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gb3ZlcnJpZGVzKHRva2VuLCBwcmV2LCB0YWJsZURhdGEsIHRhYmxlT2Zmc2V0KSB7XG4gICAgbGV0IGlQcmV2ID0gZmluZE9mZnNldCh0YWJsZURhdGEsIHRhYmxlT2Zmc2V0LCBwcmV2KTtcbiAgICByZXR1cm4gaVByZXYgPCAwIHx8IGZpbmRPZmZzZXQodGFibGVEYXRhLCB0YWJsZU9mZnNldCwgdG9rZW4pIDwgaVByZXY7XG59XG5cbi8vIEVudmlyb25tZW50IHZhcmlhYmxlIHVzZWQgdG8gY29udHJvbCBjb25zb2xlIG91dHB1dFxuY29uc3QgdmVyYm9zZSA9IHR5cGVvZiBwcm9jZXNzICE9IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYgJiYgL1xcYnBhcnNlXFxiLy50ZXN0KHByb2Nlc3MuZW52LkxPRyk7XG5sZXQgc3RhY2tJRHMgPSBudWxsO1xudmFyIFNhZmV0eTtcbihmdW5jdGlvbiAoU2FmZXR5KSB7XG4gICAgU2FmZXR5W1NhZmV0eVtcIk1hcmdpblwiXSA9IDI1XSA9IFwiTWFyZ2luXCI7XG59KShTYWZldHkgfHwgKFNhZmV0eSA9IHt9KSk7XG5mdW5jdGlvbiBjdXRBdCh0cmVlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgY3Vyc29yID0gdHJlZS5jdXJzb3IoSXRlck1vZGUuSW5jbHVkZUFub255bW91cyk7XG4gICAgY3Vyc29yLm1vdmVUbyhwb3MpO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKCEoc2lkZSA8IDAgPyBjdXJzb3IuY2hpbGRCZWZvcmUocG9zKSA6IGN1cnNvci5jaGlsZEFmdGVyKHBvcykpKVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA8IDAgPyBjdXJzb3IudG8gPCBwb3MgOiBjdXJzb3IuZnJvbSA+IHBvcykgJiYgIWN1cnNvci50eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlIDwgMCA/IE1hdGgubWF4KDAsIE1hdGgubWluKGN1cnNvci50byAtIDEsIHBvcyAtIDI1IC8qIFNhZmV0eS5NYXJnaW4gKi8pKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1pbih0cmVlLmxlbmd0aCwgTWF0aC5tYXgoY3Vyc29yLmZyb20gKyAxLCBwb3MgKyAyNSAvKiBTYWZldHkuTWFyZ2luICovKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwID8gY3Vyc29yLnByZXZTaWJsaW5nKCkgOiBjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlIDwgMCA/IDAgOiB0cmVlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBGcmFnbWVudEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzLCBub2RlU2V0KSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLm5vZGVTZXQgPSBub2RlU2V0O1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zYWZlRnJvbSA9IC0xO1xuICAgICAgICB0aGlzLnNhZmVUbyA9IC0xO1xuICAgICAgICB0aGlzLnRyZWVzID0gW107XG4gICAgICAgIHRoaXMuc3RhcnQgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRleCA9IFtdO1xuICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgIH1cbiAgICBuZXh0RnJhZ21lbnQoKSB7XG4gICAgICAgIGxldCBmciA9IHRoaXMuZnJhZ21lbnQgPSB0aGlzLmkgPT0gdGhpcy5mcmFnbWVudHMubGVuZ3RoID8gbnVsbCA6IHRoaXMuZnJhZ21lbnRzW3RoaXMuaSsrXTtcbiAgICAgICAgaWYgKGZyKSB7XG4gICAgICAgICAgICB0aGlzLnNhZmVGcm9tID0gZnIub3BlblN0YXJ0ID8gY3V0QXQoZnIudHJlZSwgZnIuZnJvbSArIGZyLm9mZnNldCwgMSkgLSBmci5vZmZzZXQgOiBmci5mcm9tO1xuICAgICAgICAgICAgdGhpcy5zYWZlVG8gPSBmci5vcGVuRW5kID8gY3V0QXQoZnIudHJlZSwgZnIudG8gKyBmci5vZmZzZXQsIC0xKSAtIGZyLm9mZnNldCA6IGZyLnRvO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMudHJlZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyZWVzLnB1c2goZnIudHJlZSk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0LnB1c2goLWZyLm9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmluZGV4LnB1c2goMCk7XG4gICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHRoaXMuc2FmZUZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IDFlOTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBgcG9zYCBtdXN0IGJlID49IGFueSBwcmV2aW91c2x5IGdpdmVuIGBwb3NgIGZvciB0aGlzIGN1cnNvclxuICAgIG5vZGVBdChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA8IHRoaXMubmV4dFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHdoaWxlICh0aGlzLmZyYWdtZW50ICYmIHRoaXMuc2FmZVRvIDw9IHBvcylcbiAgICAgICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgICAgIGlmICghdGhpcy5mcmFnbWVudClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMudHJlZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChsYXN0IDwgMCkgeyAvLyBFbmQgb2YgdHJlZVxuICAgICAgICAgICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy50cmVlc1tsYXN0XSwgaW5kZXggPSB0aGlzLmluZGV4W2xhc3RdO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRvcC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0ID0gdG9wLmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMuc3RhcnRbbGFzdF0gKyB0b3AucG9zaXRpb25zW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzdGFydCA+IHBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT0gcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA8IHRoaXMuc2FmZUZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZCA9IHN0YXJ0ICsgbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPD0gdGhpcy5zYWZlVG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsb29rQWhlYWQgPSBuZXh0LnByb3AoTm9kZVByb3AubG9va0FoZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbG9va0FoZWFkIHx8IGVuZCArIGxvb2tBaGVhZCA8IHRoaXMuZnJhZ21lbnQudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleFtsYXN0XSsrO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCArIG5leHQubGVuZ3RoID49IE1hdGgubWF4KHRoaXMuc2FmZUZyb20sIHBvcykpIHsgLy8gRW50ZXIgdGhpcyBub2RlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wdXNoKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wdXNoKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhbbGFzdF0rKztcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHN0YXJ0ICsgbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBUb2tlbkNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHN0cmVhbSkge1xuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBudWxsO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBwYXJzZXIudG9rZW5pemVycy5tYXAoXyA9PiBuZXcgQ2FjaGVkVG9rZW4pO1xuICAgIH1cbiAgICBnZXRBY3Rpb25zKHN0YWNrKSB7XG4gICAgICAgIGxldCBhY3Rpb25JbmRleCA9IDA7XG4gICAgICAgIGxldCBtYWluID0gbnVsbDtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5wLCB7IHRva2VuaXplcnMgfSA9IHBhcnNlcjtcbiAgICAgICAgbGV0IG1hc2sgPSBwYXJzZXIuc3RhdGVTbG90KHN0YWNrLnN0YXRlLCAzIC8qIFBhcnNlU3RhdGUuVG9rZW5pemVyTWFzayAqLyk7XG4gICAgICAgIGxldCBjb250ZXh0ID0gc3RhY2suY3VyQ29udGV4dCA/IHN0YWNrLmN1ckNvbnRleHQuaGFzaCA6IDA7XG4gICAgICAgIGxldCBsb29rQWhlYWQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoKDEgPDwgaSkgJiBtYXNrKSA9PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHRva2VuaXplciA9IHRva2VuaXplcnNbaV0sIHRva2VuID0gdGhpcy50b2tlbnNbaV07XG4gICAgICAgICAgICBpZiAobWFpbiAmJiAhdG9rZW5pemVyLmZhbGxiYWNrKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRva2VuaXplci5jb250ZXh0dWFsIHx8IHRva2VuLnN0YXJ0ICE9IHN0YWNrLnBvcyB8fCB0b2tlbi5tYXNrICE9IG1hc2sgfHwgdG9rZW4uY29udGV4dCAhPSBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZWRUb2tlbih0b2tlbiwgdG9rZW5pemVyLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgdG9rZW4ubWFzayA9IG1hc2s7XG4gICAgICAgICAgICAgICAgdG9rZW4uY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4ubG9va0FoZWFkID4gdG9rZW4uZW5kICsgMjUgLyogU2FmZXR5Lk1hcmdpbiAqLylcbiAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBNYXRoLm1heCh0b2tlbi5sb29rQWhlYWQsIGxvb2tBaGVhZCk7XG4gICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgIT0gMCAvKiBUZXJtLkVyciAqLykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gYWN0aW9uSW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLmV4dGVuZGVkID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCB0b2tlbi5leHRlbmRlZCwgdG9rZW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLnZhbHVlLCB0b2tlbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuaXplci5leHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uSW5kZXggPiBzdGFydEluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLmFjdGlvbnMubGVuZ3RoID4gYWN0aW9uSW5kZXgpXG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMucG9wKCk7XG4gICAgICAgIGlmIChsb29rQWhlYWQpXG4gICAgICAgICAgICBzdGFjay5zZXRMb29rQWhlYWQobG9va0FoZWFkKTtcbiAgICAgICAgaWYgKCFtYWluICYmIHN0YWNrLnBvcyA9PSB0aGlzLnN0cmVhbS5lbmQpIHtcbiAgICAgICAgICAgIG1haW4gPSBuZXcgQ2FjaGVkVG9rZW47XG4gICAgICAgICAgICBtYWluLnZhbHVlID0gc3RhY2sucC5wYXJzZXIuZW9mVGVybTtcbiAgICAgICAgICAgIG1haW4uc3RhcnQgPSBtYWluLmVuZCA9IHN0YWNrLnBvcztcbiAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCBtYWluLnZhbHVlLCBtYWluLmVuZCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFpblRva2VuID0gbWFpbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9ucztcbiAgICB9XG4gICAgZ2V0TWFpblRva2VuKHN0YWNrKSB7XG4gICAgICAgIGlmICh0aGlzLm1haW5Ub2tlbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1haW5Ub2tlbjtcbiAgICAgICAgbGV0IG1haW4gPSBuZXcgQ2FjaGVkVG9rZW4sIHsgcG9zLCBwIH0gPSBzdGFjaztcbiAgICAgICAgbWFpbi5zdGFydCA9IHBvcztcbiAgICAgICAgbWFpbi5lbmQgPSBNYXRoLm1pbihwb3MgKyAxLCBwLnN0cmVhbS5lbmQpO1xuICAgICAgICBtYWluLnZhbHVlID0gcG9zID09IHAuc3RyZWFtLmVuZCA/IHAucGFyc2VyLmVvZlRlcm0gOiAwIC8qIFRlcm0uRXJyICovO1xuICAgICAgICByZXR1cm4gbWFpbjtcbiAgICB9XG4gICAgdXBkYXRlQ2FjaGVkVG9rZW4odG9rZW4sIHRva2VuaXplciwgc3RhY2spIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zdHJlYW0uY2xpcFBvcyhzdGFjay5wb3MpO1xuICAgICAgICB0b2tlbml6ZXIudG9rZW4odGhpcy5zdHJlYW0ucmVzZXQoc3RhcnQsIHRva2VuKSwgc3RhY2spO1xuICAgICAgICBpZiAodG9rZW4udmFsdWUgPiAtMSkge1xuICAgICAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5wO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZXIuc3BlY2lhbGl6ZWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlci5zcGVjaWFsaXplZFtpXSA9PSB0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VyLnNwZWNpYWxpemVyc1tpXSh0aGlzLnN0cmVhbS5yZWFkKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPj0gMCAmJiBzdGFjay5wLnBhcnNlci5kaWFsZWN0LmFsbG93cyhyZXN1bHQgPj4gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVzdWx0ICYgMSkgPT0gMCAvKiBTcGVjaWFsaXplLlNwZWNpYWxpemUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSByZXN1bHQgPj4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5leHRlbmRlZCA9IHJlc3VsdCA+PiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9IDAgLyogVGVybS5FcnIgKi87XG4gICAgICAgICAgICB0b2tlbi5lbmQgPSB0aGlzLnN0cmVhbS5jbGlwUG9zKHN0YXJ0ICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHV0QWN0aW9uKGFjdGlvbiwgdG9rZW4sIGVuZCwgaW5kZXgpIHtcbiAgICAgICAgLy8gRG9uJ3QgYWRkIGR1cGxpY2F0ZSBhY3Rpb25zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGlvbnNbaV0gPT0gYWN0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gYWN0aW9uO1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gZW5kO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLCBlbmQsIGluZGV4KSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSBzdGFjaywgeyBwYXJzZXIgfSA9IHN0YWNrLnAsIHsgZGF0YSB9ID0gcGFyc2VyO1xuICAgICAgICBmb3IgKGxldCBzZXQgPSAwOyBzZXQgPCAyOyBzZXQrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogUGFyc2VTdGF0ZS5Ta2lwICovIDogMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gNjU1MzUgLyogU2VxLkVuZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpICsgMV0gPT0gMSAvKiBTZXEuTmV4dCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIoZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IDAgJiYgZGF0YVtpICsgMV0gPT0gMiAvKiBTZXEuT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnB1dEFjdGlvbihwYWlyKGRhdGEsIGkgKyAyKSwgdG9rZW4sIGVuZCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gdG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5wdXRBY3Rpb24ocGFpcihkYXRhLCBpICsgMSksIHRva2VuLCBlbmQsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufVxudmFyIFJlYztcbihmdW5jdGlvbiAoUmVjKSB7XG4gICAgUmVjW1JlY1tcIkRpc3RhbmNlXCJdID0gNV0gPSBcIkRpc3RhbmNlXCI7XG4gICAgUmVjW1JlY1tcIk1heFJlbWFpbmluZ1BlclN0ZXBcIl0gPSAzXSA9IFwiTWF4UmVtYWluaW5nUGVyU3RlcFwiO1xuICAgIC8vIFdoZW4gdHdvIHN0YWNrcyBoYXZlIGJlZW4gcnVubmluZyBpbmRlcGVuZGVudGx5IGxvbmcgZW5vdWdoIHRvXG4gICAgLy8gYWRkIHRoaXMgbWFueSBlbGVtZW50cyB0byB0aGVpciBidWZmZXJzLCBwcnVuZSBvbmUuXG4gICAgUmVjW1JlY1tcIk1pbkJ1ZmZlckxlbmd0aFBydW5lXCJdID0gNTAwXSA9IFwiTWluQnVmZmVyTGVuZ3RoUHJ1bmVcIjtcbiAgICBSZWNbUmVjW1wiRm9yY2VSZWR1Y2VMaW1pdFwiXSA9IDEwXSA9IFwiRm9yY2VSZWR1Y2VMaW1pdFwiO1xuICAgIC8vIE9uY2UgYSBzdGFjayByZWFjaGVzIHRoaXMgZGVwdGggKGluIC5zdGFjay5sZW5ndGgpIGZvcmNlLXJlZHVjZVxuICAgIC8vIGl0IGJhY2sgdG8gQ3V0VG8gdG8gYXZvaWQgY3JlYXRpbmcgdHJlZXMgdGhhdCBvdmVyZmxvdyB0aGUgc3RhY2tcbiAgICAvLyBvbiByZWN1cnNpdmUgdHJhdmVyc2FsLlxuICAgIFJlY1tSZWNbXCJDdXREZXB0aFwiXSA9IDE1MDAwXSA9IFwiQ3V0RGVwdGhcIjtcbiAgICBSZWNbUmVjW1wiQ3V0VG9cIl0gPSA5MDAwXSA9IFwiQ3V0VG9cIjtcbiAgICBSZWNbUmVjW1wiTWF4TGVmdEFzc29jaWF0aXZlUmVkdWN0aW9uQ291bnRcIl0gPSAzMDBdID0gXCJNYXhMZWZ0QXNzb2NpYXRpdmVSZWR1Y3Rpb25Db3VudFwiO1xuICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBub24tcmVjb3ZlcmluZyBzdGFja3MgdG8gZXhwbG9yZSAodG8gYXZvaWRcbiAgICAvLyBnZXR0aW5nIGJvZ2dlZCBkb3duIHdpdGggZXhwb25lbnRpYWxseSBtdWx0aXBseWluZyBzdGFja3MgaW5cbiAgICAvLyBhbWJpZ3VvdXMgY29udGVudClcbiAgICBSZWNbUmVjW1wiTWF4U3RhY2tDb3VudFwiXSA9IDEyXSA9IFwiTWF4U3RhY2tDb3VudFwiO1xufSkoUmVjIHx8IChSZWMgPSB7fSkpO1xuY2xhc3MgUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLnJlY292ZXJpbmcgPSAwO1xuICAgICAgICB0aGlzLm5leHRTdGFja0lEID0gMHgyNjU0OyAvLyDimZQsIOKZlSwg4pmWLCDimZcsIOKZmCwg4pmZLCDimaAsIOKZoSwg4pmiLCDimaMsIOKZpCwg4pmlLCDimaYsIOKZp1xuICAgICAgICB0aGlzLm1pblN0YWNrUG9zID0gMDtcbiAgICAgICAgdGhpcy5yZXVzZWQgPSBbXTtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TaXplID0gMDtcbiAgICAgICAgdGhpcy5iaWdSZWR1Y3Rpb25Db3VudCA9IDA7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gbmV3IElucHV0U3RyZWFtKGlucHV0LCByYW5nZXMpO1xuICAgICAgICB0aGlzLnRva2VucyA9IG5ldyBUb2tlbkNhY2hlKHBhcnNlciwgdGhpcy5zdHJlYW0pO1xuICAgICAgICB0aGlzLnRvcFRlcm0gPSBwYXJzZXIudG9wWzFdO1xuICAgICAgICBsZXQgeyBmcm9tIH0gPSByYW5nZXNbMF07XG4gICAgICAgIHRoaXMuc3RhY2tzID0gW1N0YWNrLnN0YXJ0KHRoaXMsIHBhcnNlci50b3BbMF0sIGZyb20pXTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHMubGVuZ3RoICYmIHRoaXMuc3RyZWFtLmVuZCAtIGZyb20gPiBwYXJzZXIuYnVmZmVyTGVuZ3RoICogNFxuICAgICAgICAgICAgPyBuZXcgRnJhZ21lbnRDdXJzb3IoZnJhZ21lbnRzLCBwYXJzZXIubm9kZVNldCkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgcGFyc2VkUG9zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5TdGFja1BvcztcbiAgICB9XG4gICAgLy8gTW92ZSB0aGUgcGFyc2VyIGZvcndhcmQuIFRoaXMgd2lsbCBwcm9jZXNzIGFsbCBwYXJzZSBzdGFja3MgYXRcbiAgICAvLyBgdGhpcy5wb3NgIGFuZCB0cnkgdG8gYWR2YW5jZSB0aGVtIHRvIGEgZnVydGhlciBwb3NpdGlvbi4gSWYgbm9cbiAgICAvLyBzdGFjayBmb3Igc3VjaCBhIHBvc2l0aW9uIGlzIGZvdW5kLCBpdCdsbCBzdGFydCBlcnJvci1yZWNvdmVyeS5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIHBhcnNlIGlzIGZpbmlzaGVkLCB0aGlzIHdpbGwgcmV0dXJuIGEgc3ludGF4IHRyZWUuIFdoZW5cbiAgICAvLyBub3QsIGl0IHJldHVybnMgYG51bGxgLlxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIGxldCBzdGFja3MgPSB0aGlzLnN0YWNrcywgcG9zID0gdGhpcy5taW5TdGFja1BvcztcbiAgICAgICAgLy8gVGhpcyB3aWxsIGhvbGQgc3RhY2tzIGJleW9uZCBgcG9zYC5cbiAgICAgICAgbGV0IG5ld1N0YWNrcyA9IHRoaXMuc3RhY2tzID0gW107XG4gICAgICAgIGxldCBzdG9wcGVkLCBzdG9wcGVkVG9rZW5zO1xuICAgICAgICAvLyBJZiBhIGxhcmdlIGFtb3VudCBvZiByZWR1Y3Rpb25zIGhhcHBlbmVkIHdpdGggdGhlIHNhbWUgc3RhcnRcbiAgICAgICAgLy8gcG9zaXRpb24sIGZvcmNlIHRoZSBzdGFjayBvdXQgb2YgdGhhdCBwcm9kdWN0aW9uIGluIG9yZGVyIHRvXG4gICAgICAgIC8vIGF2b2lkIGNyZWF0aW5nIGEgdHJlZSB0b28gZGVlcCB0byByZWN1cnNlIHRocm91Z2guXG4gICAgICAgIC8vIChUaGlzIGlzIGFuIHVnbHkga2x1ZGdlLCBiZWNhdXNlIHVuZm9ydHVuYXRlbHkgdGhlcmUgaXMgbm9cbiAgICAgICAgLy8gc3RyYWlnaHRmb3J3YXJkLCBjaGVhcCB3YXkgdG8gY2hlY2sgZm9yIHRoaXMgaGFwcGVuaW5nLCBkdWUgdG9cbiAgICAgICAgLy8gdGhlIGhpc3Rvcnkgb2YgcmVkdWN0aW9ucyBvbmx5IGJlaW5nIGF2YWlsYWJsZSBpbiBhblxuICAgICAgICAvLyBleHBlbnNpdmUtdG8tYWNjZXNzIGZvcm1hdCBpbiB0aGUgc3RhY2sgYnVmZmVycy4pXG4gICAgICAgIGlmICh0aGlzLmJpZ1JlZHVjdGlvbkNvdW50ID4gMzAwIC8qIFJlYy5NYXhMZWZ0QXNzb2NpYXRpdmVSZWR1Y3Rpb25Db3VudCAqLyAmJiBzdGFja3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIGxldCBbc10gPSBzdGFja3M7XG4gICAgICAgICAgICB3aGlsZSAocy5mb3JjZVJlZHVjZSgpICYmIHMuc3RhY2subGVuZ3RoICYmIHMuc3RhY2tbcy5zdGFjay5sZW5ndGggLSAyXSA+PSB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCkgeyB9XG4gICAgICAgICAgICB0aGlzLmJpZ1JlZHVjdGlvbkNvdW50ID0gdGhpcy5sYXN0QmlnUmVkdWN0aW9uU2l6ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gS2VlcCBhZHZhbmNpbmcgYW55IHN0YWNrcyBhdCBgcG9zYCB1bnRpbCB0aGV5IGVpdGhlciBtb3ZlXG4gICAgICAgIC8vIGZvcndhcmQgb3IgY2FuJ3QgYmUgYWR2YW5jZWQuIEdhdGhlciBzdGFja3MgdGhhdCBjYW4ndCBiZVxuICAgICAgICAvLyBhZHZhbmNlZCBmdXJ0aGVyIGluIGBzdG9wcGVkYC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHN0YWNrc1tpXTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRva2Vucy5tYWluVG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5wb3MgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFkdmFuY2VTdGFjayhzdGFjaywgbmV3U3RhY2tzLCBzdGFja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkVG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvayA9IHRoaXMudG9rZW5zLmdldE1haW5Ub2tlbihzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWRUb2tlbnMucHVzaCh0b2sudmFsdWUsIHRvay5lbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5ld1N0YWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IHN0b3BwZWQgJiYgZmluZEZpbmlzaGVkKHN0b3BwZWQpO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrVG9UcmVlKGZpbmlzaGVkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlci5zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSAmJiBzdG9wcGVkKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlN0dWNrIHdpdGggdG9rZW4gXCIgKyAodGhpcy50b2tlbnMubWFpblRva2VuID8gdGhpcy5wYXJzZXIuZ2V0TmFtZSh0aGlzLnRva2Vucy5tYWluVG9rZW4udmFsdWUpIDogXCJub25lXCIpKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJObyBwYXJzZSBhdCBcIiArIHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVjb3ZlcmluZylcbiAgICAgICAgICAgICAgICB0aGlzLnJlY292ZXJpbmcgPSA1IC8qIFJlYy5EaXN0YW5jZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyaW5nICYmIHN0b3BwZWQpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgc3RvcHBlZFswXS5wb3MgPiB0aGlzLnN0b3BwZWRBdCA/IHN0b3BwZWRbMF1cbiAgICAgICAgICAgICAgICA6IHRoaXMucnVuUmVjb3Zlcnkoc3RvcHBlZCwgc3RvcHBlZFRva2VucywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShmaW5pc2hlZC5mb3JjZUFsbCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyaW5nKSB7XG4gICAgICAgICAgICBsZXQgbWF4UmVtYWluaW5nID0gdGhpcy5yZWNvdmVyaW5nID09IDEgPyAxIDogdGhpcy5yZWNvdmVyaW5nICogMyAvKiBSZWMuTWF4UmVtYWluaW5nUGVyU3RlcCAqLztcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3MubGVuZ3RoID4gbWF4UmVtYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV3U3RhY2tzLmxlbmd0aCA+IG1heFJlbWFpbmluZylcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5zb21lKHMgPT4gcy5yZWR1Y2VQb3MgPiBwb3MpKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmluZy0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBQcnVuZSBzdGFja3MgdGhhdCBhcmUgaW4gdGhlIHNhbWUgc3RhdGUsIG9yIHRoYXQgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBydW5uaW5nIHdpdGhvdXQgc3BsaXR0aW5nIGZvciBhIHdoaWxlLCB0byBhdm9pZCBnZXR0aW5nIHN0dWNrXG4gICAgICAgICAgICAvLyB3aXRoIG11bHRpcGxlIHN1Y2Nlc3NmdWwgc3RhY2tzIHJ1bm5pbmcgZW5kbGVzc2x5IG9uLlxuICAgICAgICAgICAgb3V0ZXI6IGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U3RhY2tzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IG5ld1N0YWNrc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBuZXdTdGFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2suc2FtZVN0YXRlKG90aGVyKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2suYnVmZmVyLmxlbmd0aCA+IDUwMCAvKiBSZWMuTWluQnVmZmVyTGVuZ3RoUHJ1bmUgKi8gJiYgb3RoZXIuYnVmZmVyLmxlbmd0aCA+IDUwMCAvKiBSZWMuTWluQnVmZmVyTGVuZ3RoUHJ1bmUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKHN0YWNrLnNjb3JlIC0gb3RoZXIuc2NvcmUpIHx8IChzdGFjay5idWZmZXIubGVuZ3RoIC0gb3RoZXIuYnVmZmVyLmxlbmd0aCkpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdTdGFja3MubGVuZ3RoID4gMTIgLyogUmVjLk1heFN0YWNrQ291bnQgKi8pXG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNwbGljZSgxMiAvKiBSZWMuTWF4U3RhY2tDb3VudCAqLywgbmV3U3RhY2tzLmxlbmd0aCAtIDEyIC8qIFJlYy5NYXhTdGFja0NvdW50ICovKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pblN0YWNrUG9zID0gbmV3U3RhY2tzWzBdLnBvcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuZXdTdGFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzW2ldLnBvcyA8IHRoaXMubWluU3RhY2tQb3MpXG4gICAgICAgICAgICAgICAgdGhpcy5taW5TdGFja1BvcyA9IG5ld1N0YWNrc1tpXS5wb3M7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdG9wQXQocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHRoaXMuc3RvcHBlZEF0IDwgcG9zKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBtb3ZlIHN0b3BwZWRBdCBmb3J3YXJkXCIpO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IHBvcztcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhbiB1cGRhdGVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIHN0YWNrLCBvciBudWxsIGlmIHRoZVxuICAgIC8vIHN0YWNrIGNhbid0IGFkdmFuY2Ugbm9ybWFsbHkuIFdoZW4gYHNwbGl0YCBhbmQgYHN0YWNrc2AgYXJlXG4gICAgLy8gZ2l2ZW4sIHN0YWNrcyBzcGxpdCBvZmYgYnkgYW1iaWd1b3VzIG9wZXJhdGlvbnMgd2lsbCBiZSBwdXNoZWQgdG9cbiAgICAvLyBgc3BsaXRgLCBvciBhZGRlZCB0byBgc3RhY2tzYCBpZiB0aGV5IG1vdmUgYHBvc2AgZm9yd2FyZC5cbiAgICBhZHZhbmNlU3RhY2soc3RhY2ssIHN0YWNrcywgc3BsaXQpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RhY2sucG9zLCB7IHBhcnNlciB9ID0gdGhpcztcbiAgICAgICAgbGV0IGJhc2UgPSB2ZXJib3NlID8gdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIC0+IFwiIDogXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgc3RhcnQgPiB0aGlzLnN0b3BwZWRBdClcbiAgICAgICAgICAgIHJldHVybiBzdGFjay5mb3JjZVJlZHVjZSgpID8gc3RhY2sgOiBudWxsO1xuICAgICAgICBpZiAodGhpcy5mcmFnbWVudHMpIHtcbiAgICAgICAgICAgIGxldCBzdHJpY3RDeCA9IHN0YWNrLmN1ckNvbnRleHQgJiYgc3RhY2suY3VyQ29udGV4dC50cmFja2VyLnN0cmljdCwgY3hIYXNoID0gc3RyaWN0Q3ggPyBzdGFjay5jdXJDb250ZXh0Lmhhc2ggOiAwO1xuICAgICAgICAgICAgZm9yIChsZXQgY2FjaGVkID0gdGhpcy5mcmFnbWVudHMubm9kZUF0KHN0YXJ0KTsgY2FjaGVkOykge1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMucGFyc2VyLm5vZGVTZXQudHlwZXNbY2FjaGVkLnR5cGUuaWRdID09IGNhY2hlZC50eXBlID8gcGFyc2VyLmdldEdvdG8oc3RhY2suc3RhdGUsIGNhY2hlZC50eXBlLmlkKSA6IC0xO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCA+IC0xICYmIGNhY2hlZC5sZW5ndGggJiYgKCFzdHJpY3RDeCB8fCAoY2FjaGVkLnByb3AoTm9kZVByb3AuY29udGV4dEhhc2gpIHx8IDApID09IGN4SGFzaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sudXNlTm9kZShjYWNoZWQsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSByZXVzZSBvZiAke3BhcnNlci5nZXROYW1lKGNhY2hlZC50eXBlLmlkKX0pYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIShjYWNoZWQgaW5zdGFuY2VvZiBUcmVlKSB8fCBjYWNoZWQuY2hpbGRyZW4ubGVuZ3RoID09IDAgfHwgY2FjaGVkLnBvc2l0aW9uc1swXSA+IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IGNhY2hlZC5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIgaW5zdGFuY2VvZiBUcmVlICYmIGNhY2hlZC5wb3NpdGlvbnNbMF0gPT0gMClcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkID0gaW5uZXI7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVmYXVsdFJlZHVjZSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhY2suc3RhdGUsIDQgLyogUGFyc2VTdGF0ZS5EZWZhdWx0UmVkdWNlICovKTtcbiAgICAgICAgaWYgKGRlZmF1bHRSZWR1Y2UgPiAwKSB7XG4gICAgICAgICAgICBzdGFjay5yZWR1Y2UoZGVmYXVsdFJlZHVjZSk7XG4gICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSBhbHdheXMtcmVkdWNlICR7cGFyc2VyLmdldE5hbWUoZGVmYXVsdFJlZHVjZSAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi8pfSlgKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFjay5zdGFjay5sZW5ndGggPj0gMTUwMDAgLyogUmVjLkN1dERlcHRoICovKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhY2suc3RhY2subGVuZ3RoID4gOTAwMCAvKiBSZWMuQ3V0VG8gKi8gJiYgc3RhY2suZm9yY2VSZWR1Y2UoKSkgeyB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFjdGlvbnMgPSB0aGlzLnRva2Vucy5nZXRBY3Rpb25zKHN0YWNrKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSBhY3Rpb25zW2krK10sIHRlcm0gPSBhY3Rpb25zW2krK10sIGVuZCA9IGFjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gaSA9PSBhY3Rpb25zLmxlbmd0aCB8fCAhc3BsaXQ7XG4gICAgICAgICAgICBsZXQgbG9jYWxTdGFjayA9IGxhc3QgPyBzdGFjayA6IHN0YWNrLnNwbGl0KCk7XG4gICAgICAgICAgICBsb2NhbFN0YWNrLmFwcGx5KGFjdGlvbiwgdGVybSwgZW5kKTtcbiAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQobG9jYWxTdGFjaykgKyBgICh2aWEgJHsoYWN0aW9uICYgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8pID09IDAgPyBcInNoaWZ0XCJcbiAgICAgICAgICAgICAgICAgICAgOiBgcmVkdWNlIG9mICR7cGFyc2VyLmdldE5hbWUoYWN0aW9uICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLyl9YH0gZm9yICR7cGFyc2VyLmdldE5hbWUodGVybSl9IEAgJHtzdGFydH0ke2xvY2FsU3RhY2sgPT0gc3RhY2sgPyBcIlwiIDogXCIsIHNwbGl0XCJ9KWApO1xuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmIChsb2NhbFN0YWNrLnBvcyA+IHN0YXJ0KVxuICAgICAgICAgICAgICAgIHN0YWNrcy5wdXNoKGxvY2FsU3RhY2spO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNwbGl0LnB1c2gobG9jYWxTdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBBZHZhbmNlIGEgZ2l2ZW4gc3RhY2sgZm9yd2FyZCBhcyBmYXIgYXMgaXQgd2lsbCBnby4gUmV0dXJucyB0aGVcbiAgICAvLyAocG9zc2libHkgdXBkYXRlZCkgc3RhY2sgaWYgaXQgZ290IHN0dWNrLCBvciBudWxsIGlmIGl0IG1vdmVkXG4gICAgLy8gZm9yd2FyZCBhbmQgd2FzIGdpdmVuIHRvIGBwdXNoU3RhY2tEZWR1cGAuXG4gICAgYWR2YW5jZUZ1bGx5KHN0YWNrLCBuZXdTdGFja3MpIHtcbiAgICAgICAgbGV0IHBvcyA9IHN0YWNrLnBvcztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFkdmFuY2VTdGFjayhzdGFjaywgbnVsbCwgbnVsbCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN0YWNrLnBvcyA+IHBvcykge1xuICAgICAgICAgICAgICAgIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJ1blJlY292ZXJ5KHN0YWNrcywgdG9rZW5zLCBuZXdTdGFja3MpIHtcbiAgICAgICAgbGV0IGZpbmlzaGVkID0gbnVsbCwgcmVzdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSBzdGFja3NbaV0sIHRva2VuID0gdG9rZW5zW2kgPDwgMV0sIHRva2VuRW5kID0gdG9rZW5zWyhpIDw8IDEpICsgMV07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHZlcmJvc2UgPyB0aGlzLnN0YWNrSUQoc3RhY2spICsgXCIgLT4gXCIgOiBcIlwiO1xuICAgICAgICAgICAgaWYgKHN0YWNrLmRlYWRFbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdGFydGVkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YWNrLnJlc3RhcnQoKTtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAocmVzdGFydGVkKVwiKTtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYWR2YW5jZUZ1bGx5KHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3JjZSA9IHN0YWNrLnNwbGl0KCksIGZvcmNlQmFzZSA9IGJhc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgZm9yY2UuZm9yY2VSZWR1Y2UoKSAmJiBqIDwgMTAgLyogUmVjLkZvcmNlUmVkdWNlTGltaXQgKi87IGorKykge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhmb3JjZUJhc2UgKyB0aGlzLnN0YWNrSUQoZm9yY2UpICsgXCIgKHZpYSBmb3JjZS1yZWR1Y2UpXCIpO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5hZHZhbmNlRnVsbHkoZm9yY2UsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBmb3JjZUJhc2UgPSB0aGlzLnN0YWNrSUQoZm9yY2UpICsgXCIgLT4gXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpbnNlcnQgb2Ygc3RhY2sucmVjb3ZlckJ5SW5zZXJ0KHRva2VuKSkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKGluc2VydCkgKyBcIiAodmlhIHJlY292ZXItaW5zZXJ0KVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VGdWxseShpbnNlcnQsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdHJlYW0uZW5kID4gc3RhY2sucG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuRW5kID09IHN0YWNrLnBvcykge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbkVuZCsrO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IDAgLyogVGVybS5FcnIgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YWNrLnJlY292ZXJCeURlbGV0ZSh0b2tlbiwgdG9rZW5FbmQpO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSByZWNvdmVyLWRlbGV0ZSAke3RoaXMucGFyc2VyLmdldE5hbWUodG9rZW4pfSlgKTtcbiAgICAgICAgICAgICAgICBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFmaW5pc2hlZCB8fCBmaW5pc2hlZC5zY29yZSA8IHN0YWNrLnNjb3JlKSB7XG4gICAgICAgICAgICAgICAgZmluaXNoZWQgPSBzdGFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluaXNoZWQ7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgdGhlIHN0YWNrJ3MgYnVmZmVyIHRvIGEgc3ludGF4IHRyZWUuXG4gICAgc3RhY2tUb1RyZWUoc3RhY2spIHtcbiAgICAgICAgc3RhY2suY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIFRyZWUuYnVpbGQoeyBidWZmZXI6IFN0YWNrQnVmZmVyQ3Vyc29yLmNyZWF0ZShzdGFjayksXG4gICAgICAgICAgICBub2RlU2V0OiB0aGlzLnBhcnNlci5ub2RlU2V0LFxuICAgICAgICAgICAgdG9wSUQ6IHRoaXMudG9wVGVybSxcbiAgICAgICAgICAgIG1heEJ1ZmZlckxlbmd0aDogdGhpcy5wYXJzZXIuYnVmZmVyTGVuZ3RoLFxuICAgICAgICAgICAgcmV1c2VkOiB0aGlzLnJldXNlZCxcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnJhbmdlc1swXS5mcm9tLFxuICAgICAgICAgICAgbGVuZ3RoOiBzdGFjay5wb3MgLSB0aGlzLnJhbmdlc1swXS5mcm9tLFxuICAgICAgICAgICAgbWluUmVwZWF0VHlwZTogdGhpcy5wYXJzZXIubWluUmVwZWF0VGVybSB9KTtcbiAgICB9XG4gICAgc3RhY2tJRChzdGFjaykge1xuICAgICAgICBsZXQgaWQgPSAoc3RhY2tJRHMgfHwgKHN0YWNrSURzID0gbmV3IFdlYWtNYXApKS5nZXQoc3RhY2spO1xuICAgICAgICBpZiAoIWlkKVxuICAgICAgICAgICAgc3RhY2tJRHMuc2V0KHN0YWNrLCBpZCA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHRoaXMubmV4dFN0YWNrSUQrKykpO1xuICAgICAgICByZXR1cm4gaWQgKyBzdGFjaztcbiAgICB9XG59XG5mdW5jdGlvbiBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2ldO1xuICAgICAgICBpZiAob3RoZXIucG9zID09IHN0YWNrLnBvcyAmJiBvdGhlci5zYW1lU3RhdGUoc3RhY2spKSB7XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzW2ldLnNjb3JlIDwgc3RhY2suc2NvcmUpXG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzW2ldID0gc3RhY2s7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xufVxuY2xhc3MgRGlhbGVjdCB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBmbGFncywgZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIH1cbiAgICBhbGxvd3ModGVybSkgeyByZXR1cm4gIXRoaXMuZGlzYWJsZWQgfHwgdGhpcy5kaXNhYmxlZFt0ZXJtXSA9PSAwOyB9XG59XG5jb25zdCBpZCA9IHggPT4geDtcbi8vLyBDb250ZXh0IHRyYWNrZXJzIGFyZSB1c2VkIHRvIHRyYWNrIHN0YXRlZnVsIGNvbnRleHQgKHN1Y2ggYXNcbi8vLyBpbmRlbnRhdGlvbiBpbiB0aGUgUHl0aG9uIGdyYW1tYXIsIG9yIHBhcmVudCBlbGVtZW50cyBpbiB0aGUgWE1MXG4vLy8gZ3JhbW1hcikgbmVlZGVkIGJ5IGV4dGVybmFsIHRva2VuaXplcnMuIFlvdSBkZWNsYXJlIHRoZW0gaW4gYVxuLy8vIGdyYW1tYXIgZmlsZSBhcyBgQGNvbnRleHQgZXhwb3J0TmFtZSBmcm9tIFwibW9kdWxlXCJgLlxuLy8vXG4vLy8gQ29udGV4dCB2YWx1ZXMgc2hvdWxkIGJlIGltbXV0YWJsZSwgYW5kIGNhbiBiZSB1cGRhdGVkIChyZXBsYWNlZClcbi8vLyBvbiBzaGlmdCBvciByZWR1Y2UgYWN0aW9ucy5cbi8vL1xuLy8vIFRoZSBleHBvcnQgdXNlZCBpbiBhIGBAY29udGV4dGAgZGVjbGFyYXRpb24gc2hvdWxkIGJlIG9mIHRoaXNcbi8vLyB0eXBlLlxuY2xhc3MgQ29udGV4dFRyYWNrZXIge1xuICAgIC8vLyBEZWZpbmUgYSBjb250ZXh0IHRyYWNrZXIuXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3BlYy5zdGFydDtcbiAgICAgICAgdGhpcy5zaGlmdCA9IHNwZWMuc2hpZnQgfHwgaWQ7XG4gICAgICAgIHRoaXMucmVkdWNlID0gc3BlYy5yZWR1Y2UgfHwgaWQ7XG4gICAgICAgIHRoaXMucmV1c2UgPSBzcGVjLnJldXNlIHx8IGlkO1xuICAgICAgICB0aGlzLmhhc2ggPSBzcGVjLmhhc2ggfHwgKCgpID0+IDApO1xuICAgICAgICB0aGlzLnN0cmljdCA9IHNwZWMuc3RyaWN0ICE9PSBmYWxzZTtcbiAgICB9XG59XG4vLy8gSG9sZHMgdGhlIHBhcnNlIHRhYmxlcyBmb3IgYSBnaXZlbiBncmFtbWFyLCBhcyBnZW5lcmF0ZWQgYnlcbi8vLyBgbGV6ZXItZ2VuZXJhdG9yYCwgYW5kIHByb3ZpZGVzIFttZXRob2RzXSgjY29tbW9uLlBhcnNlcikgdG8gcGFyc2Vcbi8vLyBjb250ZW50IHdpdGguXG5jbGFzcyBMUlBhcnNlciBleHRlbmRzIFBhcnNlciB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLndyYXBwZXJzID0gW107XG4gICAgICAgIGlmIChzcGVjLnZlcnNpb24gIT0gMTQgLyogRmlsZS5WZXJzaW9uICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFBhcnNlciB2ZXJzaW9uICgke3NwZWMudmVyc2lvbn0pIGRvZXNuJ3QgbWF0Y2ggcnVudGltZSB2ZXJzaW9uICgkezE0IC8qIEZpbGUuVmVyc2lvbiAqL30pYCk7XG4gICAgICAgIGxldCBub2RlTmFtZXMgPSBzcGVjLm5vZGVOYW1lcy5zcGxpdChcIiBcIik7XG4gICAgICAgIHRoaXMubWluUmVwZWF0VGVybSA9IG5vZGVOYW1lcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BlYy5yZXBlYXROb2RlQ291bnQ7IGkrKylcbiAgICAgICAgICAgIG5vZGVOYW1lcy5wdXNoKFwiXCIpO1xuICAgICAgICBsZXQgdG9wVGVybXMgPSBPYmplY3Qua2V5cyhzcGVjLnRvcFJ1bGVzKS5tYXAociA9PiBzcGVjLnRvcFJ1bGVzW3JdWzFdKTtcbiAgICAgICAgbGV0IG5vZGVQcm9wcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVOYW1lcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIG5vZGVQcm9wcy5wdXNoKFtdKTtcbiAgICAgICAgZnVuY3Rpb24gc2V0UHJvcChub2RlSUQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBub2RlUHJvcHNbbm9kZUlEXS5wdXNoKFtwcm9wLCBwcm9wLmRlc2VyaWFsaXplKFN0cmluZyh2YWx1ZSkpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwZWMubm9kZVByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcFNwZWMgb2Ygc3BlYy5ub2RlUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcCA9IHByb3BTcGVjWzBdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICBwcm9wID0gTm9kZVByb3BbcHJvcF07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwcm9wU3BlYy5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcHJvcFNwZWNbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChuZXh0LCBwcm9wLCBwcm9wU3BlY1tpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHByb3BTcGVjW2kgKyAtbmV4dF07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gLW5leHQ7IGogPiAwOyBqLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChwcm9wU3BlY1tpKytdLCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZVNldCA9IG5ldyBOb2RlU2V0KG5vZGVOYW1lcy5tYXAoKG5hbWUsIGkpID0+IE5vZGVUeXBlLmRlZmluZSh7XG4gICAgICAgICAgICBuYW1lOiBpID49IHRoaXMubWluUmVwZWF0VGVybSA/IHVuZGVmaW5lZCA6IG5hbWUsXG4gICAgICAgICAgICBpZDogaSxcbiAgICAgICAgICAgIHByb3BzOiBub2RlUHJvcHNbaV0sXG4gICAgICAgICAgICB0b3A6IHRvcFRlcm1zLmluZGV4T2YoaSkgPiAtMSxcbiAgICAgICAgICAgIGVycm9yOiBpID09IDAsXG4gICAgICAgICAgICBza2lwcGVkOiBzcGVjLnNraXBwZWROb2RlcyAmJiBzcGVjLnNraXBwZWROb2Rlcy5pbmRleE9mKGkpID4gLTFcbiAgICAgICAgfSkpKTtcbiAgICAgICAgaWYgKHNwZWMucHJvcFNvdXJjZXMpXG4gICAgICAgICAgICB0aGlzLm5vZGVTZXQgPSB0aGlzLm5vZGVTZXQuZXh0ZW5kKC4uLnNwZWMucHJvcFNvdXJjZXMpO1xuICAgICAgICB0aGlzLnN0cmljdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGg7XG4gICAgICAgIGxldCB0b2tlbkFycmF5ID0gZGVjb2RlQXJyYXkoc3BlYy50b2tlbkRhdGEpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBzcGVjLmNvbnRleHQ7XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZXJTcGVjcyA9IHNwZWMuc3BlY2lhbGl6ZWQgfHwgW107XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZWQgPSBuZXcgVWludDE2QXJyYXkodGhpcy5zcGVjaWFsaXplclNwZWNzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zcGVjaWFsaXplclNwZWNzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5zcGVjaWFsaXplZFtpXSA9IHRoaXMuc3BlY2lhbGl6ZXJTcGVjc1tpXS50ZXJtO1xuICAgICAgICB0aGlzLnNwZWNpYWxpemVycyA9IHRoaXMuc3BlY2lhbGl6ZXJTcGVjcy5tYXAoZ2V0U3BlY2lhbGl6ZXIpO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVzLCBVaW50MzJBcnJheSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVEYXRhKTtcbiAgICAgICAgdGhpcy5nb3RvID0gZGVjb2RlQXJyYXkoc3BlYy5nb3RvKTtcbiAgICAgICAgdGhpcy5tYXhUZXJtID0gc3BlYy5tYXhUZXJtO1xuICAgICAgICB0aGlzLnRva2VuaXplcnMgPSBzcGVjLnRva2VuaXplcnMubWFwKHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiID8gbmV3IFRva2VuR3JvdXAodG9rZW5BcnJheSwgdmFsdWUpIDogdmFsdWUpO1xuICAgICAgICB0aGlzLnRvcFJ1bGVzID0gc3BlYy50b3BSdWxlcztcbiAgICAgICAgdGhpcy5kaWFsZWN0cyA9IHNwZWMuZGlhbGVjdHMgfHwge307XG4gICAgICAgIHRoaXMuZHluYW1pY1ByZWNlZGVuY2VzID0gc3BlYy5keW5hbWljUHJlY2VkZW5jZXMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy50b2tlblByZWNUYWJsZSA9IHNwZWMudG9rZW5QcmVjO1xuICAgICAgICB0aGlzLnRlcm1OYW1lcyA9IHNwZWMudGVybU5hbWVzIHx8IG51bGw7XG4gICAgICAgIHRoaXMubWF4Tm9kZSA9IHRoaXMubm9kZVNldC50eXBlcy5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLmRpYWxlY3QgPSB0aGlzLnBhcnNlRGlhbGVjdCgpO1xuICAgICAgICB0aGlzLnRvcCA9IHRoaXMudG9wUnVsZXNbT2JqZWN0LmtleXModGhpcy50b3BSdWxlcylbMF1dO1xuICAgIH1cbiAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgbGV0IHBhcnNlID0gbmV3IFBhcnNlKHRoaXMsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgIGZvciAobGV0IHcgb2YgdGhpcy53cmFwcGVycylcbiAgICAgICAgICAgIHBhcnNlID0gdyhwYXJzZSwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgZ290byB0YWJsZSBlbnRyeSBAaW50ZXJuYWxcbiAgICBnZXRHb3RvKHN0YXRlLCB0ZXJtLCBsb29zZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCB0YWJsZSA9IHRoaXMuZ290bztcbiAgICAgICAgaWYgKHRlcm0gPj0gdGFibGVbMF0pXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHRhYmxlW3Rlcm0gKyAxXTs7KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBUYWcgPSB0YWJsZVtwb3MrK10sIGxhc3QgPSBncm91cFRhZyAmIDE7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGFibGVbcG9zKytdO1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbG9vc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGZvciAobGV0IGVuZCA9IHBvcyArIChncm91cFRhZyA+PiAxKTsgcG9zIDwgZW5kOyBwb3MrKylcbiAgICAgICAgICAgICAgICBpZiAodGFibGVbcG9zXSA9PSBzdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gQ2hlY2sgaWYgdGhpcyBzdGF0ZSBoYXMgYW4gYWN0aW9uIGZvciBhIGdpdmVuIHRlcm1pbmFsIEBpbnRlcm5hbFxuICAgIGhhc0FjdGlvbihzdGF0ZSwgdGVybWluYWwpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGZvciAobGV0IHNldCA9IDA7IHNldCA8IDI7IHNldCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogUGFyc2VTdGF0ZS5Ta2lwICovIDogMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pLCBuZXh0OzsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKChuZXh0ID0gZGF0YVtpXSkgPT0gNjU1MzUgLyogU2VxLkVuZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpICsgMV0gPT0gMSAvKiBTZXEuTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBkYXRhW2kgPSBwYWlyKGRhdGEsIGkgKyAyKV07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFbaSArIDFdID09IDIgLyogU2VxLk90aGVyICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhaXIoZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gdGVybWluYWwgfHwgbmV4dCA9PSAwIC8qIFRlcm0uRXJyICovKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzdGF0ZVNsb3Qoc3RhdGUsIHNsb3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzWyhzdGF0ZSAqIDYgLyogUGFyc2VTdGF0ZS5TaXplICovKSArIHNsb3RdO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc3RhdGVGbGFnKHN0YXRlLCBmbGFnKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDAgLyogUGFyc2VTdGF0ZS5GbGFncyAqLykgJiBmbGFnKSA+IDA7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB2YWxpZEFjdGlvbihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuYWxsQWN0aW9ucyhzdGF0ZSwgYSA9PiBhID09IGFjdGlvbiA/IHRydWUgOiBudWxsKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGFsbEFjdGlvbnMoc3RhdGUsIGFjdGlvbikge1xuICAgICAgICBsZXQgZGVmbHQgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgNCAvKiBQYXJzZVN0YXRlLkRlZmF1bHRSZWR1Y2UgKi8pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gZGVmbHQgPyBhY3Rpb24oZGVmbHQpIDogdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDEgLyogUGFyc2VTdGF0ZS5BY3Rpb25zICovKTsgcmVzdWx0ID09IG51bGw7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpICsgMV0gPT0gMSAvKiBTZXEuTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIodGhpcy5kYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IGFjdGlvbihwYWlyKHRoaXMuZGF0YSwgaSArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBzdGF0ZXMgdGhhdCBjYW4gZm9sbG93IHRoaXMgb25lIHRocm91Z2ggc2hpZnQgYWN0aW9ucyBvclxuICAgIC8vLyBnb3RvIGp1bXBzLiBAaW50ZXJuYWxcbiAgICBuZXh0U3RhdGVzKHN0YXRlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCAxIC8qIFBhcnNlU3RhdGUuQWN0aW9ucyAqLyk7OyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPT0gNjU1MzUgLyogU2VxLkVuZCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaSArIDFdID09IDEgLyogU2VxLk5leHQgKi8pXG4gICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKHRoaXMuZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRoaXMuZGF0YVtpICsgMl0gJiAoNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8gPj4gMTYpKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5kYXRhW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5zb21lKCh2LCBpKSA9PiAoaSAmIDEpICYmIHYgPT0gdmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmRhdGFbaV0sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLy8gQ29uZmlndXJlIHRoZSBwYXJzZXIuIFJldHVybnMgYSBuZXcgcGFyc2VyIGluc3RhbmNlIHRoYXQgaGFzIHRoZVxuICAgIC8vLyBnaXZlbiBzZXR0aW5ncyBtb2RpZmllZC4gU2V0dGluZ3Mgbm90IHByb3ZpZGVkIGluIGBjb25maWdgIGFyZVxuICAgIC8vLyBrZXB0IGZyb20gdGhlIG9yaWdpbmFsIHBhcnNlci5cbiAgICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgICAgIC8vIEhpZGVvdXMgcmVmbGVjdGlvbi1iYXNlZCBrbHVkZ2UgdG8gbWFrZSBpdCBlYXN5IHRvIGNyZWF0ZSBhXG4gICAgICAgIC8vIHNsaWdodGx5IG1vZGlmaWVkIGNvcHkgb2YgYSBwYXJzZXIuXG4gICAgICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKExSUGFyc2VyLnByb3RvdHlwZSksIHRoaXMpO1xuICAgICAgICBpZiAoY29uZmlnLnByb3BzKVxuICAgICAgICAgICAgY29weS5ub2RlU2V0ID0gdGhpcy5ub2RlU2V0LmV4dGVuZCguLi5jb25maWcucHJvcHMpO1xuICAgICAgICBpZiAoY29uZmlnLnRvcCkge1xuICAgICAgICAgICAgbGV0IGluZm8gPSB0aGlzLnRvcFJ1bGVzW2NvbmZpZy50b3BdO1xuICAgICAgICAgICAgaWYgKCFpbmZvKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIHRvcCBydWxlIG5hbWUgJHtjb25maWcudG9wfWApO1xuICAgICAgICAgICAgY29weS50b3AgPSBpbmZvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcudG9rZW5pemVycylcbiAgICAgICAgICAgIGNvcHkudG9rZW5pemVycyA9IHRoaXMudG9rZW5pemVycy5tYXAodCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gY29uZmlnLnRva2VuaXplcnMuZmluZChyID0+IHIuZnJvbSA9PSB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQgPyBmb3VuZC50byA6IHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5zcGVjaWFsaXplcnMpIHtcbiAgICAgICAgICAgIGNvcHkuc3BlY2lhbGl6ZXJzID0gdGhpcy5zcGVjaWFsaXplcnMuc2xpY2UoKTtcbiAgICAgICAgICAgIGNvcHkuc3BlY2lhbGl6ZXJTcGVjcyA9IHRoaXMuc3BlY2lhbGl6ZXJTcGVjcy5tYXAoKHMsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBjb25maWcuc3BlY2lhbGl6ZXJzLmZpbmQociA9PiByLmZyb20gPT0gcy5leHRlcm5hbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgbGV0IHNwZWMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHMpLCB7IGV4dGVybmFsOiBmb3VuZC50byB9KTtcbiAgICAgICAgICAgICAgICBjb3B5LnNwZWNpYWxpemVyc1tpXSA9IGdldFNwZWNpYWxpemVyKHNwZWMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGVjO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5jb250ZXh0VHJhY2tlcilcbiAgICAgICAgICAgIGNvcHkuY29udGV4dCA9IGNvbmZpZy5jb250ZXh0VHJhY2tlcjtcbiAgICAgICAgaWYgKGNvbmZpZy5kaWFsZWN0KVxuICAgICAgICAgICAgY29weS5kaWFsZWN0ID0gdGhpcy5wYXJzZURpYWxlY3QoY29uZmlnLmRpYWxlY3QpO1xuICAgICAgICBpZiAoY29uZmlnLnN0cmljdCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5zdHJpY3QgPSBjb25maWcuc3RyaWN0O1xuICAgICAgICBpZiAoY29uZmlnLndyYXApXG4gICAgICAgICAgICBjb3B5LndyYXBwZXJzID0gY29weS53cmFwcGVycy5jb25jYXQoY29uZmlnLndyYXApO1xuICAgICAgICBpZiAoY29uZmlnLmJ1ZmZlckxlbmd0aCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5idWZmZXJMZW5ndGggPSBjb25maWcuYnVmZmVyTGVuZ3RoO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLy8vIFRlbGxzIHlvdSB3aGV0aGVyIGFueSBbcGFyc2Ugd3JhcHBlcnNdKCNsci5QYXJzZXJDb25maWcud3JhcClcbiAgICAvLy8gYXJlIHJlZ2lzdGVyZWQgZm9yIHRoaXMgcGFyc2VyLlxuICAgIGhhc1dyYXBwZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVycy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvLy8gUmV0dXJucyB0aGUgbmFtZSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiB0ZXJtLiBUaGlzIHdpbGwgb25seVxuICAgIC8vLyB3b3JrIGZvciBhbGwgdGVybXMgd2hlbiB0aGUgcGFyc2VyIHdhcyBnZW5lcmF0ZWQgd2l0aCB0aGVcbiAgICAvLy8gYC0tbmFtZXNgIG9wdGlvbi4gQnkgZGVmYXVsdCwgb25seSB0aGUgbmFtZXMgb2YgdGFnZ2VkIHRlcm1zIGFyZVxuICAgIC8vLyBzdG9yZWQuXG4gICAgZ2V0TmFtZSh0ZXJtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlcm1OYW1lcyA/IHRoaXMudGVybU5hbWVzW3Rlcm1dIDogU3RyaW5nKHRlcm0gPD0gdGhpcy5tYXhOb2RlICYmIHRoaXMubm9kZVNldC50eXBlc1t0ZXJtXS5uYW1lIHx8IHRlcm0pO1xuICAgIH1cbiAgICAvLy8gVGhlIGVvZiB0ZXJtIGlkIGlzIGFsd2F5cyBhbGxvY2F0ZWQgZGlyZWN0bHkgYWZ0ZXIgdGhlIG5vZGVcbiAgICAvLy8gdHlwZXMuIEBpbnRlcm5hbFxuICAgIGdldCBlb2ZUZXJtKCkgeyByZXR1cm4gdGhpcy5tYXhOb2RlICsgMTsgfVxuICAgIC8vLyBUaGUgdHlwZSBvZiB0b3Agbm9kZSBwcm9kdWNlZCBieSB0aGUgcGFyc2VyLlxuICAgIGdldCB0b3BOb2RlKCkgeyByZXR1cm4gdGhpcy5ub2RlU2V0LnR5cGVzW3RoaXMudG9wWzFdXTsgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBkeW5hbWljUHJlY2VkZW5jZSh0ZXJtKSB7XG4gICAgICAgIGxldCBwcmVjID0gdGhpcy5keW5hbWljUHJlY2VkZW5jZXM7XG4gICAgICAgIHJldHVybiBwcmVjID09IG51bGwgPyAwIDogcHJlY1t0ZXJtXSB8fCAwO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgcGFyc2VEaWFsZWN0KGRpYWxlY3QpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IE9iamVjdC5rZXlzKHRoaXMuZGlhbGVjdHMpLCBmbGFncyA9IHZhbHVlcy5tYXAoKCkgPT4gZmFsc2UpO1xuICAgICAgICBpZiAoZGlhbGVjdClcbiAgICAgICAgICAgIGZvciAobGV0IHBhcnQgb2YgZGlhbGVjdC5zcGxpdChcIiBcIikpIHtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSB2YWx1ZXMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoaWQgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3NbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IGRpc2FibGVkID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWZsYWdzW2ldKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IHRoaXMuZGlhbGVjdHNbdmFsdWVzW2ldXSwgaWQ7IChpZCA9IHRoaXMuZGF0YVtqKytdKSAhPSA2NTUzNSAvKiBTZXEuRW5kICovOylcbiAgICAgICAgICAgICAgICAgICAgKGRpc2FibGVkIHx8IChkaXNhYmxlZCA9IG5ldyBVaW50OEFycmF5KHRoaXMubWF4VGVybSArIDEpKSlbaWRdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEaWFsZWN0KGRpYWxlY3QsIGZsYWdzLCBkaXNhYmxlZCk7XG4gICAgfVxuICAgIC8vLyBVc2VkIGJ5IHRoZSBvdXRwdXQgb2YgdGhlIHBhcnNlciBnZW5lcmF0b3IuIE5vdCBhdmFpbGFibGUgdG9cbiAgICAvLy8gdXNlciBjb2RlLiBAaGlkZVxuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgTFJQYXJzZXIoc3BlYyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFpcihkYXRhLCBvZmYpIHsgcmV0dXJuIGRhdGFbb2ZmXSB8IChkYXRhW29mZiArIDFdIDw8IDE2KTsgfVxuZnVuY3Rpb24gZmluZEZpbmlzaGVkKHN0YWNrcykge1xuICAgIGxldCBiZXN0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBzdGFjayBvZiBzdGFja3MpIHtcbiAgICAgICAgbGV0IHN0b3BwZWQgPSBzdGFjay5wLnN0b3BwZWRBdDtcbiAgICAgICAgaWYgKChzdGFjay5wb3MgPT0gc3RhY2sucC5zdHJlYW0uZW5kIHx8IHN0b3BwZWQgIT0gbnVsbCAmJiBzdGFjay5wb3MgPiBzdG9wcGVkKSAmJlxuICAgICAgICAgICAgc3RhY2sucC5wYXJzZXIuc3RhdGVGbGFnKHN0YWNrLnN0YXRlLCAyIC8qIFN0YXRlRmxhZy5BY2NlcHRpbmcgKi8pICYmXG4gICAgICAgICAgICAoIWJlc3QgfHwgYmVzdC5zY29yZSA8IHN0YWNrLnNjb3JlKSlcbiAgICAgICAgICAgIGJlc3QgPSBzdGFjaztcbiAgICB9XG4gICAgcmV0dXJuIGJlc3Q7XG59XG5mdW5jdGlvbiBnZXRTcGVjaWFsaXplcihzcGVjKSB7XG4gICAgaWYgKHNwZWMuZXh0ZXJuYWwpIHtcbiAgICAgICAgbGV0IG1hc2sgPSBzcGVjLmV4dGVuZCA/IDEgLyogU3BlY2lhbGl6ZS5FeHRlbmQgKi8gOiAwIC8qIFNwZWNpYWxpemUuU3BlY2lhbGl6ZSAqLztcbiAgICAgICAgcmV0dXJuICh2YWx1ZSwgc3RhY2spID0+IChzcGVjLmV4dGVybmFsKHZhbHVlLCBzdGFjaykgPDwgMSkgfCBtYXNrO1xuICAgIH1cbiAgICByZXR1cm4gc3BlYy5nZXQ7XG59XG5cbmV4cG9ydCB7IENvbnRleHRUcmFja2VyLCBFeHRlcm5hbFRva2VuaXplciwgSW5wdXRTdHJlYW0sIExSUGFyc2VyLCBMb2NhbFRva2VuR3JvdXAsIFN0YWNrIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/lr/dist/index.js\n");

/***/ })

};
;