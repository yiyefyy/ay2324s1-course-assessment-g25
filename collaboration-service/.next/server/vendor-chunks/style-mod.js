"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/style-mod";
exports.ids = ["vendor-chunks/style-mod"];
exports.modules = {

/***/ "(ssr)/./node_modules/style-mod/src/style-mod.js":
/*!*************************************************!*\
  !*** ./node_modules/style-mod/src/style-mod.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StyleModule: () => (/* binding */ StyleModule)\n/* harmony export */ });\nconst C = \"\\u037c\"\nconst COUNT = typeof Symbol == \"undefined\" ? \"__\" + C : Symbol.for(C)\nconst SET = typeof Symbol == \"undefined\" ? \"__styleSet\" + Math.floor(Math.random() * 1e8) : Symbol(\"styleSet\")\nconst top = typeof globalThis != \"undefined\" ? globalThis : typeof window != \"undefined\" ? window : {}\n\n// :: - Style modules encapsulate a set of CSS rules defined from\n// JavaScript. Their definitions are only available in a given DOM\n// root after it has been _mounted_ there with `StyleModule.mount`.\n//\n// Style modules should be created once and stored somewhere, as\n// opposed to re-creating them every time you need them. The amount of\n// CSS rules generated for a given DOM root is bounded by the amount\n// of style modules that were used. So to avoid leaking rules, don't\n// create these dynamically, but treat them as one-time allocations.\nclass StyleModule {\n  // :: (Object<Style>, ?{finish: ?(string) → string})\n  // Create a style module from the given spec.\n  //\n  // When `finish` is given, it is called on regular (non-`@`)\n  // selectors (after `&` expansion) to compute the final selector.\n  constructor(spec, options) {\n    this.rules = []\n    let {finish} = options || {}\n\n    function splitSelector(selector) {\n      return /^@/.test(selector) ? [selector] : selector.split(/,\\s*/)\n    }\n\n    function render(selectors, spec, target, isKeyframes) {\n      let local = [], isAt = /^@(\\w+)\\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == \"keyframes\"\n      if (isAt && spec == null) return target.push(selectors[0] + \";\")\n      for (let prop in spec) {\n        let value = spec[prop]\n        if (/&/.test(prop)) {\n          render(prop.split(/,\\s*/).map(part => selectors.map(sel => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)),\n                 value, target)\n        } else if (value && typeof value == \"object\") {\n          if (!isAt) throw new RangeError(\"The value of a property (\" + prop + \") should be a primitive value.\")\n          render(splitSelector(prop), value, local, keyframes)\n        } else if (value != null) {\n          local.push(prop.replace(/_.*/, \"\").replace(/[A-Z]/g, l => \"-\" + l.toLowerCase()) + \": \" + value + \";\")\n        }\n      }\n      if (local.length || keyframes) {\n        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(\", \") +\n                    \" {\" + local.join(\" \") + \"}\")\n      }\n    }\n\n    for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules)\n  }\n\n  // :: () → string\n  // Returns a string containing the module's CSS rules.\n  getRules() { return this.rules.join(\"\\n\") }\n\n  // :: () → string\n  // Generate a new unique CSS class name.\n  static newName() {\n    let id = top[COUNT] || 1\n    top[COUNT] = id + 1\n    return C + id.toString(36)\n  }\n\n  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})\n  //\n  // Mount the given set of modules in the given DOM root, which ensures\n  // that the CSS rules defined by the module are available in that\n  // context.\n  //\n  // Rules are only added to the document once per root.\n  //\n  // Rule order will follow the order of the modules, so that rules from\n  // modules later in the array take precedence of those from earlier\n  // modules. If you call this function multiple times for the same root\n  // in a way that changes the order of already mounted modules, the old\n  // order will be changed.\n  //\n  // If a Content Security Policy nonce is provided, it is added to\n  // the `<style>` tag generated by the library.\n  static mount(root, modules, options) {\n    let set = root[SET], nonce = options && options.nonce\n    if (!set) set = new StyleSet(root, nonce)\n    else if (nonce) set.setNonce(nonce)\n    set.mount(Array.isArray(modules) ? modules : [modules])\n  }\n}\n\nlet adoptedSet = new Map //<Document, StyleSet>\n\nclass StyleSet {\n  constructor(root, nonce) {\n    let doc = root.ownerDocument || root, win = doc.defaultView\n    if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {\n      let adopted = adoptedSet.get(doc)\n      if (adopted) {\n        root.adoptedStyleSheets = [adopted.sheet, ...root.adoptedStyleSheets]\n        return root[SET] = adopted\n      }\n      this.sheet = new win.CSSStyleSheet\n      root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets]\n      adoptedSet.set(doc, this)\n    } else {\n      this.styleTag = doc.createElement(\"style\")\n      if (nonce) this.styleTag.setAttribute(\"nonce\", nonce)\n      let target = root.head || root\n      target.insertBefore(this.styleTag, target.firstChild)\n    }\n    this.modules = []\n    root[SET] = this\n  }\n\n  mount(modules) {\n    let sheet = this.sheet\n    let pos = 0 /* Current rule offset */, j = 0 /* Index into this.modules */\n    for (let i = 0; i < modules.length; i++) {\n      let mod = modules[i], index = this.modules.indexOf(mod)\n      if (index < j && index > -1) { // Ordering conflict\n        this.modules.splice(index, 1)\n        j--\n        index = -1\n      }\n      if (index == -1) {\n        this.modules.splice(j++, 0, mod)\n        if (sheet) for (let k = 0; k < mod.rules.length; k++)\n          sheet.insertRule(mod.rules[k], pos++)\n      } else {\n        while (j < index) pos += this.modules[j++].rules.length\n        pos += mod.rules.length\n        j++\n      }\n    }\n\n    if (!sheet) {\n      let text = \"\"\n      for (let i = 0; i < this.modules.length; i++)\n        text += this.modules[i].getRules() + \"\\n\"\n      this.styleTag.textContent = text\n    }\n  }\n\n  setNonce(nonce) {\n    if (this.styleTag && this.styleTag.getAttribute(\"nonce\") != nonce)\n      this.styleTag.setAttribute(\"nonce\", nonce)\n  }\n}\n\n// Style::Object<union<Style,string>>\n//\n// A style is an object that, in the simple case, maps CSS property\n// names to strings holding their values, as in `{color: \"red\",\n// fontWeight: \"bold\"}`. The property names can be given in\n// camel-case—the library will insert a dash before capital letters\n// when converting them to CSS.\n//\n// If you include an underscore in a property name, it and everything\n// after it will be removed from the output, which can be useful when\n// providing a property multiple times, for browser compatibility\n// reasons.\n//\n// A property in a style object can also be a sub-selector, which\n// extends the current context to add a pseudo-selector or a child\n// selector. Such a property should contain a `&` character, which\n// will be replaced by the current selector. For example `{\"&:before\":\n// {content: '\"hi\"'}}`. Sub-selectors and regular properties can\n// freely be mixed in a given object. Any property containing a `&` is\n// assumed to be a sub-selector.\n//\n// Finally, a property can specify an @-block to be wrapped around the\n// styles defined inside the object that's the property's value. For\n// example to create a media query you can do `{\"@media screen and\n// (min-width: 400px)\": {...}}`.\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3R5bGUtbW9kL3NyYy9zdHlsZS1tb2QuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsMEJBQTBCLDJCQUEyQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFFBQVE7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDViw4R0FBOEc7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyRUFBMkUsZUFBZTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzQkFBc0I7QUFDekQ7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxJQUFJLGlCQUFpQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELHlCQUF5QixLQUFLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGxpdmVibG9ja3MtZXhhbXBsZXMvbmV4dGpzLXlqcy1jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL3N0eWxlLW1vZC9zcmMvc3R5bGUtbW9kLmpzPzM1YzUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQyA9IFwiXFx1MDM3Y1wiXG5jb25zdCBDT1VOVCA9IHR5cGVvZiBTeW1ib2wgPT0gXCJ1bmRlZmluZWRcIiA/IFwiX19cIiArIEMgOiBTeW1ib2wuZm9yKEMpXG5jb25zdCBTRVQgPSB0eXBlb2YgU3ltYm9sID09IFwidW5kZWZpbmVkXCIgPyBcIl9fc3R5bGVTZXRcIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlOCkgOiBTeW1ib2woXCJzdHlsZVNldFwiKVxuY29uc3QgdG9wID0gdHlwZW9mIGdsb2JhbFRoaXMgIT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fVxuXG4vLyA6OiAtIFN0eWxlIG1vZHVsZXMgZW5jYXBzdWxhdGUgYSBzZXQgb2YgQ1NTIHJ1bGVzIGRlZmluZWQgZnJvbVxuLy8gSmF2YVNjcmlwdC4gVGhlaXIgZGVmaW5pdGlvbnMgYXJlIG9ubHkgYXZhaWxhYmxlIGluIGEgZ2l2ZW4gRE9NXG4vLyByb290IGFmdGVyIGl0IGhhcyBiZWVuIF9tb3VudGVkXyB0aGVyZSB3aXRoIGBTdHlsZU1vZHVsZS5tb3VudGAuXG4vL1xuLy8gU3R5bGUgbW9kdWxlcyBzaG91bGQgYmUgY3JlYXRlZCBvbmNlIGFuZCBzdG9yZWQgc29tZXdoZXJlLCBhc1xuLy8gb3Bwb3NlZCB0byByZS1jcmVhdGluZyB0aGVtIGV2ZXJ5IHRpbWUgeW91IG5lZWQgdGhlbS4gVGhlIGFtb3VudCBvZlxuLy8gQ1NTIHJ1bGVzIGdlbmVyYXRlZCBmb3IgYSBnaXZlbiBET00gcm9vdCBpcyBib3VuZGVkIGJ5IHRoZSBhbW91bnRcbi8vIG9mIHN0eWxlIG1vZHVsZXMgdGhhdCB3ZXJlIHVzZWQuIFNvIHRvIGF2b2lkIGxlYWtpbmcgcnVsZXMsIGRvbid0XG4vLyBjcmVhdGUgdGhlc2UgZHluYW1pY2FsbHksIGJ1dCB0cmVhdCB0aGVtIGFzIG9uZS10aW1lIGFsbG9jYXRpb25zLlxuZXhwb3J0IGNsYXNzIFN0eWxlTW9kdWxlIHtcbiAgLy8gOjogKE9iamVjdDxTdHlsZT4sID97ZmluaXNoOiA/KHN0cmluZykg4oaSIHN0cmluZ30pXG4gIC8vIENyZWF0ZSBhIHN0eWxlIG1vZHVsZSBmcm9tIHRoZSBnaXZlbiBzcGVjLlxuICAvL1xuICAvLyBXaGVuIGBmaW5pc2hgIGlzIGdpdmVuLCBpdCBpcyBjYWxsZWQgb24gcmVndWxhciAobm9uLWBAYClcbiAgLy8gc2VsZWN0b3JzIChhZnRlciBgJmAgZXhwYW5zaW9uKSB0byBjb21wdXRlIHRoZSBmaW5hbCBzZWxlY3Rvci5cbiAgY29uc3RydWN0b3Ioc3BlYywgb3B0aW9ucykge1xuICAgIHRoaXMucnVsZXMgPSBbXVxuICAgIGxldCB7ZmluaXNofSA9IG9wdGlvbnMgfHwge31cblxuICAgIGZ1bmN0aW9uIHNwbGl0U2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiAvXkAvLnRlc3Qoc2VsZWN0b3IpID8gW3NlbGVjdG9yXSA6IHNlbGVjdG9yLnNwbGl0KC8sXFxzKi8pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyKHNlbGVjdG9ycywgc3BlYywgdGFyZ2V0LCBpc0tleWZyYW1lcykge1xuICAgICAgbGV0IGxvY2FsID0gW10sIGlzQXQgPSAvXkAoXFx3KylcXGIvLmV4ZWMoc2VsZWN0b3JzWzBdKSwga2V5ZnJhbWVzID0gaXNBdCAmJiBpc0F0WzFdID09IFwia2V5ZnJhbWVzXCJcbiAgICAgIGlmIChpc0F0ICYmIHNwZWMgPT0gbnVsbCkgcmV0dXJuIHRhcmdldC5wdXNoKHNlbGVjdG9yc1swXSArIFwiO1wiKVxuICAgICAgZm9yIChsZXQgcHJvcCBpbiBzcGVjKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHNwZWNbcHJvcF1cbiAgICAgICAgaWYgKC8mLy50ZXN0KHByb3ApKSB7XG4gICAgICAgICAgcmVuZGVyKHByb3Auc3BsaXQoLyxcXHMqLykubWFwKHBhcnQgPT4gc2VsZWN0b3JzLm1hcChzZWwgPT4gcGFydC5yZXBsYWNlKC8mLywgc2VsKSkpLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpLFxuICAgICAgICAgICAgICAgICB2YWx1ZSwgdGFyZ2V0KVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgaWYgKCFpc0F0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IChcIiArIHByb3AgKyBcIikgc2hvdWxkIGJlIGEgcHJpbWl0aXZlIHZhbHVlLlwiKVxuICAgICAgICAgIHJlbmRlcihzcGxpdFNlbGVjdG9yKHByb3ApLCB2YWx1ZSwgbG9jYWwsIGtleWZyYW1lcylcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgbG9jYWwucHVzaChwcm9wLnJlcGxhY2UoL18uKi8sIFwiXCIpLnJlcGxhY2UoL1tBLVpdL2csIGwgPT4gXCItXCIgKyBsLnRvTG93ZXJDYXNlKCkpICsgXCI6IFwiICsgdmFsdWUgKyBcIjtcIilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvY2FsLmxlbmd0aCB8fCBrZXlmcmFtZXMpIHtcbiAgICAgICAgdGFyZ2V0LnB1c2goKGZpbmlzaCAmJiAhaXNBdCAmJiAhaXNLZXlmcmFtZXMgPyBzZWxlY3RvcnMubWFwKGZpbmlzaCkgOiBzZWxlY3RvcnMpLmpvaW4oXCIsIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiIHtcIiArIGxvY2FsLmpvaW4oXCIgXCIpICsgXCJ9XCIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgcHJvcCBpbiBzcGVjKSByZW5kZXIoc3BsaXRTZWxlY3Rvcihwcm9wKSwgc3BlY1twcm9wXSwgdGhpcy5ydWxlcylcbiAgfVxuXG4gIC8vIDo6ICgpIOKGkiBzdHJpbmdcbiAgLy8gUmV0dXJucyBhIHN0cmluZyBjb250YWluaW5nIHRoZSBtb2R1bGUncyBDU1MgcnVsZXMuXG4gIGdldFJ1bGVzKCkgeyByZXR1cm4gdGhpcy5ydWxlcy5qb2luKFwiXFxuXCIpIH1cblxuICAvLyA6OiAoKSDihpIgc3RyaW5nXG4gIC8vIEdlbmVyYXRlIGEgbmV3IHVuaXF1ZSBDU1MgY2xhc3MgbmFtZS5cbiAgc3RhdGljIG5ld05hbWUoKSB7XG4gICAgbGV0IGlkID0gdG9wW0NPVU5UXSB8fCAxXG4gICAgdG9wW0NPVU5UXSA9IGlkICsgMVxuICAgIHJldHVybiBDICsgaWQudG9TdHJpbmcoMzYpXG4gIH1cblxuICAvLyA6OiAodW5pb248RG9jdW1lbnQsIFNoYWRvd1Jvb3Q+LCB1bmlvbjxbU3R5bGVNb2R1bGVdLCBTdHlsZU1vZHVsZT4sID97bm9uY2U6ID9zdHJpbmd9KVxuICAvL1xuICAvLyBNb3VudCB0aGUgZ2l2ZW4gc2V0IG9mIG1vZHVsZXMgaW4gdGhlIGdpdmVuIERPTSByb290LCB3aGljaCBlbnN1cmVzXG4gIC8vIHRoYXQgdGhlIENTUyBydWxlcyBkZWZpbmVkIGJ5IHRoZSBtb2R1bGUgYXJlIGF2YWlsYWJsZSBpbiB0aGF0XG4gIC8vIGNvbnRleHQuXG4gIC8vXG4gIC8vIFJ1bGVzIGFyZSBvbmx5IGFkZGVkIHRvIHRoZSBkb2N1bWVudCBvbmNlIHBlciByb290LlxuICAvL1xuICAvLyBSdWxlIG9yZGVyIHdpbGwgZm9sbG93IHRoZSBvcmRlciBvZiB0aGUgbW9kdWxlcywgc28gdGhhdCBydWxlcyBmcm9tXG4gIC8vIG1vZHVsZXMgbGF0ZXIgaW4gdGhlIGFycmF5IHRha2UgcHJlY2VkZW5jZSBvZiB0aG9zZSBmcm9tIGVhcmxpZXJcbiAgLy8gbW9kdWxlcy4gSWYgeW91IGNhbGwgdGhpcyBmdW5jdGlvbiBtdWx0aXBsZSB0aW1lcyBmb3IgdGhlIHNhbWUgcm9vdFxuICAvLyBpbiBhIHdheSB0aGF0IGNoYW5nZXMgdGhlIG9yZGVyIG9mIGFscmVhZHkgbW91bnRlZCBtb2R1bGVzLCB0aGUgb2xkXG4gIC8vIG9yZGVyIHdpbGwgYmUgY2hhbmdlZC5cbiAgLy9cbiAgLy8gSWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBub25jZSBpcyBwcm92aWRlZCwgaXQgaXMgYWRkZWQgdG9cbiAgLy8gdGhlIGA8c3R5bGU+YCB0YWcgZ2VuZXJhdGVkIGJ5IHRoZSBsaWJyYXJ5LlxuICBzdGF0aWMgbW91bnQocm9vdCwgbW9kdWxlcywgb3B0aW9ucykge1xuICAgIGxldCBzZXQgPSByb290W1NFVF0sIG5vbmNlID0gb3B0aW9ucyAmJiBvcHRpb25zLm5vbmNlXG4gICAgaWYgKCFzZXQpIHNldCA9IG5ldyBTdHlsZVNldChyb290LCBub25jZSlcbiAgICBlbHNlIGlmIChub25jZSkgc2V0LnNldE5vbmNlKG5vbmNlKVxuICAgIHNldC5tb3VudChBcnJheS5pc0FycmF5KG1vZHVsZXMpID8gbW9kdWxlcyA6IFttb2R1bGVzXSlcbiAgfVxufVxuXG5sZXQgYWRvcHRlZFNldCA9IG5ldyBNYXAgLy88RG9jdW1lbnQsIFN0eWxlU2V0PlxuXG5jbGFzcyBTdHlsZVNldCB7XG4gIGNvbnN0cnVjdG9yKHJvb3QsIG5vbmNlKSB7XG4gICAgbGV0IGRvYyA9IHJvb3Qub3duZXJEb2N1bWVudCB8fCByb290LCB3aW4gPSBkb2MuZGVmYXVsdFZpZXdcbiAgICBpZiAoIXJvb3QuaGVhZCAmJiByb290LmFkb3B0ZWRTdHlsZVNoZWV0cyAmJiB3aW4uQ1NTU3R5bGVTaGVldCkge1xuICAgICAgbGV0IGFkb3B0ZWQgPSBhZG9wdGVkU2V0LmdldChkb2MpXG4gICAgICBpZiAoYWRvcHRlZCkge1xuICAgICAgICByb290LmFkb3B0ZWRTdHlsZVNoZWV0cyA9IFthZG9wdGVkLnNoZWV0LCAuLi5yb290LmFkb3B0ZWRTdHlsZVNoZWV0c11cbiAgICAgICAgcmV0dXJuIHJvb3RbU0VUXSA9IGFkb3B0ZWRcbiAgICAgIH1cbiAgICAgIHRoaXMuc2hlZXQgPSBuZXcgd2luLkNTU1N0eWxlU2hlZXRcbiAgICAgIHJvb3QuYWRvcHRlZFN0eWxlU2hlZXRzID0gW3RoaXMuc2hlZXQsIC4uLnJvb3QuYWRvcHRlZFN0eWxlU2hlZXRzXVxuICAgICAgYWRvcHRlZFNldC5zZXQoZG9jLCB0aGlzKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0eWxlVGFnID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKVxuICAgICAgaWYgKG5vbmNlKSB0aGlzLnN0eWxlVGFnLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKVxuICAgICAgbGV0IHRhcmdldCA9IHJvb3QuaGVhZCB8fCByb290XG4gICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKHRoaXMuc3R5bGVUYWcsIHRhcmdldC5maXJzdENoaWxkKVxuICAgIH1cbiAgICB0aGlzLm1vZHVsZXMgPSBbXVxuICAgIHJvb3RbU0VUXSA9IHRoaXNcbiAgfVxuXG4gIG1vdW50KG1vZHVsZXMpIHtcbiAgICBsZXQgc2hlZXQgPSB0aGlzLnNoZWV0XG4gICAgbGV0IHBvcyA9IDAgLyogQ3VycmVudCBydWxlIG9mZnNldCAqLywgaiA9IDAgLyogSW5kZXggaW50byB0aGlzLm1vZHVsZXMgKi9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBtb2QgPSBtb2R1bGVzW2ldLCBpbmRleCA9IHRoaXMubW9kdWxlcy5pbmRleE9mKG1vZClcbiAgICAgIGlmIChpbmRleCA8IGogJiYgaW5kZXggPiAtMSkgeyAvLyBPcmRlcmluZyBjb25mbGljdFxuICAgICAgICB0aGlzLm1vZHVsZXMuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICBqLS1cbiAgICAgICAgaW5kZXggPSAtMVxuICAgICAgfVxuICAgICAgaWYgKGluZGV4ID09IC0xKSB7XG4gICAgICAgIHRoaXMubW9kdWxlcy5zcGxpY2UoaisrLCAwLCBtb2QpXG4gICAgICAgIGlmIChzaGVldCkgZm9yIChsZXQgayA9IDA7IGsgPCBtb2QucnVsZXMubGVuZ3RoOyBrKyspXG4gICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShtb2QucnVsZXNba10sIHBvcysrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKGogPCBpbmRleCkgcG9zICs9IHRoaXMubW9kdWxlc1tqKytdLnJ1bGVzLmxlbmd0aFxuICAgICAgICBwb3MgKz0gbW9kLnJ1bGVzLmxlbmd0aFxuICAgICAgICBqKytcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXNoZWV0KSB7XG4gICAgICBsZXQgdGV4dCA9IFwiXCJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tb2R1bGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICB0ZXh0ICs9IHRoaXMubW9kdWxlc1tpXS5nZXRSdWxlcygpICsgXCJcXG5cIlxuICAgICAgdGhpcy5zdHlsZVRhZy50ZXh0Q29udGVudCA9IHRleHRcbiAgICB9XG4gIH1cblxuICBzZXROb25jZShub25jZSkge1xuICAgIGlmICh0aGlzLnN0eWxlVGFnICYmIHRoaXMuc3R5bGVUYWcuZ2V0QXR0cmlidXRlKFwibm9uY2VcIikgIT0gbm9uY2UpXG4gICAgICB0aGlzLnN0eWxlVGFnLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKVxuICB9XG59XG5cbi8vIFN0eWxlOjpPYmplY3Q8dW5pb248U3R5bGUsc3RyaW5nPj5cbi8vXG4vLyBBIHN0eWxlIGlzIGFuIG9iamVjdCB0aGF0LCBpbiB0aGUgc2ltcGxlIGNhc2UsIG1hcHMgQ1NTIHByb3BlcnR5XG4vLyBuYW1lcyB0byBzdHJpbmdzIGhvbGRpbmcgdGhlaXIgdmFsdWVzLCBhcyBpbiBge2NvbG9yOiBcInJlZFwiLFxuLy8gZm9udFdlaWdodDogXCJib2xkXCJ9YC4gVGhlIHByb3BlcnR5IG5hbWVzIGNhbiBiZSBnaXZlbiBpblxuLy8gY2FtZWwtY2FzZeKAlHRoZSBsaWJyYXJ5IHdpbGwgaW5zZXJ0IGEgZGFzaCBiZWZvcmUgY2FwaXRhbCBsZXR0ZXJzXG4vLyB3aGVuIGNvbnZlcnRpbmcgdGhlbSB0byBDU1MuXG4vL1xuLy8gSWYgeW91IGluY2x1ZGUgYW4gdW5kZXJzY29yZSBpbiBhIHByb3BlcnR5IG5hbWUsIGl0IGFuZCBldmVyeXRoaW5nXG4vLyBhZnRlciBpdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgb3V0cHV0LCB3aGljaCBjYW4gYmUgdXNlZnVsIHdoZW5cbi8vIHByb3ZpZGluZyBhIHByb3BlcnR5IG11bHRpcGxlIHRpbWVzLCBmb3IgYnJvd3NlciBjb21wYXRpYmlsaXR5XG4vLyByZWFzb25zLlxuLy9cbi8vIEEgcHJvcGVydHkgaW4gYSBzdHlsZSBvYmplY3QgY2FuIGFsc28gYmUgYSBzdWItc2VsZWN0b3IsIHdoaWNoXG4vLyBleHRlbmRzIHRoZSBjdXJyZW50IGNvbnRleHQgdG8gYWRkIGEgcHNldWRvLXNlbGVjdG9yIG9yIGEgY2hpbGRcbi8vIHNlbGVjdG9yLiBTdWNoIGEgcHJvcGVydHkgc2hvdWxkIGNvbnRhaW4gYSBgJmAgY2hhcmFjdGVyLCB3aGljaFxuLy8gd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgY3VycmVudCBzZWxlY3Rvci4gRm9yIGV4YW1wbGUgYHtcIiY6YmVmb3JlXCI6XG4vLyB7Y29udGVudDogJ1wiaGlcIid9fWAuIFN1Yi1zZWxlY3RvcnMgYW5kIHJlZ3VsYXIgcHJvcGVydGllcyBjYW5cbi8vIGZyZWVseSBiZSBtaXhlZCBpbiBhIGdpdmVuIG9iamVjdC4gQW55IHByb3BlcnR5IGNvbnRhaW5pbmcgYSBgJmAgaXNcbi8vIGFzc3VtZWQgdG8gYmUgYSBzdWItc2VsZWN0b3IuXG4vL1xuLy8gRmluYWxseSwgYSBwcm9wZXJ0eSBjYW4gc3BlY2lmeSBhbiBALWJsb2NrIHRvIGJlIHdyYXBwZWQgYXJvdW5kIHRoZVxuLy8gc3R5bGVzIGRlZmluZWQgaW5zaWRlIHRoZSBvYmplY3QgdGhhdCdzIHRoZSBwcm9wZXJ0eSdzIHZhbHVlLiBGb3Jcbi8vIGV4YW1wbGUgdG8gY3JlYXRlIGEgbWVkaWEgcXVlcnkgeW91IGNhbiBkbyBge1wiQG1lZGlhIHNjcmVlbiBhbmRcbi8vIChtaW4td2lkdGg6IDQwMHB4KVwiOiB7Li4ufX1gLlxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/style-mod/src/style-mod.js\n");

/***/ })

};
;